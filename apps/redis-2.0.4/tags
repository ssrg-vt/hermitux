!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
0.x / 1.0	doc/RoadMap.html	/^<h2><a name="0.x \/ 1.0">0.x \/ 1.0<\/a><\/h2><ul><li> TODO: Add 1.0 Features. This is important for clarity in <a href="SupportedLanguages.html">SupportedLanguages<\/a><\/li><\/ul>$/;"	a
::redis::__dispatch__	tests/support/redis.tcl	/^proc ::redis::__dispatch__ {id method args} {$/;"	p
::redis::__method__blocking	tests/support/redis.tcl	/^proc ::redis::__method__blocking {id fd val} {$/;"	p
::redis::__method__channel	tests/support/redis.tcl	/^proc ::redis::__method__channel {id fd} {$/;"	p
::redis::__method__close	tests/support/redis.tcl	/^proc ::redis::__method__close {id fd} {$/;"	p
::redis::__method__read	tests/support/redis.tcl	/^proc ::redis::__method__read {id fd} {$/;"	p
::redis::redis_bulk_read	tests/support/redis.tcl	/^proc ::redis::redis_bulk_read {fd} {$/;"	p
::redis::redis_call_callback	tests/support/redis.tcl	/^proc ::redis::redis_call_callback {id type reply} {$/;"	p
::redis::redis_multi_bulk_read	tests/support/redis.tcl	/^proc ::redis::redis_multi_bulk_read fd {$/;"	p
::redis::redis_read_line	tests/support/redis.tcl	/^proc ::redis::redis_read_line fd {$/;"	p
::redis::redis_read_reply	tests/support/redis.tcl	/^proc ::redis::redis_read_reply fd {$/;"	p
::redis::redis_readable	tests/support/redis.tcl	/^proc ::redis::redis_readable {fd id} {$/;"	p
::redis::redis_readnl	tests/support/redis.tcl	/^proc ::redis::redis_readnl {fd len} {$/;"	p
::redis::redis_reset_state	tests/support/redis.tcl	/^proc ::redis::redis_reset_state id {$/;"	p
::redis::redis_write	tests/support/redis.tcl	/^proc ::redis::redis_write {fd buf} {$/;"	p
::redis::redis_writenl	tests/support/redis.tcl	/^proc ::redis::redis_writenl {fd buf} {$/;"	p
A case study: Design and implementation of a simple Twitter clone using only the Redis key-value store as database and PHP	doc/TwitterAlikeExample.html	/^                    <h1><a name="A case study: Design and implementation of a simple Twitter clone using only the Redis key-value store as database and PHP">A case study: Design and implementation of a simple Twitter clone using only the Redis key-value store as database and PHP<\/a><\/h1>In this article I'll explain the design and the implementation of a <a href="http:\/\/retwis.antirez.com" target="_blank">simple clone of Twitter<\/a> written using PHP and <a href="http:\/\/code.google.com\/p\/redis\/" target="_blank">Redis<\/a> as only database. The programming community uses to look at key-value stores like special databases that can't be used as drop in replacement for a relational database for the development of web applications. This article will try to prove the contrary.<br\/><br\/>Our Twitter clone, <a href="http:\/\/retwis.antirez.com" target="_blank">called Retwis<\/a>, is structurally simple, has very good performances, and can be distributed among N web servers and M Redis servers with very little efforts. You can find the source code <a href="http:\/\/code.google.com\/p\/redis\/downloads\/list" target="_blank">here<\/a>.<br\/><br\/>We use PHP for the example since it can be read by everybody. The same (or... much better) results can be obtained using Ruby, Python, Erlang, and so on.<br\/><br\/><b>News! <a href="http:\/\/retwisrb.danlucraft.com\/" target="_blank">Retwis-rb<\/a> is a port of Retwis to Ruby and Sinatra written by Daniel Lucraft!<\/b> With full source code included of course, the git repository is linked at the end of the Retwis-RB page. The rest of this article targets PHP, but Ruby programmers can also check the other source code, it conceptually very similar.<h1><a name="Key-value stores basics">Key-value stores basics<\/a><\/h1>$/;"	a
A digression. How to get unique identifiers for strings	doc/IntroductionToRedisDataTypes.html	/^<\/pre>Look at the <a href="CommandReference.html">Command Reference<\/a> to discover other Set related commands, there are a bunch of interesting one. Also make sure to check the <a href="SortCommand.html">SORT<\/a> command as both Redis Sets and Lists are sortable.<h2><a name="A digression. How to get unique identifiers for strings">A digression. How to get unique identifiers for strings<\/a><\/h2>In our tags example we showed tag IDs without to mention how this IDs can be obtained. Basically for every tag added to the system, you need an unique identifier. You also want to be sure that there are no race conditions if multiple clients are trying to add the same tag at the same time. Also, if a tag already exists, you want its ID returned, otherwise a new unique ID should be created and associated to the tag.<br\/><br\/>Redis 1.4 will add the Hash type. With it it will be trivial to associate strings with unique IDs, but how to do this today with the current commands exported by Redis in a reliable way?<br\/><br\/>Our first attempt (that is broken) can be the following. Let's suppose we want to get an unique ID for the tag &quot;redis&quot;:<br\/><br\/><ul><li> In order to make this algorithm binary safe (they are just tags but think to utf8, spaces and so forth) we start performing the SHA1 sum of the tag. SHA1(redis) = b840fc02d524045429941cc15f59e41cb7be6c52.<\/li><li> Let's check if this tag is already associated with an unique ID with the command <b>GET tag:b840fc02d524045429941cc15f59e41cb7be6c52:id<\/b>.<\/li><li> If the above GET returns an ID, return it back to the user. We already have the unique ID.<\/li><li> Otherwise... create a new unique ID with <b>INCR next.tag.id<\/b> (assume it returned 123456).<\/li><li> Finally associate this new ID to our tag with <b>SET tag:b840fc02d524045429941cc15f59e41cb7be6c52:id 123456<\/b> and return the new ID to the caller.<\/li><\/ul>$/;"	a
A few new commands about already supported data types	doc/Redis_1_2_0_Changelog.html	/^<h2><a name="A few new commands about already supported data types">A few new commands about already supported data types<\/a><\/h2><ul><li> <a href="SrandmemberCommand.html">SRANDMEMBER<\/a><\/li><li> The <a href="SortCommand.html">SortCommand<\/a> is now supprots the <b>STORE<\/b> and <b>GET #<\/b> forms, the first can be used to save sorted lists, sets or sorted sets into keys for caching. Check the manual page for more information about the <b>GET #<\/b> form.<\/li><li> The new <a href="RpoplpushCommand.html">RPOPLPUSH command<\/a> can do many interesting magics, and a few of this are documented in the wiki page of the command.<\/li><\/ul>$/;"	a
A fifteen minutes introduction to Redis data types	doc/IntroductionToRedisDataTypes.html	/^<h1><a name="A fifteen minutes introduction to Redis data types">A fifteen minutes introduction to Redis data types<\/a><\/h1>As you already probably know Redis is not a plain key-value store, actually it is a <b>data structures server<\/b>, supporting different kind of values. That is, you can't just set strings as values of keys. All the following data types are supported as values:<br\/><br\/><ul><li> Binary-safe strings.<\/li><li> Lists of binary-safe strings.<\/li><li> Sets of binary-safe strings, that are collection of unique unsorted elements. You can think at this as a Ruby hash where all the keys are set to the 'true' value.<\/li><li> Sorted sets, similar to Sets but where every element is associated to a floating number score. The elements are taken sorted by score. You can think at this as Ruby hashes where the key is the element and the value is the score, but where elements are always taken in order without requiring a sorting operation.<\/li><\/ul>$/;"	a
A good place for the swap file	doc/VirtualMemoryUserGuide.html	/^<h2><a name="A good place for the swap file">A good place for the swap file<\/a><\/h2>In many configurations the swap file can be fairly large, even 40GB or more.$/;"	a
AE_ALL_EVENTS	ae.h	47;"	d
AE_DONT_WAIT	ae.h	48;"	d
AE_ERR	ae.h	39;"	d
AE_FILE_EVENTS	ae.h	45;"	d
AE_NOMORE	ae.h	50;"	d
AE_NONE	ae.h	41;"	d
AE_NOTUSED	ae.h	53;"	d
AE_OK	ae.h	38;"	d
AE_READABLE	ae.h	42;"	d
AE_SETSIZE	ae.h	36;"	d
AE_TIME_EVENTS	ae.h	46;"	d
AE_WRITABLE	ae.h	43;"	d
AL_START_HEAD	adlist.h	88;"	d
AL_START_TAIL	adlist.h	89;"	d
ANET_CONNECT_NONBLOCK	anet.c	130;"	d	file:
ANET_CONNECT_NONE	anet.c	129;"	d	file:
ANET_ERR	anet.h	35;"	d
ANET_ERR_LEN	anet.h	36;"	d
ANET_H	anet.h	32;"	d
ANET_OK	anet.h	34;"	d
APPEND _key_ _value_	doc/AppendCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="APPEND _key_ _value_">APPEND _key_ _value_<\/a><\/h1>$/;"	a
APPENDFSYNC_ALWAYS	redis.c	232;"	d	file:
APPENDFSYNC_EVERYSEC	redis.c	233;"	d	file:
APPENDFSYNC_NO	redis.c	231;"	d	file:
AUTH _password_	doc/AuthCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ConnectionHandlingSidebar.html">ConnectionHandlingSidebar<\/a><h1><a name="AUTH _password_">AUTH _password_<\/a><\/h1><blockquote>Request for authentication in a password protected Redis server.A Redis server can be instructed to require a password before to allow clientsto issue commands. This is done using the <i>requirepass<\/i> directive in theRedis configuration file.<\/blockquote>$/;"	a
AVOID_ERRNO	lzfP.h	100;"	d
Aborting I/O jobs	doc/VirtualMemorySpecification.html	/^<h2><a name="Aborting I\/O jobs">Aborting I\/O jobs<\/a><\/h2>$/;"	a
All data in memory, but saved on disk	doc/README.html	/^<\/pre>You can also add and remove elements from a set, and perform intersections, unions, and differences. <br\/><br\/>Redis can also be looked at as a data structures server. A Redis user is virtually provided with an interface to  <a href="http:\/\/en.wikipedia.org\/wiki\/Abstract_data_type" target="_blank">Abstract Data Types<\/a>, saving them from the responsibility of implementing concrete data structures and algorithms -- indeed both algorithms and data structures in Redis are properly chosen in order to obtain the best performance.<h1><a name="All data in memory, but saved on disk">All data in memory, but saved on disk<\/a><\/h1>Redis loads and mantains the whole dataset into memory, but the dataset is persistent, since at the same time it is saved on disk, so that when the server is restarted data can be loaded back in memory.<br\/><br\/>There are two kinds of persistence supported: the first one is called snapshotting. In this mode Redis periodically writes to disk asynchronously. The dataset is loaded from the dump every time the server is (re)started.<br\/><br\/>Redis can be configured to save the dataset when a certain number of changes is reached and after a given number of seconds elapses. For example, you can configure Redis to save after 1000 changes and at most 60 seconds since the last save. You can specify any combination for these numbers.<br\/><br\/>Because data is written asynchronously, when a system crash occurs, the last few queries can get lost (that is acceptable in many applications but not in all).  In order to make this a non issue Redis supports another, safer persistence mode, called <a href="AppendOnlyFileHowto.html">Append Only File<\/a>, where every command received altering the dataset (so not a read-only command, but a write command) is written on an append only file ASAP. This commands are <i>replayed<\/i> when the server is restarted in order to rebuild the dataset in memory.<br\/><br\/>Redis Append Only File supports a very handy feature: the server is able to safely rebuild the append only file in background in a non-blocking fashion when it gets too long. You can find <a href="AppendOnlyFileHowto.html">more details in the Append Only File HOWTO<\/a>.<h1><a name="Master-Slave replication made trivial">Master-Slave replication made trivial<\/a><\/h1>Whatever will be the persistence mode you'll use Redis supports master-slave replications if you want to stay really safe or if you need to scale to huge amounts of reads.<br\/><br\/><b>Redis Replication is trivial to setup<\/b>. So trivial that all you need to do in order to configure a Redis server to be a slave of another one, with automatic synchronization if the link will go down and so forth, is the following config line: <code name="code" class="python">slaveof 192.168.1.100 6379<\/code>. <a href="ReplicationHowto.html">We provide a Replication Howto<\/a> if you want to know more about this feature.<h1><a name="It's persistent but supports expires">It's persistent but supports expires<\/a><\/h1>Redis can be used as a <b>memcached on steroids<\/b> because is as fast as memcached but with a number of features more. Like memcached, Redis also supports setting timeouts to keys so that this key will be automatically removed when a given amount of time passes.<h1><a name="Beyond key-value databases">Beyond key-value databases<\/a><\/h1>All these features allow to use Redis as the sole DB for your scalable application without the need of any relational database. <a href="TwitterAlikeExample.html">We wrote a simple Twitter clone in PHP + Redis<\/a> to show a real world example, the link points to an article explaining the design and internals in very simple words.<h1><a name="Multiple databases support">Multiple databases support<\/a><\/h1>Redis supports multiple databases with commands to atomically move keys from one database to the other. By default DB 0 is selected for every new connection, but using the SELECT command it is possible to select a different database. The MOVE operation can move an item from one DB to another atomically. This can be used as a base for locking free algorithms together with the 'RANDOMKEY' commands.<h1><a name="Know more about Redis!">Know more about Redis!<\/a><\/h1>To really get a feeling about what Redis is and how it works please try reading <a href="IntroductionToRedisDataTypes.html">A fifteen minutes introduction to Redis data types<\/a>.<br\/><br\/>To know a bit more about how Redis works <i>internally<\/i> continue reading.<h1><a name="Redis Tutorial">Redis Tutorial<\/a><\/h1>(note, you can skip this section if you are only interested in &quot;formal&quot; doc.)<br\/><br\/>Later in this document you can find detailed information about Redis commands,$/;"	a
AnyEvent::Redis	doc/SupportedLanguages.html	/^<h4><a name="AnyEvent::Redis">AnyEvent::Redis<\/a><\/h4><ul><li> Non-blocking Redis client.<\/li><li> Author: <a href="http:\/\/bulknews.typepad.com\/" target="_blank">Tatsuhiko Miyagawa<\/a>, <a href="http:\/\/twitter.com\/miyagawa" target="_blank">@miyagawa<\/a>.<\/li><li> Repository: <a href="http:\/\/github.com\/miyagawa\/AnyEvent-Redis\/" target="_blank">http:\/\/github.com\/miyagawa\/AnyEvent-Redis\/<\/a><\/li><\/ul>$/;"	a
Append Only File HOWTO	doc/AppendOnlyFileHowto.html	/^<h1><a name="Append Only File HOWTO">Append Only File HOWTO<\/a><\/h1><h2><a name="General Information">General Information<\/a><\/h2>Append only file is an alternative durability option for Redis. What this mean? Let's start with some fact:<br\/><br\/><ul><li> For default Redis saves snapshots of the dataset on disk, in a binary file called dump.rdb (by default at least). For instance you can configure Redis to save the dataset every 60 seconds if there are at least 100 changes in the dataset, or every 1000 seconds if there is at least a single change in the dataset. This is known as &quot;Snapshotting&quot;.<\/li><li> Snapshotting is not very durable. If your computer running Redis stops, your power line fails, or you write killall -9 redis-server for a mistake, the latest data written on Redis will get lost. There are applications where this is not a big deal. There are applications where this is not acceptable and Redis <b>was<\/b> not an option for this applications.<\/li><\/ul>$/;"	a
Atomic operations	doc/TwitterAlikeExample.html	/^<\/pre><h2><a name="Atomic operations">Atomic operations<\/a><\/h2>$/;"	a
Authentication	doc/TwitterAlikeExample.html	/^<h2><a name="Authentication">Authentication<\/a><\/h2>$/;"	a
BENCHOBJ	Makefile	/^BENCHOBJ = ae.o anet.o redis-benchmark.o sds.o adlist.o zmalloc.o$/;"	m
BENCHPRGNAME	Makefile	/^BENCHPRGNAME = redis-benchmark$/;"	m
BGREWRITEAOF	doc/BgrewriteaofCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ControlCommandsSidebar.html">ControlCommandsSidebar<\/a><h3><a name="BGREWRITEAOF">BGREWRITEAOF<\/a><\/h3>$/;"	a
BGSAVE	doc/BgsaveCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ControlCommandsSidebar.html">ControlCommandsSidebar<\/a><h1><a name="BGSAVE">BGSAVE<\/a><\/h1>$/;"	a
BGSAVE / AOFSAVE memory usage, and copy on write	doc/RedisBigData.html	/^<h2><a name="BGSAVE \/ AOFSAVE memory usage, and copy on write">BGSAVE \/ AOFSAVE memory usage, and copy on write<\/a><\/h2>$/;"	a
BGSAVE / AOFSAVE time for big datasets	doc/RedisBigData.html	/^<h2><a name="BGSAVE \/ AOFSAVE time for big datasets">BGSAVE \/ AOFSAVE time for big datasets<\/a><\/h2>$/;"	a
BGSAVE and BGREWRITEAOF blocking fork() call	doc/RedisBigData.html	/^                    &iuml;&raquo;&iquest;=Redis Big Data: facts and guidelines=<h2><a name="BGSAVE and BGREWRITEAOF blocking fork() call">BGSAVE and BGREWRITEAOF blocking fork() call<\/a><\/h2>$/;"	a
BIG_ENDIAN	sha1.c	40;"	d	file:
BLPOP _key1_ _key2_ ... _keyN_ _timeout_ (Redis &gt;	doc/BlpopCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="BLPOP _key1_ _key2_ ... _keyN_ _timeout_ (Redis &gt;">BLPOP _key1_ _key2_ ... _keyN_ _timeout_ (Redis &gt;<\/a><\/h1> 1.3.1) =$/;"	a
BRPOP _key1_ _key2_ ... _keyN_ _timeout_ (Redis &gt;	doc/BlpopCommand.html	/^<h1><a name="BRPOP _key1_ _key2_ ... _keyN_ _timeout_ (Redis &gt;">BRPOP _key1_ _key2_ ... _keyN_ _timeout_ (Redis &gt;<\/a><\/h1> 1.3.1) =$/;"	a
BYTE_ORDER	sha1.c	46;"	d	file:
BYTE_ORDER	sha1.c	56;"	d	file:
BYTE_ORDER	sha1.c	64;"	d	file:
BYTE_ORDER	sha1.c	66;"	d	file:
Back to the reddit example	doc/IntroductionToRedisDataTypes.html	/^<\/pre><a href="ZremrangebyscoreCommand.html">ZREMRANGEBYSCORE<\/a> is not the best command name, but it can be very useful, and returns the number of removed elements.<h3><a name="Back to the reddit example">Back to the reddit example<\/a><\/h3>For the last time, back to the Reddit example. Now we have a decent plan to populate a sorted set in order to generate the home page. A sorted set can contain all the news that are not older than a few days (we remove old entries from time to time using ZREMRANGEBYSCORE). A background job gets all the elements from this sorted set, get the user votes and the time of the news, and compute the score to populate the <b>reddit.home.page<\/b> sorted set with the news IDs and associated scores. To show the home page we have just to perform a blazingly fast call to ZRANGE.<br\/><br\/>From time to time we'll remove too old news from the <b>reddit.home.page<\/b> sorted set as well in order for our system to work always against a limited set of news.<h3><a name="Updating the scores of a sorted set">Updating the scores of a sorted set<\/a><\/h3>Just a final note before to finish this tutorial. Sorted sets scores can be updated at any time. Just calling again ZADD against an element already included in the sorted set will update its score (and position) in O(log(N)), so sorted sets are suitable even when there are tons of updates.<br\/><br\/>This tutorial is in no way complete, this is just the basics to get started with Redis, read the <a href="CommandReference.html">Command Reference<\/a> to discover a lot more.<br\/><br\/>Thanks for reading. Salvatore.$/;"	a
Background saving when VM is active	doc/VirtualMemorySpecification.html	/^<h2><a name="Background saving when VM is active">Background saving when VM is active<\/a><\/h2>$/;"	a
Beyond key-value stores	doc/TwitterAlikeExample.html	/^<h2><a name="Beyond key-value stores">Beyond key-value stores<\/a><\/h2>$/;"	a
Blocking VM loading	doc/VirtualMemorySpecification.html	/^<h2><a name="Blocking VM loading">Blocking VM loading<\/a><\/h2>$/;"	a
Blocking VM swapping	doc/VirtualMemorySpecification.html	/^<h2><a name="Blocking VM swapping">Blocking VM swapping<\/a><\/h2>$/;"	a
Blocking behavior	doc/BlpopCommand.html	/^<h2><a name="Blocking behavior">Blocking behavior<\/a><\/h2><blockquote>If none of the specified keys exist or contain non empty lists, BLPOPblocks until some other client performs a <a href="RpushCommand.html">LPUSH<\/a> oran <a href="RpushCommand.html">RPUSH<\/a> operation against one of the lists.<\/blockquote>$/;"	a
Blocking clients on swapped keys	doc/VirtualMemorySpecification.html	/^<h2><a name="Blocking clients on swapped keys">Blocking clients on swapped keys<\/a><\/h2>$/;"	a
Bug fixing	doc/Redis_1_2_0_Changelog.html	/^<h2><a name="Bug fixing">Bug fixing<\/a><\/h2>Of course, many bugs are now fixed, and I bet, a few others introduced: this is how software works after all, so make sure to report issues in the Redis mailing list or in the Google Code issues tracker.<br\/><br\/>Enjoy!$/;"	a
Bulk commands	doc/ProtocolSpecification.html	/^simply by spaces.<h2><a name="Bulk commands">Bulk commands<\/a><\/h2>A bulk command is exactly like an inline command, but the last argument$/;"	a
Bulk replies	doc/ProtocolSpecification.html	/^<h2><a name="Bulk replies">Bulk replies<\/a><\/h2>The server may reply to an inline or bulk command with a bulk reply. See$/;"	a
Bulk reply	doc/ReplyTypes.html	/^At protocol level integer replies are single line replies in form of a decimal singed number prefixed by a <b>:<\/b> character. For example <b>:10<\/b> is an integer reply. Redis commands returning <i>true<\/i> or <i>false<\/i> will use an integer reply with 0 or 1 as values where 0 is false and 1 is true.<br\/><br\/>Integer replies are usually passed by client libraries as integer values.<h1><a name="Bulk reply">Bulk reply<\/a><\/h1>$/;"	a
CC	Makefile	/^CC=..\/..\/musl\/prefix\/bin\/musl-gcc$/;"	m
CCLINK	Makefile	/^  CCLINK?= -ldl -lnsl -lsocket -lm -lpthread$/;"	m
CCLINK	Makefile	/^  CCLINK?= -lm -pthread$/;"	m
CCOPT	Makefile	/^CCOPT= $(CFLAGS) $(CCLINK) $(ARCH) $(PROF)$/;"	m
CFLAGS	Makefile	/^  CFLAGS?= -std=c99 -pedantic $(OPTIMIZATION) -Wall -W $(ARCH) $(PROF)$/;"	m
CFLAGS	Makefile	/^  CFLAGS?= -std=c99 -pedantic $(OPTIMIZATION) -Wall -W -D__EXTENSIONS__ -D_XPG6$/;"	m
CHANGELOG for Redis 0.900	doc/Redis0900ChangeLog.html	/^                    <h1><a name="CHANGELOG for Redis 0.900">CHANGELOG for Redis 0.900<\/a><\/h1><pre class="codeblock python" name="code">$/;"	a
CHANGELOG for Redis 1.1.90	doc/Redis_1_2_0_Changelog.html	/^antirez<h1><a name="CHANGELOG for Redis 1.1.90">CHANGELOG for Redis 1.1.90<\/a><\/h1><ul><li> 2009-09-10 in-memory specialized object encoding. (antirez)<\/li><li> 2009-09-17 maxmemory fixed in 64 systems for values &gt; 4GB. (antirez)<\/li><li> 2009-10-07 multi-bulk protocol implemented. (antriez)<\/li><li> 2009-10-16 MSET and MSETNX commands implemented (antirez)<\/li><li> 2009-10-21 SRANDMEMBER added (antirez)<\/li><li> 2009-10-23 Fixed compilation in mac os x snow leopard when compiling a 32 bit binary.  (antirez)<\/li><li> 2009-10-23 New data type: Sorted sets and Z-commands (antirez)<\/li><li> 2009-10-26 Solaris fixed (Alan Harder)<\/li><li> 2009-10-29 Fixed Issue a number of open issues (antirez)<\/li><li> 2009-10-30 New persistence mode: append only file (antirez)<\/li><li> 2009-11-01 SORT STORE option (antirez)<\/li><li> 2009-11-03 redis-cli now accepts a -r (repeat) switch. (antirez)<\/li><li> 2009-11-04 masterauth option merged (Anthony Lauzon)<\/li><li> 2009-11-04 redis-test is now a better Redis citizen, testing everything against DB 9 and 10 and only if this DBs are empty. (antirez)<\/li><li> 2009-11-10 Implemented a much better lazy expiring algorithm for EXPIRE (antirez)<\/li><li> 2009-11-11 RPUSHLPOP (antirez from an idea of @ezmobius)<\/li><li> 2009-11-12 Merge git:\/\/github.com\/ianxm\/redis (Can't remmber what this implements, sorry)<\/li><li> 2009-11-17 multi-bulk reply support for redis-bench, LRANGE speed tests (antirez)<\/li><li> 2009-11-17 support for writev implemented. (Stefano Barbato)<\/li><li> 2009-11-19 debug mode (-D) in redis-bench (antirez)<\/li><li> 2009-11-21 SORT GET # implemented (antirez)<\/li><li> 2009-11-23 ae.c made modular, with support for epoll. (antirez)<\/li><li> 2009-11-26 background append log rebuilding (antirez)<\/li><li> 2009-11-28 Added support for kqueue. (Harish Mallipeddi)<\/li><li> 2009-11-29 SORT support for sorted sets (antirez, thanks to @tobi for the idea)<\/li><\/ul>$/;"	a
CHECKAOFOBJ	Makefile	/^CHECKAOFOBJ = redis-check-aof.o$/;"	m
CHECKAOFPRGNAME	Makefile	/^CHECKAOFPRGNAME = redis-check-aof$/;"	m
CHECKDUMPOBJ	Makefile	/^CHECKDUMPOBJ = redis-check-dump.o lzf_c.o lzf_d.o$/;"	m
CHECKDUMPPRGNAME	Makefile	/^CHECKDUMPPRGNAME = redis-check-dump$/;"	m
CHECK_INPUT	lzfP.h	121;"	d
CL-Redis (Common Lisp)	doc/SupportedLanguages.html	/^<h3><a name="CL-Redis (Common Lisp)">CL-Redis (Common Lisp)<\/a><\/h3><ul><li> Common Lisp client library for Redis, an advanced key\/value store.<\/li><li> Home Page: <a href="http:\/\/www.cliki.net\/cl-redis" target="_blank">http:\/\/www.cliki.net\/cl-redis<\/a><\/li><li> Author: Mahmud, <a href="http:\/\/twitter.com\/BigThingist" target="_blank">@BigThingist<\/a>.<\/li><\/ul>$/;"	a
CLIENT_CONNECTING	redis-benchmark.c	53;"	d	file:
CLIENT_READREPLY	redis-benchmark.c	55;"	d	file:
CLIENT_SENDQUERY	redis-benchmark.c	54;"	d	file:
CLIOBJ	Makefile	/^CLIOBJ = anet.o sds.o adlist.o redis-cli.o zmalloc.o linenoise.o$/;"	m
CLIPRGNAME	Makefile	/^CLIPRGNAME = redis-cli$/;"	m
COMMAND_1 ...	doc/MultiExecCommand.html	/^<h1><a name="COMMAND_1 ...">COMMAND_1 ...<\/a><\/h1>$/;"	a
COMMAND_2 ...	doc/MultiExecCommand.html	/^<h1><a name="COMMAND_2 ...">COMMAND_2 ...<\/a><\/h1>$/;"	a
COMMAND_N ...	doc/MultiExecCommand.html	/^<h1><a name="COMMAND_N ...">COMMAND_N ...<\/a><\/h1>$/;"	a
CONFIG GET _pattern_	doc/ConfigCommand.html	/^<h2><a name="CONFIG GET _pattern_">CONFIG GET _pattern_<\/a><\/h2><blockquote>CONFIG GET returns the current configuration parameters. This sub commandonly accepts a single argument, that is glob style pattern. All theconfiguration parameters matching this parameter are reported as alist of key-value pairs. Example:<\/blockquote><pre class="codeblock python" name="code">$/;"	a
CONFIG GET _pattern_ (Redis &gt;	doc/ConfigCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ControlCommandsSidebar.html">ControlCommandsSidebar<\/a><h1><a name="CONFIG GET _pattern_ (Redis &gt;">CONFIG GET _pattern_ (Redis &gt;<\/a><\/h1> 2.0)=$/;"	a
CONFIG SET _parameter_ _value_	doc/ConfigCommand.html	/^<\/pre>The return type of the command is a <a href="ReplyTypes.html">bulk reply<\/a>.<h2><a name="CONFIG SET _parameter_ _value_">CONFIG SET _parameter_ _value_<\/a><\/h2><blockquote>CONFIG SET is used in order to reconfigure the server, setting a specificconfiguration parameter to a new value.<\/blockquote>$/;"	a
CONFIG SET _parameter_ _value_ (Redis &gt;	doc/ConfigCommand.html	/^<h1><a name="CONFIG SET _parameter_ _value_ (Redis &gt;">CONFIG SET _parameter_ _value_ (Redis &gt;<\/a><\/h1> 2.0)=<br\/><br\/><blockquote>The CONFIG command is able to retrieve or alter the configuration of a runningRedis server. Not all the configuration parameters are supported.<\/blockquote>$/;"	a
CURR_OFFSET	redis-check-dump.c	75;"	d	file:
Categorized Command List	doc/CommandReference.html	/^                    &iuml;&raquo;&iquest;= Redis Command Reference =<br\/><br\/>Every command name links to a specific wiki page describing the behavior of the command.<h2><a name="Categorized Command List">Categorized Command List<\/a><\/h2><h2><a name="Connection handling">Connection handling<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="QuitCommand.html">QUIT<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> - <\/td><td style="border: 1px solid #aaa; padding: 5px;">  close the connection <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="AuthCommand.html">AUTH<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>password<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  simple password authentication if enabled  <\/td><\/tr><\/table>$/;"	a
Check and Set (CAS) transactions using WATCH	doc/MultiExecCommand.html	/^<\/pre><h2><a name="Check and Set (CAS) transactions using WATCH">Check and Set (CAS) transactions using WATCH<\/a><\/h2>WATCH is used in order to provide a CAS (Check and Set) behavior to$/;"	a
Client Libraries Reference	doc/SupportedLanguages.html	/^<h2><a name="Client Libraries Reference">Client Libraries Reference<\/a><\/h2><h3><a name="as3 (ActionScript 3)">as3 (ActionScript 3)<\/a><\/h3><ul><li> An ActionScript 3 (Flash) library for Redis.<\/li><li> Repository: <a href="http:\/\/github.com\/claus\/as3redis" target="_blank">http:\/\/github.com\/claus\/as3redis<\/a><\/li><li> Author: Claus Wahlers, <a href="http:\/\/twitter.com\/cwahlers" target="_blank">        @cwahlers<\/a>.<\/li><\/ul>$/;"	a
Client library implementations hints	doc/PublishSubscribe.html	/^<h2><a name="Client library implementations hints">Client library implementations hints<\/a><\/h2>$/;"	a
Commands operating on all value types	doc/CommandReference.html	/^<h2><a name="Commands operating on all value types">Commands operating on all value types<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ExistsCommand.html">EXISTS<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  test if a key exists  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="DelCommand.html">DEL<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  delete a key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="TypeCommand.html">TYPE<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  return the type of the value stored at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="KeysCommand.html">KEYS<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>pattern<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  return all the keys matching a given pattern  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="RandomkeyCommand.html">RANDOMKEY<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> - <\/td><td style="border: 1px solid #aaa; padding: 5px;">  return a random key from the key space  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="RenameCommand.html">RENAME<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>oldname<\/i> <i>newname<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  rename the old key in the new one, destroying the newname key if it already exists  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="RenamenxCommand.html">RENAMENX<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>oldname<\/i> <i>newname<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  rename the <i>oldname<\/i> key to <i>newname<\/i>, if the <i>newname<\/i> key does not already exist  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="DbsizeCommand.html">DBSIZE<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> - <\/td><td style="border: 1px solid #aaa; padding: 5px;">  return the number of keys in the current db  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ExpireCommand.html">EXPIRE<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> - <\/td><td style="border: 1px solid #aaa; padding: 5px;">  set a time to live in seconds on a key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ExpireCommand.html">PERSIST<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> - <\/td><td style="border: 1px solid #aaa; padding: 5px;">  remove the expire from a key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="TtlCommand.html">TTL<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> - <\/td><td style="border: 1px solid #aaa; padding: 5px;">  get the time to live in seconds of a key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SelectCommand.html">SELECT<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>index<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Select the DB with the specified index  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="MoveCommand.html">MOVE<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>dbindex<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Move the key from the currently selected DB to the <i>dbindex<\/i> DB   <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="FlushdbCommand.html">FLUSHDB<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> - <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Remove all the keys from the currently selected DB  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="FlushallCommand.html">FLUSHALL<\/a><\/td><td style="border: 1px solid #aaa; padding: 5px;"> - <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Remove all the keys from all the databases  <\/td><\/tr><\/table>$/;"	a
Commands operating on hashes	doc/CommandReference.html	/^<h2><a name="Commands operating on hashes">Commands operating on hashes<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HsetCommand.html">HSET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>field<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Set the hash field to the specified value. Creates the hash if needed.  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HgetCommand.html">HGET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>field<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Retrieve the value of the specified hash field.  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HmgetCommand.html">HMGET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>field1<\/i> ... <i>fieldN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Get the hash values associated to the specified fields.  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HmsetCommand.html">HMSET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>field1<\/i> <i>value1<\/i> ... <i>fieldN<\/i> <i>valueN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Set the hash fields to their respective values.  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HincrbyCommand.html">HINCRBY<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  <i>key<\/i> <i>field<\/i> <i>integer<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Increment the integer value of the hash at <i>key<\/i> on <i>field<\/i> with <i>integer<\/i>.  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HexistsCommand.html">HEXISTS<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>field<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Test for existence of a specified field in a hash  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HdelCommand.html">HDEL<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>field<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Remove the specified field from a hash  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HlenCommand.html">HLEN<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">   Return the number of items in a hash.  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HgetallCommand.html">HKEYS<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return all the fields in a hash.  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HgetallCommand.html">HVALS<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Return all the values in a hash.  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="HgetallCommand.html">HGETALL<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Return all the fields and associated values in a hash.  <\/td><\/tr><\/table>$/;"	a
Commands operating on lists	doc/CommandReference.html	/^<h2><a name="Commands operating on lists">Commands operating on lists<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="RpushCommand.html">RPUSH<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Append an element to the tail of the List value at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="RpushCommand.html">LPUSH<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Append an element to the head of the List value at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="LlenCommand.html">LLEN<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the length of the List value at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="LrangeCommand.html">LRANGE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>start<\/i> <i>end<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return a range of elements from the List at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="LtrimCommand.html">LTRIM<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>start<\/i> <i>end<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Trim the list at key to the specified range of elements  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="LindexCommand.html">LINDEX<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>index<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the element at index position from the List at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="LsetCommand.html">LSET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>index<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Set a new value as the element at index position of the List at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="LremCommand.html">LREM<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>count<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Remove the first-N, last-N, or all the elements matching value from the List at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="LpopCommand.html">LPOP<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return and remove (atomically) the first element of the List at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="LpopCommand.html">RPOP<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return and remove (atomically) the last element of the List at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="BlpopCommand.html">BLPOP<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key1<\/i> <i>key2<\/i> ... <i>keyN<\/i> <i>timeout<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Blocking LPOP  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="BlpopCommand.html">BRPOP<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key1<\/i> <i>key2<\/i> ... <i>keyN<\/i> <i>timeout<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Blocking RPOP  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="RpoplpushCommand.html">RPOPLPUSH<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>srckey<\/i> <i>dstkey<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return and remove (atomically) the last element of the source List stored at <i>srckey<\/i> and push the same element to the destination List stored at <i>dstkey<\/i>  <\/td><\/tr><\/table>$/;"	a
Commands operating on sets	doc/CommandReference.html	/^<h2><a name="Commands operating on sets">Commands operating on sets<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SaddCommand.html">SADD<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>member<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Add the specified member to the Set value at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SremCommand.html">SREM<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>member<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Remove the specified member from the Set value at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SpopCommand.html">SPOP<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Remove and return (pop) a random element from the Set value at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SmoveCommand.html">SMOVE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>srckey<\/i> <i>dstkey<\/i> <i>member<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Move the specified member from one Set to another atomically  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ScardCommand.html">SCARD<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the number of elements (the cardinality) of the Set at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SismemberCommand.html">SISMEMBER<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>member<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Test if the specified value is a member of the Set at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SinterCommand.html">SINTER<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key1<\/i> <i>key2<\/i> ... <i>keyN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the intersection between the Sets stored at key1, key2, ..., keyN  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SinterstoreCommand.html">SINTERSTORE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>dstkey<\/i> <i>key1<\/i> <i>key2<\/i> ... <i>keyN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Compute the intersection between the Sets stored at key1, key2, ..., keyN, and store the resulting Set at dstkey  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SunionCommand.html">SUNION<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key1<\/i> <i>key2<\/i> ... <i>keyN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the union between the Sets stored at key1, key2, ..., keyN  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SunionstoreCommand.html">SUNIONSTORE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>dstkey<\/i> <i>key1<\/i> <i>key2<\/i> ... <i>keyN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Compute the union between the Sets stored at key1, key2, ..., keyN, and store the resulting Set at dstkey  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SdiffCommand.html">SDIFF<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key1<\/i> <i>key2<\/i> ... <i>keyN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the difference between the Set stored at key1 and all the Sets key2, ..., keyN  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SdiffstoreCommand.html">SDIFFSTORE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>dstkey<\/i> <i>key1<\/i> <i>key2<\/i> ... <i>keyN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Compute the difference between the Set key1 and all the Sets key2, ..., keyN, and store the resulting Set at dstkey  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SmembersCommand.html">SMEMBERS<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return all the members of the Set value at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SrandmemberCommand.html">SRANDMEMBER<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return a random member of the Set value at key  <\/td><\/tr><\/table>$/;"	a
Commands operating on sorted zsets (sorted sets)	doc/CommandReference.html	/^<h2><a name="Commands operating on sorted zsets (sorted sets)">Commands operating on sorted zsets (sorted sets)<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZaddCommand.html">ZADD<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>score<\/i> <i>member<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Add the specified member to the Sorted Set value at key or update the score if it already exist  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZremCommand.html">ZREM<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>member<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Remove the specified member from the Sorted Set value at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZincrbyCommand.html">ZINCRBY<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>increment<\/i> <i>member<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  If the member already exists increment its score by <i>increment<\/i>, otherwise add the member setting <i>increment<\/i> as score  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZrankCommand.html">ZRANK<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>member<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the rank (or index) or <i>member<\/i> in the sorted set at <i>key<\/i>, with scores being ordered from low to high  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZrankCommand.html">ZREVRANK<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>member<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the rank (or index) or <i>member<\/i> in the sorted set at <i>key<\/i>, with scores being ordered from high to low  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZrangeCommand.html">ZRANGE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>start<\/i> <i>end<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return a range of elements from the sorted set at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZrangeCommand.html">ZREVRANGE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>start<\/i> <i>end<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return a range of elements from the sorted set at key, exactly like ZRANGE, but the sorted set is ordered in traversed in reverse order, from the greatest to the smallest score  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZrangebyscoreCommand.html">ZRANGEBYSCORE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>min<\/i> <i>max<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return all the elements with score &gt;= min and score &lt;= max (a range query) from the sorted set  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZrangebyscoreCommand.html">ZCOUNT<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>min<\/i> <i>max<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the number of elements with score &gt;= min and score &lt;= max in the sorted set  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZcardCommand.html">ZCARD<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the cardinality (number of elements) of the sorted set at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZscoreCommand.html">ZSCORE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>element<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the score associated with the specified element of the sorted set at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZremrangebyrankCommand.html">ZREMRANGEBYRANK<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>min<\/i> <i>max<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Remove all the elements with rank &gt;= min and rank &lt;= max from the sorted set  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZremrangebyscoreCommand.html">ZREMRANGEBYSCORE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>min<\/i> <i>max<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Remove all the elements with score &gt;= min and score &lt;= max from the sorted set  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ZunionstoreCommand.html">ZUNIONSTORE \/ ZINTERSTORE<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>dstkey<\/i> <i>N<\/i> <i>key1<\/i> ... <i>keyN<\/i> WEIGHTS <i>w1<\/i> ... <i>wN<\/i> AGGREGATE SUM|MIN|MAX  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Perform a union or intersection over a number of sorted sets with optional weight and aggregate  <\/td><\/tr><\/table>$/;"	a
Commands operating on string values	doc/CommandReference.html	/^<h2><a name="Commands operating on string values">Commands operating on string values<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SetCommand.html">SET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Set a <i>key<\/i> to a string <i>value<\/i>  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="GetCommand.html">GET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the string value of the <i>key<\/i>  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="GetsetCommand.html">GETSET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Set a key to a string returning the old value of the key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="MgetCommand.html">MGET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key1<\/i> <i>key2<\/i> ... <i>keyN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Multi-get, return the strings values of the keys  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SetnxCommand.html">SETNX<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Set a key to a string value if the key does not exist  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SetexCommand.html">SETEX<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>time<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Set+Expire combo command  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="MsetCommand.html">MSET<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key1<\/i> <i>value1<\/i> <i>key2<\/i> <i>value2<\/i> ... <i>keyN<\/i> <i>valueN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Set multiple keys to multiple values in a single atomic operation   <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="MsetCommand.html">MSETNX<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key1<\/i> <i>value1<\/i> <i>key2<\/i> <i>value2<\/i> ... <i>keyN<\/i> <i>valueN<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Set multiple keys to multiple values in a single atomic operation if none of the keys already exist  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="IncrCommand.html">INCR<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Increment the integer value of key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="IncrCommand.html">INCRBY<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>integer<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Increment the integer value of <i>key<\/i> by <i>integer<\/i>  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="IncrCommand.html">DECR<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Decrement the integer value of key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="IncrCommand.html">DECRBY<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>integer<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Decrement the integer value of <i>key<\/i> by <i>integer<\/i>  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="AppendCommand.html">APPEND<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>value<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Append the specified string to the string stored at key  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SubstrCommand.html">SUBSTR<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> <i>start<\/i> <i>end<\/i>  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return a substring of a larger string  <\/td><\/tr><\/table>$/;"	a
Compile	doc/QuickStart.html	/^<\/pre><h2><a name="Compile">Compile<\/a><\/h2>Redis can be compiled in most <a href="SupportedPlatforms.html">POSIX systems<\/a>. To compile Redis just untar the tar.gz, enter the directly and type 'make'.<br\/><br\/><pre class="codeblock python python python" name="code">$/;"	a
Congestion Control	doc/UDP.html	/^<\/pre>The only reply type that needs proper parsing is the multi bulk reply. All the other replies can be processed just looking at the first byte and calling a straightforward function.<h2><a name="Congestion Control">Congestion Control<\/a><\/h2>UDP lacks built-in support for congestion control. In this first stage the$/;"	a
Consistency with range functions in various programming languages	doc/LrangeCommand.html	/^the list, -2 the penultimate element and so on.<h2><a name="Consistency with range functions in various programming languages">Consistency with range functions in various programming languages<\/a><\/h2>Note that if you have a list of numbers from 0 to 100, LRANGE 0 10 will return$/;"	a
Creating Redis Strings	doc/HackingStrings.html	/^<i>buf<\/i> character array.<h2><a name="Creating Redis Strings">Creating Redis Strings<\/a><\/h2>A new data type named <code name="code" class="python">sds<\/code> is defined in <b>sds.h<\/b> to be a synonymn for a character pointer:<br\/><br\/><pre class="codeblock python python" name="code">$/;"	a
Credits	doc/Credits.html	/^                    <h1><a name="Credits">Credits<\/a><\/h1><ul><li> The Redis server was designed and written by <a href="http:\/\/invece.org" target="_blank">Salvatore Sanfilippo (aka antirez)<\/a><\/li><li> <a href="http:\/\/brainspl.at\/" target="_blank">Ezra Zygmuntowicz (aka ezmobius)<\/a> - Ruby client lib initial version and hacking<\/li><li> <a href="http:\/\/qix.it" target="_blank">Ludovico Magnocavallo (aka ludo)<\/a> - Python clinet lib<\/li><li> <a href="http:\/\/www.adroll.com\/" target="_blank">Valentino Volonghi of Adroll<\/a> - Erlang client lib<\/li><li> <b>brettbender<\/b> - found and fixed a bug in sds.c that caused the server to crash at least on 64 bit systems, and anyway to be buggy since we used the same vararg thing against vsprintf without to call va_start and va_end every time.<\/li><li> <a href="http:\/\/www.rot13.org\/~dpavlin" target="_blank">Dobrica Pavlinusic<\/a> - Perl client lib<\/li><li> Brian Hammond - AUTH command implementation, C++ client lib<\/li><li> <a href="http:\/\/www.clorophilla.net\/" target="_blank">Daniele Alessandri<\/a> - Lua client lib<\/li><li> Corey Stup - C99 cleanups<\/li><li> Taylor Weibley - Ruby client improvements<\/li><li> Bob Potter - Rearrange redisObject struct to reduce memory usage in 64bit environments<\/li><li> Luca Guidi and Brian McKinney - Ruby client improvements<\/li><li> Aman Gupta - SDIFF \/ SDIFFSTORE, other Set operations improvements, ability to disable clients timeout.<\/li><li> Diego Rosario Brogna - Code and ideas about dumping backtrace on sigsegv and similar error conditions.<\/li><\/ul>$/;"	a
DBSIZE	doc/DbsizeCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="DBSIZE">DBSIZE<\/a><\/h1><blockquote>Return the number of keys in the currently selected database.<\/blockquote>$/;"	a
DEBUG	Makefile	/^DEBUG?= -g -rdynamic -ggdb $/;"	m
DECR _key_ _integer_	doc/IncrCommand.html	/^<h1><a name="DECR _key_ _integer_">DECR _key_ _integer_<\/a><\/h1>$/;"	a
DECRBY _key_ _integer_	doc/IncrCommand.html	/^<h1><a name="DECRBY _key_ _integer_">DECRBY _key_ _integer_<\/a><\/h1>$/;"	a
DEL _key1_ _key2_ ... _keyN_	doc/DelCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="DEL _key1_ _key2_ ... _keyN_">DEL _key1_ _key2_ ... _keyN_<\/a><\/h1>$/;"	a
DICT_ERR	dict.h	40;"	d
DICT_HT_INITIAL_SIZE	dict.h	85;"	d
DICT_NOTUSED	dict.h	43;"	d
DICT_OK	dict.h	39;"	d
DICT_STATS_VECTLEN	dict.c	600;"	d	file:
Data layout	doc/TwitterAlikeExample.html	/^<h2><a name="Data layout">Data layout<\/a><\/h2>$/;"	a
Design pattern: Implementing locking with SETNX	doc/SetnxCommand.html	/^<\/pre><h2><a name="Design pattern: Implementing locking with SETNX">Design pattern: Implementing locking with SETNX<\/a><\/h2><blockquote>SETNX can also be seen as a locking primitive. For instance to acquirethe lock of the key <b>foo<\/b>, the client could try the following:<\/blockquote>$/;"	a
ERROR	redis-check-aof.c	9;"	d	file:
ERROR	redis-check-dump.c	60;"	d	file:
EXEC or DISCARD	doc/MultiExecCommand.html	/^<h1><a name="EXEC or DISCARD">EXEC or DISCARD<\/a><\/h1>MULTI, EXEC, DISCARD and WATCH commands are the fundation of Redis Transactions.$/;"	a
EXISTS _key_	doc/ExistsCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="EXISTS _key_">EXISTS _key_<\/a><\/h1>$/;"	a
EXPIRE _key_ _seconds_	doc/ExpireCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="EXPIRE _key_ _seconds_">EXPIRE _key_ _seconds_<\/a><\/h1>$/;"	a
EXPIREAT _key_ _unixtime_ (Redis &gt;	doc/ExpireCommand.html	/^<h1><a name="EXPIREAT _key_ _unixtime_ (Redis &gt;">EXPIREAT _key_ _unixtime_ (Redis &gt;<\/a><\/h1> 1.1)=$/;"	a
Enhanced Lazy Expiration algorithm	doc/ExpireCommand.html	/^<h2><a name="Enhanced Lazy Expiration algorithm">Enhanced Lazy Expiration algorithm<\/a><\/h2><blockquote>Redis does not constantly monitor keys that are going to be expired.Keys are expired simply when some client tries to access a key, andthe key is found to be timed out.<\/blockquote>$/;"	a
Error reply	doc/ReplyTypes.html	/^Status code replies are single line strings having the <b>+<\/b> character as first byte. The string to return to the client is simply verything that follows the first <b>+<\/b> character. For example the <a href="PingCommand.html">PING<\/a> command returns <b>+PONG<\/b>, that is the string &quot;PONG&quot;.<h1><a name="Error reply">Error reply<\/a><\/h1>$/;"	a
Event Library	doc/EventLibray.html	/^<h1><a name="Event Library">Event Library<\/a><\/h1><h2><a name="Why is an Event Library needed at all?">Why is an Event Library needed at all?<\/a><\/h2>Let us figure it out through a series of Q&amp;As.<br\/><br\/>Q: What do you expect a network server to be doing all the time? &lt;br\/&gt;$/;"	a
Event Loop Processing	doc/RedisEventLibrary.html	/^This completes the initialization of Redis event loop.<h2><a name="Event Loop Processing">Event Loop Processing<\/a><\/h2><code name="code" class="python">ae.c:aeMain<\/code> called from <code name="code" class="python">redis.c:main<\/code> does the job of processing the event loop that is initialized in the previous phase.<br\/><br\/><code name="code" class="python">ae.c:aeMain<\/code> calls <code name="code" class="python">ae.c:aeProcessEvents<\/code> in a while loop that processes pending time and file events.<h3><a name="aeProcessEvents">aeProcessEvents<\/a><\/h3><code name="code" class="python">ae.c:aeProcessEvents<\/code> looks for the time event that will be pending in the smallest amount of time by calling <code name="code" class="python">ae.c:aeSearchNearestTimer<\/code> on the event loop. In our case there is only one timer event in the event loop that was created by <code name="code" class="python">ae.c:aeCreateTimeEvent<\/code>. <br\/><br\/>Remember, that timer event created by <code name="code" class="python">aeCreateTimeEvent<\/code> has by now probably elapsed because it had a expiry time of one millisecond. Since, the timer has already expired the seconds and microseconds fields of the <code name="code" class="python">tvp<\/code> timeval structure variable is initialized to zero. <br\/><br\/>The <code name="code" class="python">tvp<\/code> structure variable along with the event loop variable is passed to <code name="code" class="python">ae_epoll.c:aeApiPoll<\/code>.<br\/><br\/><code name="code" class="python">aeApiPoll<\/code> functions does a <a href="http:\/\/man.cx\/epoll_wait" target="_blank">epoll_wait<\/a> on the epoll descriptor and populates the <code name="code" class="python">eventLoop-&gt;fired<\/code> table with the details:$/;"	a
Examples	doc/HincrbyCommand.html	/^<blockquote>The range of values supported by HINCRBY is limited to 64 bit signed integers.<\/blockquote><h2><a name="Examples">Examples<\/a><\/h2>$/;"	a
Examples	doc/ZrangebyscoreCommand.html	/^<h2><a name="Examples">Examples<\/a><\/h2>$/;"	a
Exclusive intervals and infinity	doc/ZrangebyscoreCommand.html	/^<blockquote>The <b>ZCOUNT<\/b> command is similar to <b>ZRANGEBYSCORE<\/b> but instead of returningthe actual elements in the specified interval, it just returns the numberof matching elements.<\/blockquote><h2><a name="Exclusive intervals and infinity">Exclusive intervals and infinity<\/a><\/h2>$/;"	a
FAQ: Can you explain better why Redis &lt; 2.1.3 deletes keys with an EXPIRE on write operations?	doc/ExpireCommand.html	/^<\/pre><h2><a name="FAQ: Can you explain better why Redis &lt; 2.1.3 deletes keys with an EXPIRE on write operations?">FAQ: Can you explain better why Redis &lt; 2.1.3 deletes keys with an EXPIRE on write operations?<\/a><\/h2>$/;"	a
FAQ: How this limitations were solved in Redis versions &gt; 2.1.3?	doc/ExpireCommand.html	/^Running the above example with the 10 seconds pause will lead to 'a' being set to the value of 1, as it no longer exists when INCR is called 10 seconds later.<br\/><br\/>Instead if we drop the 10 seconds pause, the result is that 'a' is set to 101.<br\/><br\/>And in the practice timing changes! For instance the client may wait 10 seconds before INCR, but the sequence written in the Append Only File (and later replayed-back as fast as possible when Redis is restarted) will not have the pause. Even if we add a timestamp in the AOF, when the time difference is smaller than our timer resolution, we have a race condition.<br\/><br\/>The same happens with master-slave replication. Again, consider the example above: the client will use the same sequence of commands without the 10 seconds pause, but the replication link will slow down for a few seconds due to a network problem. Result? The master will contain 'a' set to 101, the slave 'a' set to 1.<br\/><br\/>The only way to avoid this but at the same time have reliable non time dependent timeouts on keys is to destroy volatile keys when a write operation is attempted against it.<br\/><br\/>After all Redis is one of the rare fully persistent databases that will give you EXPIRE. This comes to a cost :)<h2><a name="FAQ: How this limitations were solved in Redis versions &gt; 2.1.3?">FAQ: How this limitations were solved in Redis versions &gt; 2.1.3?<\/a><\/h2>Since Redis 2.1.3 there are no longer restrictions in the use you can do of write commands against volatile keys, still the replication and AOF file are guaranteed to be fully consistent.<br\/><br\/>In order to obtain a correct behavior without sacrificing consistency now when a key expires, a DEL operation is synthesized in both the AOF file and against all the attached slaves. This way the expiration process is centralized in the master instance, and there is no longer a chance of consistency errors.<br\/><br\/>However while the slaves while connected to a master will not expire keys independently, they'll still take the full state of the expires existing in the dataset, so when a slave is elected to a master it will be able to expire the keys independently, fully acting as a master.$/;"	a
FLUSHALL	doc/FlushallCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="FLUSHALL">FLUSHALL<\/a><\/h1>$/;"	a
FLUSHDB	doc/FlushdbCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="FLUSHDB">FLUSHDB<\/a><\/h1>$/;"	a
FRST	lzf_c.c	48;"	d	file:
Fast parsing of multi bulk replies	doc/UDP.html	/^<ul><li> <b>Request ID<\/b> - this field is the request packet ID that the server is acknowledging.<\/li><li> <b>Opcode<\/b> - the operation code, used to identify the role of this packet in the Redis UDP protocol. For the ACK packet the opcode value is 4.<\/li><li> <b>Ack<\/b> - the actual acknowledge value: this is set to 0 if the Server did not processed a request with the specified ID in the latest 10 seconds. Otherwise it is set to 1.<\/li><\/ul>The remaining 16 bits are reserved for future use.<br\/><br\/>Note that the ability to acknowledge an operation takes memory Server side. This is why a Redis Server is able to correctly reply to an Ack request for packets received up to 10 seconds from the reception of the Request itself.<br\/><br\/>After 10 seconds the Server will forget about the processed operation, and will reply to Ack request packets with an Ack reply where the Ack field is set to 0, as if the request was never processed.<br\/><br\/>As the Redis UDP protocol is intended to be used in low latency conditions in very speed networks, 10 seconds should be more than enough in order to understand that the reply timed out, and to ask the server an acknowledge about a given request.<br\/><br\/>Note: Acknowledges work even if multiple clients with different IP addresses or ports are using the same set of Request IDs, as every request is internally remembered associated with the originating client IP address and port.<br\/><br\/>For this reason it is absolutely mandatory that an Ack request packet is sent using the same IP address and port as the original request packet.<h2><a name="Fast parsing of multi bulk replies">Fast parsing of multi bulk replies<\/a><\/h2>Using the UDP protocol, complete replies are received with a single system call.$/;"	a
Features (DRAFT)	doc/Features.html	/^<h1><a name="Features (DRAFT)">Features (DRAFT)<\/a><\/h1>Checking Redis for the first time? Here your will find the most important features, and pointers to a lot more information.<h2><a name="Speed">Speed<\/a><\/h2>Redis is written in ANSI C, and loads the whole dataset in memory, so it is wicked <i><b>fast<\/b>!<\/i> Up to 110,000 <a href="SETs.html">SETs<\/a>\/second, 81,000 GETs\/second can be achieved in an entry level Linux box. Read more about Redis <a href="Speed.html">Speed<\/a>.<br\/><br\/>Also Redis  supports <a href="Pipelining.html">Pipelining<\/a> of commands and <a href="MultiBulkCommands.html">getting and setting m&Atilde;&ordm;ltiple values in a single command<\/a> to speed up communication with the client libraries.<h2><a name="Persistence">Persistence<\/a><\/h2>While all the data lives in memory, changes are <i>asynchronously<\/i> saved on disk using flexible policies based on elapsed time and\/or number of updates since last save. <br\/><br\/>If you can't afford losing some data, starting on version 1.1 (currently in beta but you can download it from the Git repository) Redis supports an append-only file persistence mode. Check more on <a href="Persistence.html">Persistence<\/a>, or read the <a href="AppendOnlyFileHowto.html">AppendOnlyFileHowto<\/a> for more information.<h2><a name="Support for Data Structures">Support for Data Structures<\/a><\/h2>Values in Redis can be <a href="Strings.html">Strings<\/a> as in a conventional key-value store, but also <a href="Lists.html">Lists<\/a>, <a href="Sets.html">Sets<\/a>, and <a href="SortedSets.html">SortedSets<\/a> (to be support in <a href="RoadMap.html">version 1.1<\/a>). This data types allow pushing\/poping elements, or adding\/removing them, also perform server side union, intersection, difference between sets, and so forth depending on the types. Redis supports different kind of sorting abilities for <a href="Sets.html">Sets<\/a> and <a href="Lists.html">Lists<\/a>.<br\/><br\/>You can think in Redis as a <b>Data Structures Server<\/b>, that allows you to model non trivial problems. Read <a href="DataTypes.html">Data Types<\/a> to learn more about the way Redis handle <a href="Strings.html">Strings<\/a>, and the <a href="Commands.html">Commands<\/a> supported by <a href="Lists.html">Lists<\/a>, <a href="Sets.html">Sets<\/a> and <a href="SortedSets.html">SortedSets<\/a><h2><a name="Atomic Operations">Atomic Operations<\/a><\/h2>Redis operations working on the different Data Types are <b>atomic<\/b>, so setting or increasing a key, adding and removing elements from a set, increasing a counter will all be accomplished safely.<h2><a name="Variety of Supported Languages">Variety of Supported Languages<\/a><\/h2>Ruby, Python, Twisted Python, PHP, Erlang, Tcl, Perl, Lua, Java, Scala, Clojure, choose your poison. Check the list of <a href="SupportedLanguages.html">Supported Languages<\/a> for all the details.<br\/><br\/>If your favorite language is not supported yet, you can write your own client library, as the <a href="ProtocolSpecification.html">Protocol<\/a> is pretty simple.<h2><a name="Master\/Slave Replication">Master\/Slave Replication<\/a><\/h2>Redis supports a very simple and fast Master\/Slave replication. Is so simple it takes only one line in the <a href="Configuration.html">configuration file<\/a> to set it up, and 21 seconds for a Slave to complete the initial sync of 10 MM key set in a Amazon EC2 instance.<br\/><br\/>Read more about Master\/Slave <a href="Replication.html">Replication<\/a>. <h2><a name="Sharding">Sharding<\/a><\/h2>Distributing the dataset across multiple Redis instances is easy in Redis, as in any other key-value store. And this depends basically on the <a href="Supported.html">Languages<\/a> client libraries being able to do so. <br\/><br\/>Read more about <a href="Sharding.html">Sharding<\/a> if you want to know more abour distributing data and workload in Redis.<h2><a name="Hot Backups">Hot Backups<\/a><\/h2>TODO<h2><a name="Simple to Install, Setup and Manage">Simple to Install, Setup and Manage<\/a><\/h2>Installing Redis requires little more than downloading it, uncompressing it and running make. Management is near zero, so you can start using Redis in a matter of minutes.<br\/><br\/>Go on and read about Redis <a href="Installation.html">installation<\/a>, its <a href="Setup.html">Setup<\/a> and <a href="Management.html">Management<\/a>.<h2><a name="Portable">Portable<\/a><\/h2>Redis is written in ANSI C and works in most POSIX systems like Linux, BSD, Mac OS X, Solaris, and so on. Redis is reported to compile and work under WIN32 if compiled with Cygwin, but there is no official support for Windows currently.<h2><a name="Liberal Licensing">Liberal Licensing<\/a><\/h2>Redis is free software released under the very liberal BSD license.<h2><a name="What's next?">What's next?<\/a><\/h2>Want to get started with Redis? Try the <a href="QuickStart.html">Quick Start<\/a> you will be up and running in just a matter of minutes.  <br\/><br\/>Check the <a href="CodeSamples.html">Code Samples<\/a> and find how you can use Redis with your favorite programming language.<br\/><br\/><a href="Comparisons.html">Compare<\/a> Redis with other key-value stores, like Tokyo Cabinet or Memcached.$/;"	a
Features Support Matrix	doc/SupportedLanguages.html	/^<h2><a name="Features Support Matrix">Features Support Matrix<\/a><\/h2>        <br\/><br\/>The following matrix should give you a quick overviwe of the state of the different client libraries existing for each supported language.<br\/><br\/>The core command set is the one of Version 1.0, while <a href="Sharding.html">Sharding<\/a> and <a href="Pipelining.html">Pipelining<\/a> are convenient client side features not tied to any Redis server version.<h3><a name="Version 1.1">Version 1.1<\/a><\/h3>Compatible client libraries are expected to implement the command sets specified in <b>Version 1.0<\/b> plus:<br\/><br\/><ul><li> <b>String<\/b>: MSET, MSETNX.<\/li><li> <b>List<\/b>: RPOPLPUSH.<\/li><li> <b>Sorted Set (ZSET)<\/b>: ZADD, ZREM, ZRANGE, ZREVRANGE, ZRANGEBYSCORE, ZCARD, ZSCORE.<\/li><\/ul>$/;"	a
Following users	doc/TwitterAlikeExample.html	/^<\/pre><code name="code" class="python">showPost<\/code> will simply convert and print a Post in HTML while <code name="code" class="python">showUserPosts<\/code> get range of posts passing them to <code name="code" class="python">showPosts<\/code>.<h2><a name="Following users">Following users<\/a><\/h2>If user id 1000 (antirez) wants to follow user id 1001 (pippo), we can do this with just two SADD:<br\/><br\/><pre class="codeblock python python python python python python python python python python python python python python python python python python python python python python python" name="code">$/;"	a
Following, followers and updates	doc/TwitterAlikeExample.html	/^<h2><a name="Following, followers and updates">Following, followers and updates<\/a><\/h2>$/;"	a
Format of pushed messages	doc/PublishSubscribe.html	/^<blockquote>The reply of the SUBSCRIBE and UNSUBSCRIBE operations are sent in the formof messages, so that the client can just read a coherent stream of messageswhere the first element indicates the kind of message.<\/blockquote><h2><a name="Format of pushed messages">Format of pushed messages<\/a><\/h2>$/;"	a
Further reading	doc/QuickStart.html	/^<\/pre><h2><a name="Further reading">Further reading<\/a><\/h2><ul><li> What to play more with Redis? Read <a href="IntroductionToRedisDataTypes.html">Fifteen minutes introduction to Redis data types<\/a>.<\/li><li> Check all the <a href="Features.html">Features<\/a><\/li><li> Read the full list of available commands in the <a href="CommandReference.html">Command Reference<\/a>.<\/li><li> Start using Redis from your <a href="SupportedLanguages.html">favorite language<\/a>.<\/li><li> Take a look at some <a href="ProgrammingExamples.html">Programming Examples<\/a>. <\/li><\/ul>$/;"	a
GET _key_	doc/GetCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="GET _key_">GET _key_<\/a><\/h1>$/;"	a
GETSET _key_ _value_	doc/GetsetCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="GETSET _key_ _value_">GETSET _key_ _value_<\/a><\/h1>$/;"	a
GLUEREPLY_UP_TO	redis.c	2088;"	d	file:
Get the latest Redis source code	doc/UnstableSource.html	/^                    <h1><a name="Get the latest Redis source code">Get the latest Redis source code<\/a><\/h1><h2><a name="Unstable code">Unstable code<\/a><\/h2>$/;"	a
Go-Redis (Go)	doc/SupportedLanguages.html	/^<h3><a name="Go-Redis (Go)">Go-Redis (Go)<\/a><\/h3><ul><li> Client protocol for redis key-value store.<\/li><li> Author: Joubin Houshyar, <a href="http:\/\/twitter.com\/SunOf27" target="_blank">@SunOf27<\/a>.<\/li><li> Repository: <a href="http:\/\/github.com\/alphazero\/Go-Redis" target="_blank">http:\/\/github.com\/alphazero\/Go-Redis<\/a><\/li><\/ul>$/;"	a
HAVE_BACKTRACE	config.h	28;"	d
HAVE_EPOLL	config.h	33;"	d
HAVE_KQUEUE	config.h	37;"	d
HAVE_MALLOC_SIZE	config.h	13;"	d
HDEL _key_ _field_ (Redis &gt;	doc/HdelCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="HashCommandsSidebar.html">HashCommandsSidebar<\/a><h1><a name="HDEL _key_ _field_ (Redis &gt;">HDEL _key_ _field_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
HEXISTS _key_ _field_ (Redis &gt;	doc/HexistsCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="HashCommandsSidebar.html">HashCommandsSidebar<\/a><h1><a name="HEXISTS _key_ _field_ (Redis &gt;">HEXISTS _key_ _field_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
HGET _key_ _field_ (Redis &gt;	doc/HgetCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="HashCommandsSidebar.html">HashCommandsSidebar<\/a><h1><a name="HGET _key_ _field_ (Redis &gt;">HGET _key_ _field_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
HGETALL _key_ (Redis &gt;	doc/HgetallCommand.html	/^<h1><a name="HGETALL _key_ (Redis &gt;">HGETALL _key_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
HGETSET	doc/NonexistentCommands.html	/^This is a list of commands that don't exist in Redis, but can be accomplished in a different way, usually by means of <a href="MultiExecCommand.html">WATCH\/MULTI\/EXEC<\/a>.<br\/><br\/>For better performance, you can pipeline multiple commands.<h1><a name="HGETSET">HGETSET<\/a><\/h1><a href="GetsetCommand.html">GETSET<\/a> for Hashes.<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
HINCRBY _key_ _field_ _value_ (Redis &gt;	doc/HincrbyCommand.html	/^<h1><a name="HINCRBY _key_ _field_ _value_ (Redis &gt;">HINCRBY _key_ _field_ _value_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
HKEYS _key_ (Redis &gt;	doc/HgetallCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="HashCommandsSidebar.html">HashCommandsSidebar<\/a><h1><a name="HKEYS _key_ (Redis &gt;">HKEYS _key_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
HLEN _key_ (Redis &gt;	doc/HlenCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="HashCommandsSidebar.html">HashCommandsSidebar<\/a><h1><a name="HLEN _key_ (Redis &gt;">HLEN _key_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
HLOG	lzfP.h	55;"	d
HMGET _key_ _field1_ ... _fieldN_ (Redis &gt;	doc/HmgetCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="HashCommandsSidebar.html">HashCommandsSidebar<\/a><h1><a name="HMGET _key_ _field1_ ... _fieldN_ (Redis &gt;">HMGET _key_ _field1_ ... _fieldN_ (Redis &gt;<\/a><\/h1> 1.3.10) =$/;"	a
HMSET _key_ _field1_ _value1_ ... _fieldN_ _valueN_ (Redis &gt;	doc/HmsetCommand.html	/^<h1><a name="HMSET _key_ _field1_ _value1_ ... _fieldN_ _valueN_ (Redis &gt;">HMSET _key_ _field1_ _value1_ ... _fieldN_ _valueN_ (Redis &gt;<\/a><\/h1> 1.3.10) =$/;"	a
HOWTOs about selected features	doc/index.html	/^<h1><a name="HOWTOs about selected features">HOWTOs about selected features<\/a><\/h1><ul><li> <a href="ReplicationHowto.html">The Redis Replication HOWTO<\/a> is what you need to read in order to understand how Redis master <code name="code" class="python">&lt;-&gt;<\/code> slave replication works.<\/li><li> <a href="AppendOnlyFileHowto.html">The Append Only File HOWTO<\/a> explains how the alternative Redis durability mode works. AOF is an alternative to snapshotting on disk from time to time (the default).<\/li><li> <a href="VirtualMemoryUserGuide.html">Virtual Memory User Guide<\/a>. A simple to understand guide about using and configuring the Redis Virtual Memory.<\/li><\/ul>$/;"	a
HSET _key_ _field_ _value_ (Redis &gt;	doc/HsetCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="HashCommandsSidebar.html">HashCommandsSidebar<\/a><h1><a name="HSET _key_ _field_ _value_ (Redis &gt;">HSET _key_ _field_ _value_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
HSETNX _key_ _field_ _value_ (Redis &gt;	doc/HsetnxCommand.html	/^<h1><a name="HSETNX _key_ _field_ _value_ (Redis &gt;">HSETNX _key_ _field_ _value_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
HSIZE	lzf_c.c	39;"	d	file:
HVALS _key_ (Redis &gt;	doc/HgetallCommand.html	/^<h1><a name="HVALS _key_ (Redis &gt;">HVALS _key_ (Redis &gt;<\/a><\/h1> 1.3.10)=$/;"	a
Hacking	doc/index.html	/^<h1><a name="Hacking">Hacking<\/a><\/h1>$/;"	a
Hacking Strings	doc/HackingStrings.html	/^<h1><a name="Hacking Strings">Hacking Strings<\/a><\/h1>The implementation of Redis strings is contained in <b><\/b>sds.c<b><\/b> ( sds stands for Simple Dynamic Strings ).<br\/><br\/>The C structure <i>sdshdr<\/i> declared in <b>sds.h<\/b> represents a Redis string:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Handling deadlocks	doc/SetnxCommand.html	/^<h3><a name="Handling deadlocks">Handling deadlocks<\/a><\/h3><blockquote>In the above locking algorithm there is a problem: what happens if a clientfails, crashes, or is otherwise not able to release the lock?It's possible to detect this condition because the lock key contains aUNIX timestamp. If such a timestamp is &lt;= the current Unix time the lockis no longer valid.<\/blockquote>$/;"	a
Hashing the key	doc/TwitterAlikeExample.html	/^<h3><a name="Hashing the key">Hashing the key<\/a><\/h3>$/;"	a
How Fast is Redis?	doc/Benchmarks.html	/^                    <h1><a name="How Fast is Redis?">How Fast is Redis?<\/a><\/h1>Redis includes the <code name="code" class="python">redis-benchmark<\/code> utility that simulates <a href="SETs.html">SETs<\/a>\/GETs done by N clients at the same time sending M total queries (it is similar to the Apache's <code name="code" class="python">ab<\/code> utility). Below you'll find the full output of the benchmark executed against a Linux box.<br\/><br\/><ul><li> The test was done with 50 simultaneous clients performing 100000 requests.<\/li><li> The value SET and GET is a 256 bytes string.<\/li><li> The Linux box is running <b>Linux 2.6<\/b>, it's <b>Xeon X3320 2.5Ghz<\/b>.<\/li><li> Text executed using the loopback interface (127.0.0.1).<\/li><\/ul>$/;"	a
How Redis replication works	doc/ReplicationHowto.html	/^<h2><a name="How Redis replication works">How Redis replication works<\/a><\/h2>In order to start the replication, or after the connection closes in order resynchronize with the master, the slave connects to the master and issues the SYNC command.<br\/><br\/>The master starts a background saving, and at the same time starts to collect all the new commands received that had the effect to modify the dataset. When the background saving completed the master starts the transfer of the database file to the slave, that saves it on disk, and then load it in memory. At this point the master starts to send all the accumulated commands, and all the new commands received from clients that had the effect of a dataset modification, to the slave, as a stream of commands, in the same format of the Redis protocol itself.<br\/><br\/>You can try it yourself via telnet. Connect to the Redis port while the server is doing some work and issue the SYNC command. You'll see a bulk transfer and then every command received by the master will be re-issued in the telnet session.<br\/><br\/>Slaves are able to automatically reconnect when the master <code name="code" class="python">&lt;-&gt;<\/code> slave link goes down for some reason. If the master receives multiple concurrent slave synchronization requests it performs a single background saving in order to serve all them.<h2><a name="Configuration">Configuration<\/a><\/h2>To configure replication is trivial: just add the following line to the slave configuration file:$/;"	a
How blocking VM works	doc/VirtualMemorySpecification.html	/^<h2><a name="How blocking VM works">How blocking VM works<\/a><\/h2>$/;"	a
How does a swapped value looks like internally	doc/VirtualMemorySpecification.html	/^As you can see from the above output, the Redis top level hash table maps Redis Objects (keys) to other Redis Objects (values). The Virtual Memory is only able to swap <i>values<\/i> on disk, the objects associated to <i>keys<\/i> are always taken in memory: this trade off guarantees very good lookup performances, as one of the main design goals of the Redis VM is to have performances similar to Redis with VM disabled when the part of the dataset frequently used fits in RAM.<h2><a name="How does a swapped value looks like internally">How does a swapped value looks like internally<\/a><\/h2>$/;"	a
How durable is the append only file?	doc/AppendOnlyFileHowto.html	/^<h2><a name="How durable is the append only file?">How durable is the append only file?<\/a><\/h2>Check redis.conf, you can configure how many times Redis will fsync() data on disk. There are three options:<br\/><br\/><ul><li> Fsync() every time a new command is appended to the append log file. Very very slow, very safe.<\/li><li> Fsync() one time every second. Fast enough, and you can lose 1 second of data if there is a disaster.<\/li><li> Never fsync(), just put your data in the hands of the Operating System. The faster and unsafer method.<\/li><\/ul>$/;"	a
How the expire is removed from a key	doc/ExpireCommand.html	/^<h2><a name="How the expire is removed from a key">How the expire is removed from a key<\/a><\/h2><blockquote>When the key is set to a new value using the SET command, or when a keyis destroied via DEL, the timeout is removed from the key.<\/blockquote>$/;"	a
I/O Threads	doc/VirtualMemorySpecification.html	/^<ul><li> 1: One way is obvious, and in my opionion, not a good idea at all, that is, turning Redis itself into a theaded server: if every request is served by a different thread automatically other clients don't need to wait for blocked ones. Redis is fast, exports atomic operations, has no locks, and is just 10k lines of code, <b>because<\/b> it is single threaded, so this was not an option for me.<\/li><li> 2: Using non-blocking I\/O against the swap file. After all you can think Redis already event-loop based, why don't just handle disk I\/O in a non-blocking fashion? I also discarded this possiblity because of two main reasons. One is that non blocking file operations, unlike sockets, are an incompatibility nightmare. It's not just like calling select, you need to use OS-specific things. The other problem is that the I\/O is just one part of the time consumed to handle VM, another big part is the CPU used in order to encode\/decode data to\/from the swap file. This is I picked option three, that is...<\/li><li> 3: Using I\/O threads, that is, a pool of threads handling the swap I\/O operations. This is what the Redis VM is using, so let's detail how this works.<\/li><\/ul><h2><a name="I\/O Threads">I\/O Threads<\/a><\/h2>$/;"	a
IDX	lzf_c.c	51;"	d	file:
IDX	lzf_c.c	53;"	d	file:
IDX	lzf_c.c	55;"	d	file:
INCR _key_	doc/IncrCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="INCR _key_">INCR _key_<\/a><\/h1>$/;"	a
INCRBY _key_ _integer_	doc/IncrCommand.html	/^<h1><a name="INCRBY _key_ _integer_">INCRBY _key_ _integer_<\/a><\/h1>$/;"	a
INFO	doc/InfoCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ControlCommandsSidebar.html">ControlCommandsSidebar<\/a><h1><a name="INFO">INFO<\/a><\/h1><blockquote>The info command returns different information and statistics about the server in an format that's simple to parse by computers and easy to red by huamns.<\/blockquote>$/;"	a
INIT_HTAB	lzfP.h	91;"	d
INSTALL	Makefile	/^INSTALL= cp -p$/;"	m
INSTALL_BIN	Makefile	/^INSTALL_BIN= $(INSTALL_TOP)\/bin$/;"	m
INSTALL_TOP	Makefile	/^INSTALL_TOP= \/usr\/local$/;"	m
IOThreadEntryPoint	redis.c	/^static void *IOThreadEntryPoint(void *arg) {$/;"	f	file:
Implementation details	doc/Lists.html	/^The resulting list stored at <i>mylist<\/i> will contain the elements &quot;b&quot;,&quot;a&quot;,&quot;c&quot;.<br\/><br\/>The max length of a list is 232-1 elements (4294967295, more than 4 billion of elements per list).<h1><a name="Implementation details">Implementation details<\/a><\/h1>Redis Lists are implemented as doubly liked lists. A few commands benefit from the fact the lists are doubly linked in order to reach the needed element starting from the nearest extreme (head or tail). <a href="LrangeCommand.html">LRANGE<\/a> and <a href="LindexCommand.html">LINDEX<\/a> are examples of such commands.<br\/><br\/>The use of linked lists also guarantees that regardless of the length of the list pushing and popping are O(1) operations.<br\/><br\/>Redis Lists cache length information so <a href="LlenCommand.html">LLEN<\/a> is O(1) as well.$/;"	a
Integer reply	doc/ProtocolSpecification.html	/^PING, SET, SELECT, SAVE, BGSAVE, SHUTDOWN, RENAME, LPUSH, RPUSH, LSET, LTRIM<h2><a name="Integer reply">Integer reply<\/a><\/h2>This type of reply is just a CRLF terminated string representing an integer, prefixed by a &quot;:&quot; byte. For example &quot;:0\\r\\n&quot;, or &quot;:1000\\r\\n&quot; are integer replies.<br\/><br\/>With commands like INCR or LASTSAVE using the integer reply to actually return a value there is no special meaning for the returned integer. It is just an incremental number for INCR, a UNIX time for LASTSAVE and so on.<br\/><br\/>Some commands like EXISTS will return 1 for true and 0 for false.<br\/><br\/>Other commands like SADD, SREM and SETNX will return 1 if the operation was actually done, 0 otherwise.<br\/><br\/>The following commands will reply with an integer reply: SETNX, DEL, EXISTS, INCR, INCRBY, DECR, DECRBY, DBSIZE, LASTSAVE, RENAMENX, MOVE, LLEN, SADD, SREM, SISMEMBER, SCARD<h2><a name="Multi bulk commands">Multi bulk commands<\/a><\/h2>As you can see with the protocol described so far there is no way to$/;"	a
Integer reply	doc/ReplyTypes.html	/^This is like a status code reply but the first character is <b>-<\/b> instead of <b>+<\/b>. The client library should raise an error for error replies and stop the execution of the program if the exception is not trapped, showing the error message (everything following the first <b>-<\/b> character). An example of error is &quot;-Error no such key&quot; or &quot;-foobar&quot;. Note that error replies will not collide with negative integer replies since integer replies are prefixed with the <b>:<\/b> character.<h1><a name="Integer reply">Integer reply<\/a><\/h1>$/;"	a
Introduction (IDEA MORE THAN A DRAFT)	doc/FromSqlToDataStructures.html	/^<h1><a name="Introduction (IDEA MORE THAN A DRAFT)">Introduction (IDEA MORE THAN A DRAFT)<\/a><\/h1><b>&Acirc;&iquest;Coming from SQLand?<\/b> <i>&Acirc;&iquest;Who doesn't?<\/i> Redis is simple, <i>primitive<\/i> when comapred to the world you are used to in the world of Relational Database Managers (RDBMS) and Structure Query Language (SQL), here you will find insight to build bridges between both worlds to model real life problems.<h2><a name="Data Structures">Data Structures<\/a><\/h2>When I was young, happy and single ;) I studied <b>Data Structures<\/b> at the university, actually I learnt Data Structures and Algorithms <i>before<\/i> learning anything about Databases, and particularly RDBMS and SQL. This is natural because you need to know about Data Structures and Algorithms to understand a Database.<br\/><br\/>Redis can be seen as a <b>Data Structures Server<\/b>, a very simple interface to a extremly fast and efficient <h2><a name="Dude where is my SELECT statement?">Dude where is my SELECT statement?<\/a><\/h2><h2><a name="LISTs">LISTs<\/a><\/h2>In SQL there is no such thing as a &quot;natural&quot; order, a SELECT statement without a ORDER BY clause will return data in a undefined order. In Redis <a href="LISTs.html">LISTs<\/a> address the problem of natural ordering, ...<h2><a name="SETs">SETs<\/a><\/h2>So you have a bunch of unordered data, <h2><a name="SORT to the rescue">SORT to the rescue<\/a><\/h2>But sometimes we <i>need<\/i> to actually sort a LIST in a order different from its natural or take a SET and have it ordered, there is where the <i>fast<\/i> SORT commands comes handy... <h3><a name="SORT BY">SORT BY<\/a><\/h3>Just SORTing keys would be kind of boring, sometimes useless right? Well, you can SORT...<h2><a name="HASHEs">HASHEs<\/a><\/h2>Umm, sorry you will have to wait for a <a href="RoadMap.html">upcoming version of Redis<\/a> to have Hashes, but here are Idioms you should house to manage Dictionary like data...$/;"	a
Is there something I can do to lower the Redis memory usage?	doc/FAQ.html	/^have 10 times the I\/O between memory and disk than otherwise needed.<h1><a name="Is there something I can do to lower the Redis memory usage?">Is there something I can do to lower the Redis memory usage?<\/a><\/h1>Yes, try to compile it with 32 bit target if you are using a 64 bit box.<br\/><br\/>If you are using Redis &gt;= 1.3, try using the Hash data type, it can save a lot of memory.<br\/><br\/>If you are using hashes or any other type with values bigger than 128 bytes try also this to lower the RSS usage (Resident Set Size): EXPORT MMAP_THRESHOLD=4096<h1><a name="I have an empty Redis server but INFO and logs are reporting megabytes of memory in use!">I have an empty Redis server but INFO and logs are reporting megabytes of memory in use!<\/a><\/h1>This may happen and it's prefectly ok. Redis objects are small C structures allocated and freed a lot of times. This costs a lot of CPU so instead of being freed, released objects are taken into a free list and reused when needed. This memory is taken exactly by this free objects ready to be reused.<h1><a name="What happens if Redis runs out of memory?">What happens if Redis runs out of memory?<\/a><\/h1>With modern operating systems malloc() returning NULL is not common, usually the server will start swapping and Redis performances will be disastrous so you'll know it's time to use more Redis servers or get more RAM.<br\/><br\/>The INFO command (work in progress in this days) will report the amount of memory Redis is using so you can write scripts that monitor your Redis servers checking for critical conditions.<br\/><br\/>You can also use the &quot;maxmemory&quot; option in the config file to put a limit to the memory Redis can use. If this limit is reached Redis will start to reply with an error to write commands (but will continue to accept read-only commands).<h1><a name="Does Redis use more memory running in 64 bit boxes? Can I use 32 bit Redis in 64 bit systems?">Does Redis use more memory running in 64 bit boxes? Can I use 32 bit Redis in 64 bit systems?<\/a><\/h1>Redis uses a lot more memory when compiled for 64 bit target, especially if the dataset is composed of many small keys and values. Such a database will, for instance, consume 50 MB of RAM when compiled for the 32 bit target, and 80 MB for 64 bit! That's a big difference.<br\/><br\/>You can run 32 bit Redis binaries in a 64 bit Linux and Mac OS X system without problems. For OS X just use <b>make 32bit<\/b>. For Linux instead, make sure you have <b>libc6-dev-i386<\/b> installed, then use <b>make 32bit<\/b> if you are using the latest Git version. Instead for Redis &lt;= 1.2.2 you have to edit the Makefile and replace &quot;-arch i386&quot; with &quot;-m32&quot;.<br\/><br\/>If your application is already able to perform application-level sharding, it is very advisable to run N instances of Redis 32bit against a big 64 bit Redis box (with more than 4GB of RAM) instead than a single 64 bit instance, as this is much more memory efficient. <h1><a name="How much time it takes to load a big database at server startup?">How much time it takes to load a big database at server startup?<\/a><\/h1>Just an example on normal hardware: It takes about 45 seconds to restore a 2 GB database on a fairly standard system, no RAID. This can give you some kind of feeling about the order of magnitude of the time needed to load data when you restart the server.<h1><a name="Background saving is failing with a fork() error under Linux even if I've a lot of free RAM!">Background saving is failing with a fork() error under Linux even if I've a lot of free RAM!<\/a><\/h1>Short answer: <code name="code" class="python">echo 1 &gt; \/proc\/sys\/vm\/overcommit_memory<\/code> :)<br\/><br\/>And now the long one:<br\/><br\/>Redis background saving schema relies on the copy-on-write semantic of fork in modern operating systems: Redis forks (creates a child process) that is an exact copy of the parent. The child process dumps the DB on disk and finally exits. In theory the child should use as much memory as the parent being a copy, but actually thanks to the copy-on-write semantic implemented by most modern operating systems the parent and child process will <i>share<\/i> the common memory pages. A page will be duplicated only when it changes in the child or in the parent. Since in theory all the pages may change while the child process is saving, Linux can't tell in advance how much memory the child will take, so if the <code name="code" class="python">overcommit_memory<\/code> setting is set to zero fork will fail unless there is as much free RAM as required to really duplicate all the parent memory pages, with the result that if you have a Redis dataset of 3 GB and just 2 GB of free memory it will fail.<br\/><br\/>Setting <code name="code" class="python">overcommit_memory<\/code> to 1 says Linux to relax and perform the fork in a more optimistic allocation fashion, and this is indeed what you want for Redis.<br\/><br\/>A good source to understand how Linux Virtual Memory work and other alternatives for <code name="code" class="python">overcommit_memory<\/code> and <code name="code" class="python">overcommit_ratio<\/code> is this classic from Red Hat Magaize, &quot;Understanding Virtual Memory&quot;: <a href="http:\/\/www.redhat.com\/magazine\/001nov04\/features\/vm\/" target="_blank">http:\/\/www.redhat.com\/magazine\/001nov04\/features\/vm\/<\/a> <h1><a name="Are Redis on disk snapshots atomic?">Are Redis on disk snapshots atomic?<\/a><\/h1>Yes, redis background saving process is always fork(2)ed when the server is outside of the execution of a command, so every command reported to be atomic in RAM is also atomic from the point of view of the disk snapshot.<h1><a name="Redis is single threaded, how can I exploit multiple CPU \/ cores?">Redis is single threaded, how can I exploit multiple CPU \/ cores?<\/a><\/h1>Simply start multiple instances of Redis in different ports in the same box and threat them as different servers! Given that Redis is a distributed database anyway in order to scale you need to think in terms of multiple computational units. At some point a single box may not be enough anyway.<br\/><br\/>In general key-value databases are very scalable because of the property that different keys can stay on different servers independently.<br\/><br\/>In Redis there are client libraries such Redis-rb (the Ruby client) that are able to handle multiple servers automatically using <i>consistent hashing<\/i>. We are going to implement consistent hashing in all the other major client libraries. If you use a different language you can implement it yourself otherwise just hash the key before to SET \/ GET it from a given server. For example imagine to have N Redis servers, server-0, server-1, ..., server-N. You want to store the key &quot;foo&quot;, what's the right server where to put &quot;foo&quot; in order to distribute keys evenly among different servers? Just perform the <i>crc<\/i> = CRC32(&quot;foo&quot;), then <i>servernum<\/i> = <i>crc<\/i> % N (the rest of the division for N). This will give a number between 0 and N-1 for every key. Connect to this server and store the key. The same for gets.<br\/><br\/>This is a basic way of performing key partitioning, consistent hashing is much better and this is why after Redis 1.0 will be released we'll try to implement this in every widely used client library starting from Python and PHP (Ruby already implements this support).<h1><a name="I'm using some form of key hashing for partitioning, but what about SORT BY?">I'm using some form of key hashing for partitioning, but what about SORT BY?<\/a><\/h1>With <a href="SortCommand.html">SORT<\/a> BY you need that all the <i>weight keys<\/i> are in the same Redis instance of the list\/set you are trying to sort. In order to make this possible we developed a concept called <i>key tags<\/i>. A key tag is a special pattern inside a key that, if preset, is the only part of the key hashed in order to select the server for this key. For example in order to hash the key &quot;foo&quot; I simply perform the CRC32 checksum of the whole string, but if this key has a pattern in the form of the characters {...} I only hash this substring. So for example for the key &quot;foo{bared}&quot; the key hashing code will simply perform the CRC32 of &quot;bared&quot;. This way using key tags you can ensure that related keys will be stored on the same Redis instance just using the same key tag for all this keys. Redis-rb already implements key tags.<h1><a name="What is the maximum number of keys a single Redis instance can hold? and what the max number of elements in a List, Set, Ordered Set?">What is the maximum number of keys a single Redis instance can hold? and what the max number of elements in a List, Set, Ordered Set?<\/a><\/h1>In theory Redis can handle up to 2<sup>32 keys, and was tested in practice to handle at least 150 million of keys per instance. We are working in order to experiment with larger values.<br\/><br\/>Every list, set, and ordered set, can hold 2<\/sup>32 elements.<br\/><br\/>Actually Redis internals are ready to allow up to 2<sup>64 elements but the current disk dump format don't support this, and there is a lot time to fix this issues in the future as currently even with 128 GB of RAM it's impossible to reach 2<\/sup>32 elements.<h1><a name="What Redis means actually?">What Redis means actually?<\/a><\/h1>Redis means two things:$/;"	a
Isn't this key-value thing just hype?	doc/FAQ.html	/^<h1><a name="Isn't this key-value thing just hype?">Isn't this key-value thing just hype?<\/a><\/h1>I imagine key-value DBs, in the short term future, to be used like you use memory in a program, with lists, hashes, and so on. With Redis it's like this, but this special kind of memory containing your data structures is shared, atomic, persistent.<br\/><br\/>When we write code it is obvious, when we take data in memory, to use the most sensible data structure for the work, right? Incredibly when data is put inside a relational DB this is no longer true, and we create an absurd data model even if our need is to put data and get this data back in the same order we put it inside (an ORDER BY is required when the data should be already sorted. Strange, dont' you think?).<br\/><br\/>Key-value DBs bring this back at home, to create sensible data models and use the right data structures for the problem we are trying to solve.<h1><a name="Can I backup a Redis DB while the server is working?">Can I backup a Redis DB while the server is working?<\/a><\/h1>Yes you can. When Redis saves the DB it actually creates a temp file, then rename(2) that temp file name to the destination file name. So even while the server is working it is safe to save the database file just with the <i>cp<\/i> unix command. Note that you can use master-slave replication in order to have redundancy of data, but if all you need is backups, cp or scp will do the work pretty well.<h1><a name="What's the Redis memory footprint?">What's the Redis memory footprint?<\/a><\/h1>Worst case scenario: 1 Million keys with the key being the natural numbers from 0 to 999999 and the string &quot;Hello World&quot; as value use 100MB on my Intel macbook (32bit). Note that the same data stored linearly in an unique string takes something like 16MB, this is the norm because with small keys and values there is a lot of overhead. Memcached will perform similarly.<br\/><br\/>With large keys\/values the ratio is much better of course.<br\/><br\/>64 bit systems will use much more memory than 32 bit systems to store the same keys, especially if the keys and values are small, this is because pointers takes 8 bytes in 64 bit systems. But of course the advantage is that you can have a lot of memory in 64 bit systems, so to run large Redis servers a 64 bit system is more or less required.<h1><a name="I like Redis high level operations and features, but I don't like it takes everything in memory and I can't have a dataset larger the memory. Plans to change this?">I like Redis high level operations and features, but I don't like it takes everything in memory and I can't have a dataset larger the memory. Plans to change this?<\/a><\/h1>Short answer: If you are using a Redis client that supports consistent hashing you can distribute the dataset across different nodes. For instance the Ruby clients supports this feature. There are plans to develop redis-cluster that basically is a dummy Redis server that is only used in order to distribute the requests among N different nodes using consistent hashing.<h1><a name="Why Redis takes the whole dataset in RAM?">Why Redis takes the whole dataset in RAM?<\/a><\/h1>Redis takes the whole dataset in memory and writes asynchronously on disk in order to be very fast, you have the best of both worlds: hyper-speed and persistence of data, but the price to pay is exactly this, that the dataset must fit on your computers RAM.<br\/><br\/>If the data is larger then memory, and this data is stored on disk, what happens is that the bottleneck of the disk I\/O speed will start to ruin the performances. Maybe not in benchmarks, but once you have real load from multiple clients with distributed key accesses the data must come from disk, and the disk is damn slow. Not only, but Redis supports higher level data structures than the plain values. To implement this things on disk is even slower.<br\/><br\/>Redis will always continue to hold the whole dataset in memory because this days scalability requires to use RAM as storage media, and RAM is getting cheaper and cheaper. Today it is common for an entry level server to have 16 GB of RAM! And in the 64-bit era there are no longer limits to the amount of RAM you can have in theory.<br\/><br\/>Amazon EC2 now provides instances with 32 or 64 GB of RAM.<h1><a name="If my dataset is too big for RAM and I don't want to use consistent hashing or other ways to distribute the dataset across different nodes, what I can do to use Redis anyway?">If my dataset is too big for RAM and I don't want to use consistent hashing or other ways to distribute the dataset across different nodes, what I can do to use Redis anyway?<\/a><\/h1>You may try to load a dataset larger than your memory in Redis and see what happens, basically if you are using a modern Operating System, and you have a lot of data in the DB that is rarely accessed, the OS's virtual memory implementation will try to swap rarely used pages of memory on the disk, to only recall this pages when they are needed. If you have many large values rarely used this will work. If your DB is big because you have tons of little values accessed at random without a specific pattern this will not work (at low level a page is usually 4096 bytes, and you can have different keys\/values stored at a single page. The OS can't swap this page on disk if there are even few keys used frequently).<br\/><br\/>Another possible solution is to use both MySQL and Redis at the same time, basically take the state on Redis, and all the things that get accessed very frequently: user auth tokens, Redis Lists with chronologically ordered IDs of the last N-comments, N-posts, and so on. Then use MySQL as a simple storage engine for larger data, that is just create a table with an auto-incrementing ID as primary key and a large BLOB field as data field. Access MySQL data only by primary key (the ID). The application will run the high traffic queries against Redis but when there is to take the big data will ask MySQL for specific resources IDs.<br\/><br\/>Update: it could be interesting to test how Redis performs with datasets larger than memory if the OS swap partition is in one of this very fast Intel SSD disks.<h1><a name="Do you plan to implement Virtual Memory in Redis? Why don't just let the Operating System handle it for you?">Do you plan to implement Virtual Memory in Redis? Why don't just let the Operating System handle it for you?<\/a><\/h1>Yes, in order to support datasets bigger than RAM there is the plan to $/;"	a
JRedis	doc/SupportedLanguages.html	/^<h4><a name="JRedis">JRedis<\/a><\/h4><ul><li> Java Client and Connectors for Redis JCA compliant. Currently offers a complete functioning Synchronous connector, Asynchronous connection and pipelining support under heavy development.<\/li><li> Author: Joubin Houshyar, <a href="http:\/\/twitter.com\/SunOf27" target="_blank">@SunOf27<\/a>.<\/li><li> Home: <a href="http:\/\/code.google.com\/p\/jredis\/" target="_blank">http:\/\/code.google.com\/p\/jredis\/<\/a><\/li><li> Repository: <a href="http:\/\/github.com\/alphazero\/jredis" target="_blank">http:\/\/github.com\/alphazero\/jredis<\/a><\/li><\/ul>$/;"	a
Java	doc/ProgrammingExamples.html	/^Nothing speaks better than code examples, here you are:<h2><a name="Java">Java<\/a><\/h2><h3><a name="Twayis">Twayis<\/a><\/h3> <br\/><br\/>A Java clone of <b>Retwis<\/b> showcase integration between the <a href="http:\/\/www.playframework.org\/" target="_blank">Play! framework<\/a> and Redis <a href="http:\/\/code.google.com\/p\/twayis\/" target="_blank">Google Code Project Page<\/a><h2><a name="PHP">PHP<\/a><\/h2><h3><a name="Retwis">Retwis<\/a><\/h3>A PHP Twitter clone, the original example of Redis capabilities. With a <a href="http:\/\/retwis.antirez.com\/" target="_blank">live demo<\/a>, and an <a href="http:\/\/code.google.com\/p\/redis\/wiki\/TwitterAlikeExample" target="_blank">article explaining it design<\/a>. You can find the code in the Downloads tab.<h2><a name="Ruby">Ruby<\/a><\/h2><h3><a name="twatcher-lite">twatcher-lite<\/a><\/h3>A simplied version of the application running <a href="http:\/\/twatcher.com\/" target="_blank">http:\/\/twatcher.com\/<\/a> from Mirko Froehlich (<a href="http:\/\/twitter.com\/digitalhobbit" target="_blank">@digitalhobbit<\/a>) with a full blog post explaining its development at <a href="http:\/\/www.digitalhobbit.com\/2009\/11\/08\/building-a-twitter-filter-with-sinatra-redis-and-tweetstream\/" target="_blank"> Building a Twitter Filter With Sinatra, Redis, and TweetStream<\/a><h3><a name="Resque">Resque<\/a><\/h3>The &quot;simple&quot; Redis-based queue behind Github background jobs, that replaced SQS, Starling, ActiveMessaging, BackgroundJob, DelayedJob, and Beanstalkd. Developed by Chris Wanstrath (<a href="http:\/\/twitter.com\/defunkt" target="_blank">@defunkt<\/a>) the code is at <a href="http:\/\/github.com\/defunkt\/resque" target="_blank">http:\/\/github.com\/defunkt\/resque<\/a>, be sure to read <a href="http:\/\/github.com\/blog\/542-introducing-resque" target="_blank">the introduction<\/a><h3><a name="Retwis-rb">Retwis-rb<\/a><\/h3>A port of <b>Retwis<\/b> to Ruby and <a href="http:\/\/www.sinatrarb.com\/" target="_blank">Sinatra<\/a> written by Daniel Lucraft (<a href="http:\/\/twitter.com\/DanLucraft" target="_blank">@DanLucraft<\/a>) Full source code is available at <a href="http:\/\/github.com\/danlucraft\/retwis-rb" target="_blank">http:\/\/github.com\/danlucraft\/retwis-rb<\/a><h3><a name="scanty-redis">scanty-redis<\/a><\/h3>Scanty is <i>minimal<\/i> blogging software developed by Adam Wiggins (<a href="http:\/\/twitter.com\/hirodusk" target="_blank">@hirodusk<\/a>) It is not a blogging engine, but it&acirc;s small and easy to modify, so it could be the starting point for your blog. <a href="http:\/\/github.com\/adamwiggins\/scanty-redis" target="_blank">This fork<\/a> is modified to use Redis, a full featured key-value database, instead of SQL. <h3><a name="Note Taking">Note Taking<\/a><\/h3>A <i>very simple<\/i> note taking example of Ruby and Redis application using <a href="http:\/\/www.sinatrarb.com\/" target="_blank">Sinatra<\/a>. Developed by Pieter Noordhuis <a href="http:\/\/twitter.com\/pnoordhuis" target="_blank">@pnoordhuis<\/a>, you can check the code at <a href="http:\/\/gist.github.com\/86714" target="_blank">http:\/\/gist.github.com\/86714<\/a>$/;"	a
Java	doc/SupportedLanguages.html	/^<h3><a name="Java">Java<\/a><\/h3><h4><a name="JDBC-Redis">JDBC-Redis<\/a><\/h4><ul><li> JDBC-Redis is Java driver using the JDBC interface for Redis Database. This project doesn't aim for a complete implementation of the JDBC specification since Redis isn't a relational database, but should provide a familiar interface to Java developers interact with Redis.<\/li><li> Repository: <a href="http:\/\/code.google.com\/p\/jdbc-redis\/" target="_blank">http:\/\/code.google.com\/p\/jdbc-redis\/<\/a><\/li><\/ul>$/;"	a
Jedis	doc/SupportedLanguages.html	/^<h4><a name="Jedis">Jedis<\/a><\/h4><ul><li> Jedis is a small and sane Redis client for Java. It aims to be easier to use by providing a more natural API. It currently supports the binary-safe protocol and pipelining. Sharding and connection pooling is on the way.<\/li><li> Author: Jonathan Leibiusky, <a href="http:\/\/twitter.com\/xetorthio" target="_blank">@xetorthio<\/a>.<\/li><li> Repository: <a href="http:\/\/github.com\/xetorthio\/jedis" target="_blank">http:\/\/github.com\/xetorthio\/jedis<\/a><\/li><\/ul>$/;"	a
KEYS _pattern_	doc/KeysCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="KEYS _pattern_">KEYS _pattern_<\/a><\/h1>$/;"	a
LASTSAVE	doc/LastsaveCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ControlCommandsSidebar.html">ControlCommandsSidebar<\/a><h1><a name="LASTSAVE">LASTSAVE<\/a><\/h1>$/;"	a
LINDEX _key_ _index_	doc/LindexCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="LINDEX _key_ _index_">LINDEX _key_ _index_<\/a><\/h1>$/;"	a
LINENOISE_DEFAULT_HISTORY_MAX_LEN	linenoise.c	85;"	d	file:
LINENOISE_MAX_LINE	linenoise.c	86;"	d	file:
LINE_BUFLEN	redis-cli.c	413;"	d	file:
LITTLE_ENDIAN	sha1.c	39;"	d	file:
LLEN _key_	doc/LlenCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="LLEN _key_">LLEN _key_<\/a><\/h1>$/;"	a
LPOP _key_	doc/LpopCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="LPOP _key_">LPOP _key_<\/a><\/h1>$/;"	a
LPUSH _key_ _string_	doc/RpushCommand.html	/^<h3><a name="LPUSH _key_ _string_">LPUSH _key_ _string_<\/a><\/h3>$/;"	a
LRANGE _key_ _start_ _end_	doc/LrangeCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="LRANGE _key_ _start_ _end_">LRANGE _key_ _start_ _end_<\/a><\/h1>$/;"	a
LREM _key_ _count_ _value_	doc/LremCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="LREM _key_ _count_ _value_">LREM _key_ _count_ _value_<\/a><\/h1>$/;"	a
LSET _key_ _index_ _value_	doc/LsetCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="LSET _key_ _index_ _value_">LSET _key_ _index_ _value_<\/a><\/h1>$/;"	a
LTRIM _key_ _start_ _end_	doc/LtrimCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="LTRIM _key_ _start_ _end_">LTRIM _key_ _start_ _end_<\/a><\/h1>$/;"	a
LZFP_h	lzfP.h	38;"	d
LZF_H	lzf.h	38;"	d
LZF_STATE	lzfP.h	/^typedef const u8 *LZF_STATE[1 << (HLOG)];$/;"	t
LZF_STATE_ARG	lzfP.h	109;"	d
LZF_VERSION	lzf.h	49;"	d
Latency percentiles	doc/Benchmarks.html	/^Results: <b>about 110000 <a href="SETs.html">SETs<\/a> per second, about 81000 GETs per second.<\/b><h1><a name="Latency percentiles">Latency percentiles<\/a><\/h1><pre class="codeblock python" name="code">$/;"	a
License	doc/README.html	/^for a language missing a decent client implementation.<h1><a name="License">License<\/a><\/h1>Redis is released under the BSD license. See the COPYING file for more information.<h1><a name="Credits">Credits<\/a><\/h1>Redis is written and maintained by Salvatore Sanfilippo, Aka 'antirez'.$/;"	a
Loading objects back in memory	doc/VirtualMemorySpecification.html	/^<h2><a name="Loading objects back in memory">Loading objects back in memory<\/a><\/h2>$/;"	a
Log rewriting	doc/AppendOnlyFileHowto.html	/^<h2><a name="Log rewriting">Log rewriting<\/a><\/h2>As you can guess... the append log file gets bigger and bigger, every time there is a new operation changing the dataset. Even if you set always the same key &quot;mykey&quot; to the values of &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, ... up to 10000000000 in the end you'll have just a single key in the dataset, just a few bytes! but how big will be the append log file? Very very big.<br\/><br\/>So Redis supports an interesting feature: it is able to rebuild the append log file, in background, without to stop processing client commands. The key is the command <a href="BGREWRITEAOF.html">BGREWRITEAOF<\/a>. This command basically is able to use the dataset in memory in order to rewrite the shortest sequence of commands able to rebuild the exact dataset that is currently in memory.<br\/><br\/>So from time to time when the log gets too big, try this command. It's safe as if it fails you will not lost your old log (but you can make a backup copy given that currently 1.1 is still in beta!).<h2><a name="Wait... but how does this work?">Wait... but how does this work?<\/a><\/h2>Basically it uses the same fork() copy-on-write trick that snapshotting already uses. This is how the algorithm works:<br\/><br\/><ul><li> Redis forks, so now we have a child and a parent.<\/li><li> The child starts writing the new append log file in a temporary file.<\/li><li> The parent accumulates all the new changes in an in-memory buffer (but at the same time it writes the new changes in the <b>old<\/b> append only file, so if the rewriting fails, we are safe).<\/li><li> When the child finished to rewrite the file, the parent gets a signal, and append the in-memory buffer at the end of the file generated by the child.<\/li><li> Profit! Now Redis atomically renames the old file into the new one, and starts appending new data into the new file.<\/li><\/ul>$/;"	a
MAX_LATENCY	redis-benchmark.c	57;"	d	file:
MAX_LIT	lzf_c.c	74;"	d	file:
MAX_OFF	lzf_c.c	75;"	d	file:
MAX_REF	lzf_c.c	76;"	d	file:
MGET _key1_ _key2_ ... _keyN_	doc/MgetCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="MGET _key1_ _key2_ ... _keyN_">MGET _key1_ _key2_ ... _keyN_<\/a><\/h1>$/;"	a
MONITOR	doc/MonitorCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ControlCommandsSidebar.html">ControlCommandsSidebar<\/a><h1><a name="MONITOR">MONITOR<\/a><\/h1><blockquote>MONITOR is a debugging command that outputs the whole sequence of commandsreceived by the Redis server. is very handy in order to understandwhat is happening into the database. This command is used directlyvia telnet.<\/blockquote>$/;"	a
MOVE _key_ _dbindex_	doc/MoveCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="MOVE _key_ _dbindex_">MOVE _key_ _dbindex_<\/a><\/h1>$/;"	a
MSET Return value	doc/MsetCommand.html	/^<h2><a name="MSET Return value">MSET Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a> Basically +OK as MSET can't fail<h2><a name="MSETNX Return value">MSETNX Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
MSET _key1_ _value1_ _key2_ _value2_ ... _keyN_ _valueN_ (Redis &gt;	doc/MsetCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="MSET _key1_ _value1_ _key2_ _value2_ ... _keyN_ _valueN_ (Redis &gt;">MSET _key1_ _value1_ _key2_ _value2_ ... _keyN_ _valueN_ (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
MSETNX _key1_ _value1_ _key2_ _value2_ ... _keyN_ _valueN_ (Redis &gt;	doc/MsetCommand.html	/^<h1><a name="MSETNX _key1_ _value1_ _key2_ _value2_ ... _keyN_ _valueN_ (Redis &gt;">MSETNX _key1_ _value1_ _key2_ _value2_ ... _keyN_ _valueN_ (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
MULTI	doc/MultiExecCommand.html	/^<h1><a name="MULTI">MULTI<\/a><\/h1>$/;"	a
Making it horizontally scalable	doc/TwitterAlikeExample.html	/^<h1><a name="Making it horizontally scalable">Making it horizontally scalable<\/a><\/h1>$/;"	a
Memcached	doc/Comparisons.html	/^                    &iuml;&raquo;&iquest;if your are asking yourself how is Redis different fom other key-value stores here you will find it compared to some of the most popular contendors (all great software) in this category. <h2><a name="Memcached">Memcached<\/a><\/h2><ul><li> Memcached is not persistent, it just holds everything in memory without saving since its main goal is to be used as a cache, while Redis is <a href="Persistence.html">persistent<\/a>.<\/li><\/ul>$/;"	a
Messages matching both a pattern and a channel subscription	doc/PublishSubscribe.html	/^<h2><a name="Messages matching both a pattern and a channel subscription">Messages matching both a pattern and a channel subscription<\/a><\/h2>$/;"	a
Monitoring the VM	doc/VirtualMemoryUserGuide.html	/^Not all the kind of file systems are able to deal with large files in a good way, especially Mac OS X file system tends to be really lame about it.<br\/><br\/>The suggestion is to use Linux ext3 file system, or any other file system with good support for <b>sparse files<\/b>. What are sparse files?<br\/><br\/>Sparse files are files where a lot of the content happen to be empty. Advanced file systems like ext2, ext3, ext4, RaiserFS, Raiser4, and many others, are able to encode this files in a more efficient way and will allocate more space for the file when needed, that is, when more actual blocks of the file will be used.<br\/><br\/>The swap file is obviously pretty sparse, especially if the server is running since little time or it is much bigger compared to the amount of data swapped out. A file system not supporting sparse files can at some point block the Redis process while creating a very big file at once.<br\/><br\/>For a list of file systems supporting spare files <a href="http:\/\/en.wikipedia.org\/wiki\/Comparison_of_file_systems" target="_blank">check this Wikipedia page comparing different files systems<\/a>.<h2><a name="Monitoring the VM">Monitoring the VM<\/a><\/h2>Once you have a Redis system with VM enabled up and running, you may be very interested in knowing how it's working: how many objects are swapped in total, the number of objects swapped and loaded every second, and so forth.<br\/><br\/>There is an utility that is very handy in checking how the VM is working, that is part of <a href="http:\/\/code.google.com\/p\/redis-tools" target="_blank">Redis Tools<\/a>. This tool is called redis-stat, and using it is pretty straightforward:<br\/><br\/><pre class="codeblock python python python" name="code">$/;"	a
More details on the PUBLISH command	doc/PublishSubscribe.html	/^<h2><a name="More details on the PUBLISH command">More details on the PUBLISH command<\/a><\/h2>$/;"	a
Multi bulk reply	doc/ReplyTypes.html	/^A bulk reply is a binary-safe reply that is used to return a binary safe single string value (string is not limited to alphanumerical strings, it may contain binary data of any kind). Client libraries will usually return a string as return value of Redis commands returning bulk replies. There is a special bulk reply that signal that the element does not exist. When this happens the client library should return 'nil', 'false', or some other special element that can be distinguished by an empty string.<h1><a name="Multi bulk reply">Multi bulk reply<\/a><\/h1>$/;"	a
Multi-Bulk replies	doc/ProtocolSpecification.html	/^NULL, and so forth.<h2><a name="Multi-Bulk replies">Multi-Bulk replies<\/a><\/h2>Commands similar to LRANGE needs to return multiple values (every element$/;"	a
Multiple clients blocking for the same keys	doc/BlpopCommand.html	/^<h2><a name="Multiple clients blocking for the same keys">Multiple clients blocking for the same keys<\/a><\/h2><blockquote>Multiple clients can block for the same key. They are put intoa queue, so the first to be served will be the one that started to waitearlier, in a first-blpopping first-served fashion.<\/blockquote>$/;"	a
Multiple commands and pipelining	doc/ProtocolSpecification.html	/^modifications.<h2><a name="Multiple commands and pipelining">Multiple commands and pipelining<\/a><\/h2>A client can use the same connection in order to issue multiple commands.$/;"	a
NEXT	lzf_c.c	49;"	d	file:
Networking layer	doc/ProtocolSpecification.html	/^to get a first feeling of the protocol playing with it by TELNET.<h2><a name="Networking layer">Networking layer<\/a><\/h2>A client connects to a Redis server creating a TCP connection to the port 6379.$/;"	a
Nil elements in Multi-Bulk replies	doc/ProtocolSpecification.html	/^happens. This makes possible to distinguish between empty list and non existing ones.<h2><a name="Nil elements in Multi-Bulk replies">Nil elements in Multi-Bulk replies<\/a><\/h2>Single elements of a multi bulk reply may have -1 length, in order to signal that this elements are missing and not empty strings. This can happen with the SORT command when used with the GET <i>pattern<\/i> option when the specified key is missing. Example of a multi bulk reply containing an empty element:<br\/><br\/><pre class="codeblock python python python python python python python python" name="code">$/;"	a
Non blocking VM as probabilistic enhancement of blocking VM	doc/VirtualMemorySpecification.html	/^<h2><a name="Non blocking VM as probabilistic enhancement of blocking VM">Non blocking VM as probabilistic enhancement of blocking VM<\/a><\/h2>$/;"	a
Non blocking behavior	doc/BlpopCommand.html	/^<h2><a name="Non blocking behavior">Non blocking behavior<\/a><\/h2><blockquote>When BLPOP is called, if at least one of the specified keys contain a nonempty list, an element is popped from the head of the list and returned tothe caller together with the name of the key (BLPOP returns a two elementsarray, the first element is the key, the second the popped value).<\/blockquote>$/;"	a
Non blocking hash table	doc/RedisBigData.html	/^<h2><a name="Non blocking hash table">Non blocking hash table<\/a><\/h2>$/;"	a
Not Sorting at all	doc/SortCommand.html	/^<h2><a name="Not Sorting at all">Not Sorting at all<\/a><\/h2><pre class="codeblock python python python python python python" name="code">$/;"	a
Notes	doc/InfoCommand.html	/^<\/pre>All the fields are in the form <code name="code" class="python">field:value<\/code><h2><a name="Notes">Notes<\/a><\/h2><ul><li> <code name="code" class="python">used_memory<\/code> is returned in bytes, and is the total number of bytes allocated by the program using <code name="code" class="python">malloc<\/code>.<\/li><li> <code name="code" class="python">uptime_in_days<\/code> is redundant since the uptime in seconds contains already the full uptime information, this field is only mainly present for humans.<\/li><li> <code name="code" class="python">changes_since_last_save<\/code> does not refer to the number of key changes, but to the number of operations that produced some kind of change in the dataset.<\/li><\/ul>$/;"	a
OBJ	Makefile	/^OBJ = adlist.o ae.o anet.o dict.o redis.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o$/;"	m
OPTIMIZATION	Makefile	/^OPTIMIZATION?=-O2$/;"	m
Object Hash Mappers	doc/ObjectHashMappers.html	/^<h1><a name="Object Hash Mappers">Object Hash Mappers<\/a><\/h1>Looking for a higher level if abstraction for your Objects, their Properties and Relationships?<br\/><br\/>There is not need to stick to the <a href="SupportedLanguages.html">client libraries<\/a> exposing the raw features of Redis, here you will find a list of <b>Object Hash Mappers<\/b>,  working in the same fashion a ORM does.<h2><a name="Ruby">Ruby<\/a><\/h2><h3><a name="Ohm">Ohm<\/a><\/h3><ul><li> Object-hash mapping library for Redis. It includes an extensible list of validations and has very good performance.<\/li><li> Authors: <a href="http:\/\/soveran.com\/" target="_blank">Michel Martens<\/a>, <a href="http:\/\/twitter.com\/soveran" target="_blank">@soveran<\/a>; and Damian Janowski <a href="http:\/\/twitter.com\/djanowski" target="_blank">@djanowski<\/a>.<\/li><li> Repository: <a href="http:\/\/github.com\/soveran\/ohm" target="_blank">http:\/\/github.com\/soveran\/ohm<\/a><\/li><li> Group: <a href="http:\/\/groups.google.com\/group\/ohm-ruby" target="_blank">http:\/\/groups.google.com\/group\/ohm-ruby<\/a><\/li><\/ul>$/;"	a
Operating on ranges	doc/IntroductionToRedisDataTypes.html	/^<\/pre>A very important note, ZSets have just a &quot;default&quot; ordering but you are still free to call the <a href="SortCommand.html">SORT<\/a> command against sorted sets to get a different ordering (but this time the server will waste CPU). An alternative for having multiple orders is to add every element in multiple sorted sets at the same time.<h3><a name="Operating on ranges">Operating on ranges<\/a><\/h3>Sorted sets are more powerful than this. They can operate on ranges. For instance let's try to get all the individuals that born up to the 1950. We use the <a href="ZrangebyscoreCommand.html">ZRANGEBYSCORE<\/a> command to do it:<br\/><br\/><pre class="codeblock python python python python python python python python python python python python" name="code">$/;"	a
Out-of-range indexes	doc/LrangeCommand.html	/^behavior of range-related functions in your programming language of choice (think Ruby's Range.new, Array#slice or Python's range() function).<br\/><br\/>LRANGE behavior is consistent with one of Tcl.<h2><a name="Out-of-range indexes">Out-of-range indexes<\/a><\/h2>Indexes out of range will not produce an error: if start is over$/;"	a
PDP_ENDIAN	sha1.c	41;"	d	file:
PERSIST _key_	doc/ExpireCommand.html	/^<h1><a name="PERSIST _key_">PERSIST _key_<\/a><\/h1>$/;"	a
PHP	doc/SupportedLanguages.html	/^<h3><a name="PHP">PHP<\/a><\/h3><h4><a name="Redis PHP Bindings">Redis PHP Bindings<\/a><\/h4><ul><li> Simple default binding in Redis main repository. No longer under active development.<\/li><li> Author: <a href="http:\/\/qix.it\/" target="_blank">Ludovico Magnocavallo<\/a>, <a href="http:\/\/twitter.com\/ludo" target="_blank">@ludo<\/a>.<\/li><li> Repository: <a href="http:\/\/code.google.com\/p\/redis\/source\/browse\/#svn\/trunk\/client-libraries\/php" target="_blank">http:\/\/code.google.com\/p\/redis\/source\/browse\/#svn\/trunk\/client-libraries\/php<\/a><\/li><\/ul>$/;"	a
PREFIX_SIZE	zmalloc.c	38;"	d	file:
PREFIX_SIZE	zmalloc.c	40;"	d	file:
PRGNAME	Makefile	/^PRGNAME = redis-server$/;"	m
PSUBSCRIBE and PUNSUBSCRIBE: pattern matching subscriptions	doc/PublishSubscribe.html	/^<h2><a name="PSUBSCRIBE and PUNSUBSCRIBE: pattern matching subscriptions">PSUBSCRIBE and PUNSUBSCRIBE: pattern matching subscriptions<\/a><\/h2>$/;"	a
PSUBSCRIBE pattern_1 pattern_2 ... pattern_N	doc/PublishSubscribe.html	/^<h1><a name="PSUBSCRIBE pattern_1 pattern_2 ... pattern_N">PSUBSCRIBE pattern_1 pattern_2 ... pattern_N<\/a><\/h1>$/;"	a
PUBLISH channel message	doc/PublishSubscribe.html	/^<h1><a name="PUBLISH channel message">PUBLISH channel message<\/a><\/h1>Time complexity: subscribe is O(1), unsubscribe is O(N) where N is the number of clients already subscribed to a channel, publish is O(N+M) where N is the number of clients subscribed to the receiving channel, and M is the total number of subscribed patterns (by any client). Psubscribe is O(N) where N is the number of patterns the Psubscribing client is already subscribed to. Punsubscribe is O(N+M) where N is the number of patterns the Punsubscribing client is already subscribed and M is the number of total patterns subscribed in the system (by any client).<br\/><br\/><blockquote>SUBSCRIBE, UNSUBSCRIBE and PUBLISH commands implement the<a href="http:\/\/en.wikipedia.org\/wiki\/Publish\/subscribe" target="_blank">Publish\/Subscribe messaging paradigm<\/a> where (citing Wikipedia) senders (publishers) are not programmed to send their messages to specific receivers (subscribers). Rather, published messages are characterized into channels, without knowledge of what (if any) subscribers there may be. Subscribers express interest in one or more channels, and only receive messages that are of interest, without knowledge of what (if any) publishers there are. This decoupling of publishers and subscribers can allow for greater scalability and a more dynamic network topology.<\/blockquote>$/;"	a
PUNSUBSCRIBE (unsubscribe from all patterns)	doc/PublishSubscribe.html	/^<h1><a name="PUNSUBSCRIBE (unsubscribe from all patterns)">PUNSUBSCRIBE (unsubscribe from all patterns)<\/a><\/h1>$/;"	a
PUNSUBSCRIBE pattern_1 pattern_2 ... pattern_N	doc/PublishSubscribe.html	/^<h1><a name="PUNSUBSCRIBE pattern_1 pattern_2 ... pattern_N">PUNSUBSCRIBE pattern_1 pattern_2 ... pattern_N<\/a><\/h1>$/;"	a
Paginating updates	doc/TwitterAlikeExample.html	/^<h2><a name="Paginating updates">Paginating updates<\/a><\/h2>$/;"	a
Parameters value format	doc/ConfigCommand.html	/^<\/pre><h2><a name="Parameters value format">Parameters value format<\/a><\/h2><blockquote>The value of the configuration parameter is the same as the one of thesame parameter in the Redis configuration file, with the following exceptions:<\/blockquote>$/;"	a
Perl	doc/SupportedLanguages.html	/^<h3><a name="Perl">Perl<\/a><\/h3><h4><a name="Perl Client">Perl Client<\/a><\/h4><ul><li> Perl binding for Redis database.<\/li><li> Author: <a href="http:\/\/blog.rot13.org\/" target="_blank">Dobrica Pavlinusic<\/a>, <a href="http:\/\/twitter.com\/dpavlin" target="_blank">@dpavlin<\/a>.<\/li><li> Repository: <a href="http:\/\/svn.rot13.org\/index.cgi\/Redis" target="_blank">http:\/\/svn.rot13.org\/index.cgi\/Redis<\/a><\/li><\/ul>$/;"	a
Persistence control commands	doc/CommandReference.html	/^<h2><a name="Persistence control commands">Persistence control commands<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SaveCommand.html">SAVE<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Synchronously save the DB on disk  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="BgsaveCommand.html">BGSAVE<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Asynchronously save the DB on disk  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="LastsaveCommand.html">LASTSAVE<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Return the UNIX time stamp of the last successfully saving of the dataset on disk  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ShutdownCommand.html">SHUTDOWN<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Synchronously save the DB on disk, then shutdown the server  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="BgrewriteaofCommand.html">BGREWRITEAOF<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Rewrite the append only file in background when it gets too big  <\/td><\/tr><\/table>$/;"	a
Pipelining (DRAFT)	doc/Pipelining.html	/^                    <h1><a name="Pipelining (DRAFT)">Pipelining (DRAFT)<\/a><\/h1>A client library can use the same connection in order to issue multiple commands. But Redis supports <b>pipelining<\/b>, so multiple commands can be sent to the server with a single write operation by the client, without need to read the server reply in order to issue the next command. All the replies can be read at the end.<br\/><br\/>Usually Redis server and client will have a very fast link so this is not very important to support this feature in a client implementation, still if an application needs to issue a very large number of commands in s short time, using pipelining can be much faster.<br\/><br\/>Please read the <a href="ProtocolSpecification.html">ProtocolSpecification<\/a> if you want to learn more about the way Redis <a href="SupportedLanguages.html">clients<\/a> and the server communicate.<br\/><br\/>Pipelining is one of the <a href="Speed.html">Speed<\/a> <a href="Features.html">Features<\/a> of Redis, you can also check the support for <a href="MultiBulkCommands.html">send and receive multiple values in a single command<\/a>.$/;"	a
Play with the built in client	doc/QuickStart.html	/^<\/pre>With the <a href="Configuration.html">default configuration<\/a> Redis will log to the standard output so you can check what happens. Later, you can <a href="Configuration.html">change the default settings<\/a>.<h2><a name="Play with the built in client">Play with the built in client<\/a><\/h2>Redis ships with a command line client that is automatically compiled when you ran <code name="code" class="python">make<\/code> and it is called <code name="code" class="python">redis-cli<\/code>For instance to set a key and read back the value use the following:<br\/><br\/><pre class="codeblock python python python python python" name="code">$/;"	a
Predis	doc/SupportedLanguages.html	/^<h4><a name="Predis">Predis<\/a><\/h4><ul><li> A flexible and feature-complete PHP client library for the Redis key-value database. Predis is currently a work-in-progress and it targets PHP &gt;= 5.3, though it is highly due to be backported to PHP &gt;= 5.2.6 as soon as the public API and the internal design on the main branch will be considered stable enough.<\/li><li> Author: <a href="http:\/\/www.clorophilla.net\/blog\/" target="_blank">Daniele Alessandri<\/a>, <a href="http:\/\/twitter.com\/jol1hahn" target="_blank">@jol1hahn<\/a><\/li><li> Repository: <a href="http:\/\/github.com\/nrk\/predis\/" target="_blank">http:\/\/github.com\/nrk\/predis\/<\/a><\/li><\/ul>$/;"	a
Prerequisites	doc/TwitterAlikeExample.html	/^<h2><a name="Prerequisites">Prerequisites<\/a><\/h2>$/;"	a
Programming Example	doc/PublishSubscribe.html	/^<h2><a name="Programming Example">Programming Example<\/a><\/h2>$/;"	a
Programming Examples (DRAFT)	doc/ProgrammingExamples.html	/^<h1><a name="Programming Examples (DRAFT)">Programming Examples (DRAFT)<\/a><\/h1><h2><a name="TODO">TODO<\/a><\/h2><ul><li> Add <a href="http:\/\/github.com\/jodosha\/redis-store" target="_blank">http:\/\/github.com\/jodosha\/redis-store<\/a><\/li><\/ul>$/;"	a
Programming patterns: safe queues	doc/RpoplpushCommand.html	/^<h2><a name="Programming patterns: safe queues">Programming patterns: safe queues<\/a><\/h2><blockquote>Redis lists are often used as queues in order to exchange messages betweendifferent programs. A program can add a message performing an <a href="RpushCommand.html">LPUSH<\/a> operationagainst a Redis list (we call this program a Producer), while another program(that we call Consumer) can process the messages performing an <a href="LpopCommand.html">RPOP<\/a> commandin order to start reading the messages from the oldest.<\/blockquote>$/;"	a
Programming patterns: server-side O(N) list traversal	doc/RpoplpushCommand.html	/^<h2><a name="Programming patterns: server-side O(N) list traversal">Programming patterns: server-side O(N) list traversal<\/a><\/h2><blockquote>Using RPOPPUSH with the same source and destination key a process canvisit all the elements of an N-elements List in O(N) without to transferthe full list from the server to the client in a single <a href="LrangeCommand.html">LRANGE<\/a> operation.Note that a process can traverse the list even while other processesare actively RPUSHing against the list, and still no element will be skipped.<\/blockquote>$/;"	a
Publish/Subscribe	doc/CommandReference.html	/^<h2><a name="Publish\/Subscribe">Publish\/Subscribe<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="PublishSubscribe.html">SUBSCRIBE\/UNSUBSCRIBE\/PUBLISH<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Redis Public\/Subscribe messaging paradigm implementation  <\/td><\/tr><\/table>$/;"	a
Pushing IDs instead of the actual data in Redis lists	doc/IntroductionToRedisDataTypes.html	/^<\/pre>Note that <a href="LrangeCommand.html">LRANGE<\/a> takes two indexes, the first and the last element of the range to return. Both the indexes can be negative to tell Redis to start to count for the end, so -1 is the last element, -2 is the penultimate element of the list, and so forth.<br\/><br\/>As you can guess from the example above, lists can be used, for instance, in order to implement a chat system. Another use is as queues in order to route messages between different processes. But the key point is that <b>you can use Redis lists every time you require to access data in the same order they are added<\/b>. This will not require any SQL ORDER BY operation, will be very fast, and will scale to millions of elements even with a toy Linux box.<br\/><br\/>For instance in ranking systems like the social news reddit.com you can add every new submitted link into a List, and with <a href="LrangeCommand.html">LRANGE<\/a> it's possible to paginate results in a trivial way.<br\/><br\/>In a blog engine implementation you can have a list for every post, where to push blog comments, and so forth.<h3><a name="Pushing IDs instead of the actual data in Redis lists">Pushing IDs instead of the actual data in Redis lists<\/a><\/h3>In the above example we pushed our &quot;objects&quot; (simply messages in the example) directly inside the Redis list, but this is often not the way to go, as objects can be referenced in multiple times: in a list to preserve their chronological order, in a Set to remember they are about a specific category, in another list but only if this object matches some kind of requisite, and so forth.<br\/><br\/>Let's return back to the reddit.com example. A more credible pattern for adding submitted links (news) to the list is the following:<br\/><br\/><pre class="codeblock python python python python" name="code">$/;"	a
Python	doc/SupportedLanguages.html	/^<h3><a name="Python">Python<\/a><\/h3><h4><a name="Python Client">Python Client<\/a><\/h4><ul><li> Simple Python client in Redis main repository. No longer under active development.<\/li><li> Author: <a href="http:\/\/qix.it\/" target="_blank">Ludovico Magnocavallo<\/a>, <a href="http:\/\/twitter.com\/ludo" target="_blank">@ludo<\/a>.<\/li><li> Repository: <a href="http:\/\/code.google.com\/p\/redis\/source\/browse\/#svn\/trunk\/client-libraries\/python" target="_blank">http:\/\/code.google.com\/p\/redis\/source\/browse\/#svn\/trunk\/client-libraries\/python<\/a><\/li><\/ul>$/;"	a
Questions?	doc/VirtualMemorySpecification.html	/^<h2><a name="Questions?">Questions?<\/a><\/h2>$/;"	a
Quick Start	doc/QuickStart.html	/^<h1><a name="Quick Start">Quick Start<\/a><\/h1>This quickstart is a five minutes howto on how to get started with Redis. For more information on Redis check <a href="http:\/\/code.google.com\/p\/redis\/wiki\/index" target="_blank">Redis Documentation Index<\/a>.<h2><a name="Obtain the latest version">Obtain the latest version<\/a><\/h2>The latest stable source distribution of Redis can be obtained <a href="http:\/\/code.google.com\/p\/redis\/downloads\/list" target="_blank">at this location as a tarball<\/a>.<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Quit	doc/QuitCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ConnectionHandlingSidebar.html">ConnectionHandlingSidebar<\/a><h1><a name="Quit">Quit<\/a><\/h1><blockquote>Ask the server to silently close the connection.<\/blockquote>$/;"	a
R0	sha1.c	97;"	d	file:
R1	sha1.c	98;"	d	file:
R2	sha1.c	99;"	d	file:
R3	sha1.c	100;"	d	file:
R4	sha1.c	101;"	d	file:
RANDOMKEY	doc/RandomkeyCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="RANDOMKEY">RANDOMKEY<\/a><\/h1>$/;"	a
RCH	Makefile	/^	make ARCH="-m32"$/;"	m
REDIS_AGGR_MAX	redis.c	5971;"	d	file:
REDIS_AGGR_MIN	redis.c	5970;"	d	file:
REDIS_AGGR_SUM	redis.c	5969;"	d	file:
REDIS_BLOCKED	redis.c	191;"	d	file:
REDIS_CMD_BULK	redis-cli.c	48;"	d	file:
REDIS_CMD_BULK	redis.c	108;"	d	file:
REDIS_CMD_DENYOOM	redis.c	114;"	d	file:
REDIS_CMD_FORCE_REPLICATION	redis.c	115;"	d	file:
REDIS_CMD_INLINE	redis-cli.c	47;"	d	file:
REDIS_CMD_INLINE	redis.c	109;"	d	file:
REDIS_CMD_MULTIBULK	redis-cli.c	49;"	d	file:
REDIS_CONFIGLINE_MAX	redis.c	92;"	d	file:
REDIS_DEBUG	redis.c	219;"	d	file:
REDIS_DEFAULT_DBNUM	redis.c	91;"	d	file:
REDIS_ENCODING_HT	redis-check-dump.c	26;"	d	file:
REDIS_ENCODING_HT	redis.c	130;"	d	file:
REDIS_ENCODING_INT	redis-check-dump.c	24;"	d	file:
REDIS_ENCODING_INT	redis.c	128;"	d	file:
REDIS_ENCODING_RAW	redis-check-dump.c	23;"	d	file:
REDIS_ENCODING_RAW	redis.c	127;"	d	file:
REDIS_ENCODING_ZIPMAP	redis-check-dump.c	25;"	d	file:
REDIS_ENCODING_ZIPMAP	redis.c	129;"	d	file:
REDIS_EOF	redis-check-dump.c	31;"	d	file:
REDIS_EOF	redis.c	139;"	d	file:
REDIS_ERR	redis.c	83;"	d	file:
REDIS_EXPIRELOOKUPS_PER_CRON	redis.c	95;"	d	file:
REDIS_EXPIRETIME	redis-check-dump.c	29;"	d	file:
REDIS_EXPIRETIME	redis.c	137;"	d	file:
REDIS_GIT_DIRTY	release.h	2;"	d
REDIS_GIT_SHA1	release.h	1;"	d
REDIS_HASH	redis-check-dump.c	18;"	d	file:
REDIS_HASH	redis.c	122;"	d	file:
REDIS_HASH_KEY	redis.c	6430;"	d	file:
REDIS_HASH_MAX_ZIPMAP_ENTRIES	redis.c	236;"	d	file:
REDIS_HASH_MAX_ZIPMAP_VALUE	redis.c	237;"	d	file:
REDIS_HASH_VALUE	redis.c	6431;"	d	file:
REDIS_HEAD	redis.c	209;"	d	file:
REDIS_HT_MINFILL	redis.c	105;"	d	file:
REDIS_IOBUF_LEN	redis.c	88;"	d	file:
REDIS_IOJOB_DO_SWAP	redis.c	538;"	d	file:
REDIS_IOJOB_LOAD	redis.c	536;"	d	file:
REDIS_IOJOB_PREPARE_SWAP	redis.c	537;"	d	file:
REDIS_IO_WAIT	redis.c	192;"	d	file:
REDIS_LIST	redis-check-dump.c	15;"	d	file:
REDIS_LIST	redis.c	119;"	d	file:
REDIS_LOADBUF_LEN	redis.c	89;"	d	file:
REDIS_MASTER	redis.c	188;"	d	file:
REDIS_MAXIDLETIME	redis.c	87;"	d	file:
REDIS_MAX_COMPLETED_JOBS_PROCESSED	redis.c	184;"	d	file:
REDIS_MAX_SYNC_TIME	redis.c	94;"	d	file:
REDIS_MAX_WRITE_PER_EVENT	redis.c	96;"	d	file:
REDIS_MONITOR	redis.c	189;"	d	file:
REDIS_MULTI	redis.c	190;"	d	file:
REDIS_NOTICE	redis.c	221;"	d	file:
REDIS_NOTUSED	redis-benchmark.c	59;"	d	file:
REDIS_NOTUSED	redis-cli.c	51;"	d	file:
REDIS_NOTUSED	redis.c	225;"	d	file:
REDIS_OBJFREELIST_MAX	redis.c	93;"	d	file:
REDIS_OK	redis.c	82;"	d	file:
REDIS_OP_DIFF	redis.c	5345;"	d	file:
REDIS_OP_INTER	redis.c	5346;"	d	file:
REDIS_OP_UNION	redis.c	5344;"	d	file:
REDIS_RDB_14BITLEN	redis-check-dump.c	47;"	d	file:
REDIS_RDB_14BITLEN	redis.c	155;"	d	file:
REDIS_RDB_32BITLEN	redis-check-dump.c	48;"	d	file:
REDIS_RDB_32BITLEN	redis.c	156;"	d	file:
REDIS_RDB_6BITLEN	redis-check-dump.c	46;"	d	file:
REDIS_RDB_6BITLEN	redis.c	154;"	d	file:
REDIS_RDB_ENCVAL	redis-check-dump.c	49;"	d	file:
REDIS_RDB_ENCVAL	redis.c	157;"	d	file:
REDIS_RDB_ENC_INT16	redis-check-dump.c	56;"	d	file:
REDIS_RDB_ENC_INT16	redis.c	164;"	d	file:
REDIS_RDB_ENC_INT32	redis-check-dump.c	57;"	d	file:
REDIS_RDB_ENC_INT32	redis.c	165;"	d	file:
REDIS_RDB_ENC_INT8	redis-check-dump.c	55;"	d	file:
REDIS_RDB_ENC_INT8	redis.c	163;"	d	file:
REDIS_RDB_ENC_LZF	redis-check-dump.c	58;"	d	file:
REDIS_RDB_ENC_LZF	redis.c	166;"	d	file:
REDIS_RDB_LENERR	redis-check-dump.c	50;"	d	file:
REDIS_RDB_LENERR	redis.c	158;"	d	file:
REDIS_REPL_CONNECT	redis.c	196;"	d	file:
REDIS_REPL_CONNECTED	redis.c	197;"	d	file:
REDIS_REPL_NONE	redis.c	195;"	d	file:
REDIS_REPL_ONLINE	redis.c	206;"	d	file:
REDIS_REPL_SEND_BULK	redis.c	205;"	d	file:
REDIS_REPL_WAIT_BGSAVE_END	redis.c	204;"	d	file:
REDIS_REPL_WAIT_BGSAVE_START	redis.c	203;"	d	file:
REDIS_REQUEST_MAX_SIZE	redis.c	97;"	d	file:
REDIS_SELECTDB	redis-check-dump.c	30;"	d	file:
REDIS_SELECTDB	redis.c	138;"	d	file:
REDIS_SERVERPORT	redis.c	86;"	d	file:
REDIS_SET	redis-check-dump.c	16;"	d	file:
REDIS_SET	redis.c	120;"	d	file:
REDIS_SHARED_INTEGERS	redis.c	516;"	d	file:
REDIS_SLAVE	redis.c	187;"	d	file:
REDIS_SORTKEY_MAX	redis.c	216;"	d	file:
REDIS_SORT_ASC	redis.c	214;"	d	file:
REDIS_SORT_DESC	redis.c	215;"	d	file:
REDIS_SORT_GET	redis.c	213;"	d	file:
REDIS_STATIC_ARGS	redis.c	90;"	d	file:
REDIS_STRING	redis-check-dump.c	14;"	d	file:
REDIS_STRING	redis.c	118;"	d	file:
REDIS_TAIL	redis.c	210;"	d	file:
REDIS_THREAD_STACK_SIZE	redis.c	179;"	d	file:
REDIS_VERBOSE	redis.c	220;"	d	file:
REDIS_VERSION	redis.c	30;"	d	file:
REDIS_VM_LOADING	redis.c	172;"	d	file:
REDIS_VM_MAX_NEAR_PAGES	redis.c	176;"	d	file:
REDIS_VM_MAX_RANDOM_JUMP	redis.c	177;"	d	file:
REDIS_VM_MAX_THREADS	redis.c	178;"	d	file:
REDIS_VM_MEMORY	redis.c	169;"	d	file:
REDIS_VM_SWAPPED	redis.c	170;"	d	file:
REDIS_VM_SWAPPING	redis.c	171;"	d	file:
REDIS_WARNING	redis.c	222;"	d	file:
REDIS_WRITEV_IOVEC_COUNT	redis.c	102;"	d	file:
REDIS_WRITEV_THRESHOLD	redis.c	100;"	d	file:
REDIS_ZSET	redis-check-dump.c	17;"	d	file:
REDIS_ZSET	redis.c	121;"	d	file:
REG_CS	redis.h	/^  REG_CS,$/;"	e	enum:__anon4
REG_CS	redis.h	66;"	d
REG_DS	redis.h	/^  REG_DS,$/;"	e	enum:__anon4
REG_DS	redis.h	42;"	d
REG_EAX	redis.h	/^  REG_EAX,$/;"	e	enum:__anon4
REG_EAX	redis.h	58;"	d
REG_EBP	redis.h	/^  REG_EBP,$/;"	e	enum:__anon4
REG_EBP	redis.h	48;"	d
REG_EBX	redis.h	/^  REG_EBX,$/;"	e	enum:__anon4
REG_EBX	redis.h	52;"	d
REG_ECX	redis.h	/^  REG_ECX,$/;"	e	enum:__anon4
REG_ECX	redis.h	56;"	d
REG_EDI	redis.h	/^  REG_EDI,$/;"	e	enum:__anon4
REG_EDI	redis.h	44;"	d
REG_EDX	redis.h	/^  REG_EDX,$/;"	e	enum:__anon4
REG_EDX	redis.h	54;"	d
REG_EFL	redis.h	/^  REG_EFL,$/;"	e	enum:__anon4
REG_EFL	redis.h	68;"	d
REG_EIP	redis.h	/^  REG_EIP,$/;"	e	enum:__anon4
REG_EIP	redis.h	64;"	d
REG_ERR	redis.h	/^  REG_ERR,$/;"	e	enum:__anon4
REG_ERR	redis.h	62;"	d
REG_ES	redis.h	/^  REG_ES,$/;"	e	enum:__anon4
REG_ES	redis.h	40;"	d
REG_ESI	redis.h	/^  REG_ESI,$/;"	e	enum:__anon4
REG_ESI	redis.h	46;"	d
REG_ESP	redis.h	/^  REG_ESP,$/;"	e	enum:__anon4
REG_ESP	redis.h	50;"	d
REG_FS	redis.h	/^  REG_FS,$/;"	e	enum:__anon4
REG_FS	redis.h	38;"	d
REG_GS	redis.h	/^  REG_GS = 0,$/;"	e	enum:__anon4
REG_GS	redis.h	36;"	d
REG_SS	redis.h	/^  REG_SS$/;"	e	enum:__anon4
REG_SS	redis.h	72;"	d
REG_TRAPNO	redis.h	/^  REG_TRAPNO,$/;"	e	enum:__anon4
REG_TRAPNO	redis.h	60;"	d
REG_UESP	redis.h	/^  REG_UESP,$/;"	e	enum:__anon4
REG_UESP	redis.h	70;"	d
RENAME _oldkey_ _newkey_	doc/RenameCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="RENAME _oldkey_ _newkey_">RENAME _oldkey_ _newkey_<\/a><\/h1>$/;"	a
RENAMENX _oldkey_ _newkey_	doc/RenamenxCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="RENAMENX _oldkey_ _newkey_">RENAMENX _oldkey_ _newkey_<\/a><\/h1>$/;"	a
REPLY_BULK	redis-benchmark.c	50;"	d	file:
REPLY_INT	redis-benchmark.c	48;"	d	file:
REPLY_MBULK	redis-benchmark.c	51;"	d	file:
REPLY_RETCODE	redis-benchmark.c	49;"	d	file:
RPOP _key_	doc/LpopCommand.html	/^<h1><a name="RPOP _key_">RPOP _key_<\/a><\/h1>$/;"	a
RPOPLPUSH _srckey_ _dstkey_ (Redis &gt;	doc/RpoplpushCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="RPOPLPUSH _srckey_ _dstkey_ (Redis &gt;">RPOPLPUSH _srckey_ _dstkey_ (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
RPUSH _key_ _string_	doc/RpushCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h3><a name="RPUSH _key_ _string_">RPUSH _key_ _string_<\/a><\/h3>$/;"	a
R_Nan	redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_Nan	redis.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_NegInf	redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_NegInf	redis.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_PosInf	redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_PosInf	redis.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_Zero	redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_Zero	redis.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
Random things to know	doc/VirtualMemoryUserGuide.html	/^<ul><li> Clients accessing swapped out keys will block other clients while reading from disk, so the latency experimented by clients can be larger, especially if the disk is slow or busy and\/or if there are big values swapped on disk.<\/li><li> The blocking VM performances are <b>overall<\/b> better, as there is no time lost in synchronization, spawning of threads, resuming blocked clients waiting for values.<\/li><\/ul>So if you are willing to accept an higher latency from time to time, blocking VM can be a good pick, especially if swapping happens rarely as most of your often accessed data happens to fit in your memory.<br\/><br\/>If instead you have a lot of swap in and swap out operations and you have many cores that you want to exploit, and in general when you don't want that clients dealing with swapped values will block other clients for a few milliseconds (or more if the swapped value is very big), then it's better to use threaded VM.<br\/><br\/>To experiment with your dataset and different configurations is warmly encouraged...<h1><a name="Random things to know">Random things to know<\/a><\/h1>$/;"	a
Redis 0.100 Changelog	doc/Redis0100ChangeLog.html	/^                    <h1><a name="Redis 0.100 Changelog">Redis 0.100 Changelog<\/a><\/h1>$/;"	a
Redis CLI	doc/RedisCLI.html	/^<h1><a name="Redis CLI">Redis CLI<\/a><\/h1>$/;"	a
Redis Event Library	doc/RedisEventLibrary.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="RedisInternals.html">RedisInternals<\/a><h1><a name="Redis Event Library">Redis Event Library<\/a><\/h1>Redis implements its own event library. The event library is implemented in <b>ae.c<\/b>.<br\/><br\/>The best way to understand how the Redis event library works is to understand how Redis uses it.<h2><a name="Event Loop Initialization">Event Loop Initialization<\/a><\/h2>$/;"	a
Redis Hash Type	doc/Hashes.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="HashCommandsSidebar.html">HashCommandsSidebar<\/a><h1><a name="Redis Hash Type">Redis Hash Type<\/a><\/h1>Redis Hashes are unordered maps of <a href="String.html">Redis Strings<\/a> between fields and values. It is possible to add, remove, test for existence of fields in O(1) amortized time. It is also possible to enumerate all the keys, values, or both, in O(N) (where N is the number of fields inside the hash).<br\/><br\/>Redis Hashes are interesting because they are very well suited to represent objects. For instance web applications users can be represented by a Redis Hash containing fields such username, encrpypted_password, lastlogin, and so forth.<br\/><br\/>Another very important property of Redis Hashes is that they use very little memory for hashes composed of a small number of fields (configurable, check redis.conf for details), compared to storing every field as a top level Redis key. This is obtained using a different specialized representation for small hashes. See the implementation details paragraph below for more information.<br\/><br\/>Commands operating on hashes try to make a good use of the return value in order to signal the application about previous existence of fields. For instance the <a href="HsetCommand.html">HSET<\/a> command will return 1 if the field set was not already present in the hash, otherwise will return 0 (and the user knows this was just an update operation).<br\/><br\/>The max number of fields in a set is 232-1 (4294967295, more than 4 billion of members per hash).<h1><a name="Implementation details">Implementation details<\/a><\/h1>The obvious internal representation of hashes is indeed an hash table, as the name of the data structure itself suggests. Still the drawback of this representation is that there is a lot of space overhead for hash table metadata.<br\/><br\/>Because one of the most interesting uses of Hashes is object encoding, and objects are often composed of a few fields each, Redis uses a different internal representation for small hashes (for Redis to consider a hash small, this must be composed a limited number of fields, and each field and value can't exceed a given number of bytes. All this is user-configurable).<br\/><br\/>Small hashes are thus encoded using a data structure called zipmap (is not something you can find in a CS book, the name is a Redis invention), that is a very memory efficient data structure to represent string to string maps, at the cost of being O(N) instead of O(1) for most operations. Since the constant times of this data structure are very small, and the zipmaps are converted into real hash tables once they are big enough, the amortized time of Redis hashes is still O(1), and in the practice small zipmaps are not slower than small hash tables because they are designed for good cache locality and fast access.<br\/><br\/>The result is that small hashes are both memory efficient and fast, while bigger hashes are fast but not as memory efficient than small hashes.$/;"	a
Redis Internals	doc/RedisInternals.html	/^                    <h1><a name="Redis Internals">Redis Internals<\/a><\/h1>This is a source code level documentation of Redis.<h2><a name="Redis STRINGS">Redis STRINGS<\/a><\/h2>String is the basic building block of Redis types. <br\/><br\/>Redis is a key-value store.$/;"	a
Redis List Type	doc/Lists.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ListCommandsSidebar.html">ListCommandsSidebar<\/a><h1><a name="Redis List Type">Redis List Type<\/a><\/h1>Redis Lists are lists of <a href="Strings.html">Redis Strings<\/a>, sorted by insertion order. It's possible to add elements to a Redis List pushing new elements on the head (on the left) or on the tail (on the right) of the list.<br\/><br\/>The <a href="RpushCommand.html">LPUSH<\/a> command inserts a new elmenet on head, while <a href="RpushCommand.html">RPUSH<\/a> inserts a new element on tail. A new list is created when one of this operations is performed against an empty key.<br\/><br\/>For instance if perform the following operations:$/;"	a
Redis Replication Howto	doc/ReplicationHowto.html	/^<h1><a name="Redis Replication Howto">Redis Replication Howto<\/a><\/h1><h2><a name="General Information">General Information<\/a><\/h2>Redis replication is a very simple to use and configure master-slave replication that allows slave Redis servers to be exact copies of master servers. The following are some very important facts about Redis replication:<br\/><br\/><ul><li> A master can have multiple slaves.<\/li><li> Slaves are able to accept other slaves connections, so instead to connect a number of slaves against the same master it is also possible to connect some of the slaves to other slaves in a graph-alike structure.<\/li><li> Redis replication is non-blocking on the master side, this means that the master will continue to serve queries while one or more slaves are performing the first synchronization. Instead replication is blocking on the slave side: while the slave is performing the first synchronization it can't reply to queries.<\/li><li> Replications can be used both for scalability, in order to have multiple slaves for read-only queries (for example heavy <a href="SortCommand.html">SORT<\/a> operations can be launched against slaves), or simply for data redundancy.<\/li><li> It is possible to use replication to avoid the saving process on the master side: just configure your master redis.conf in order to avoid saving at all (just comment al the &quot;save&quot; directives), then connect a slave configured to save from time to time.<\/li><\/ul>$/;"	a
Redis Reply Types	doc/ReplyTypes.html	/^                    <h1><a name="Redis Reply Types">Redis Reply Types<\/a><\/h1>Redis commands can reply to the client with four different kind of replies, you can find the protocol level specification of this replies in the <a href="ProtocolSpecification.html">Redis Protocol Specification<\/a>. This page is instead an higher level description of the four types of replies from the point of view of the final user.<h1><a name="Status code reply">Status code reply<\/a><\/h1>$/;"	a
Redis Set Type	doc/Sets.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="Redis Set Type">Redis Set Type<\/a><\/h1>Redis Sets are unordered collections of <a href="Strings.html">Redis Strings<\/a>. It's possible to add, remove, and test for existence of members in O(1).<br\/><br\/>Redis Sets have the desirable property of not allowing repeated members. Adding the same element multiple times will result in a set having a single copy of this element. Practically speaking this means that adding an members does not require a &quot;check if exists then add&quot; operation.<br\/><br\/>Commands operating on sets try to make a good use of the return value in order to signal the application about previous existence of members. For instance the <a href="SaddCommand.html">SADD<\/a> command will return 1 if the element added was not already a member of the set, otherwise will return 0.<br\/><br\/>The max number of members in a set is 232-1 (4294967295, more than 4 billion of members per set).<br\/><br\/>Redis Sets support a wide range of operations, like union, intersection, difference. Intersection is optimized in order to perform the smallest number of lookups. For instance if you try to intersect a 10000 members set with a 2 members set Redis will iterate the 2 members set testing for members existence in the other set, performing 2 lookups instead of 10000.<h1><a name="Implementation details">Implementation details<\/a><\/h1>Redis Sets are implemented using hash tables, so adding, removing and testing for members is O(1) in the average. The hash table will automatically resize when new elements are added or removed into a Set.<br\/><br\/>The hash table resizing is a blocking operation performed synchronously so working with huge sets (consisting of many millions of elements) care should be taken when mass-inserting a very big amount of elements in a Set while other clients are querying Redis at high speed.<br\/><br\/>It is possible that in the near future Redis will switch to skip lists (already used in sorted sets) in order to avoid such a problem.$/;"	a
Redis Sets	doc/IntroductionToRedisDataTypes.html	/^<\/pre>We obtained an unique incremental ID for our news object just incrementing a key, then used this ID to create the object setting a key for every field in the object. Finally the ID of the new object was pushed on the <b>submitted.news<\/b> list.<br\/><br\/>This is just the start. Check the <a href="CommandReference.html">Command Reference<\/a> and read about all the other list related commands. You can remove elements, rotate lists, get and set elements by index, and of course retrieve the length of the list with <a href="LLenCommand.html">LLEN<\/a>.<h2><a name="Redis Sets">Redis Sets<\/a><\/h2>Redis Sets are unordered collection of binary-safe strings. The <a href="SaddCommand.html">SADD<\/a> command adds a new element to a set. It's also possible to do a number of other operations against sets like testing if a given element already exists, performing the intersection, union or difference between multiple sets and so forth. An example is worth 1000 words:<br\/><br\/><pre class="codeblock python python python python python" name="code">$/;"	a
Redis Sorted Set Type	doc/SortedSets.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SortedSetCommandsSidebar.html">SortedSetCommandsSidebar<\/a><h1><a name="Redis Sorted Set Type">Redis Sorted Set Type<\/a><\/h1>Redis Sorted Sets are, similarly to <a href="Sets.html">Sets<\/a>, collections of <a href="Strings.html">Redis Strings<\/a>. The difference is that every member of a Sorted Set hash an <b>associated score<\/b> that is used in order to take this member in order.<br\/><br\/>The <a href="ZaddCommand.html">ZADD<\/a> command is used to add a new member to a Sorted Set, specifying the score of the element. Calling ZADD against a member already present in the sorted set but using a different score will update the score for the element, moving it to the right position in order to preserve ordering.<br\/><br\/>It's possible to get ranges of elements from Sorted Sets in a very similar way to what happens with <a href="Lists.html">Lists<\/a> and the <a href="LrangeCommnad.html">LRANGE<\/a> command  using the Sorted Sets <a href="ZrangeCommand.html">ZRANGE<\/a> command.<br\/><br\/>It's also possible to get or remove ranges of elements by score using the <a href="ZrangebyscoreCommand.html">ZRANGEBYSCORE<\/a> and <a href="ZremrangebyscoreCommand.html">ZREMRANGEBYSCORE<\/a> commands.<br\/><br\/>The max number of members in a sorted set is 232-1 (4294967295, more than 4 billion of members per set).<br\/><br\/>Note that while Sorted Sets are already ordered, it is still possible to use the <a href="SortCommand.html">SORT<\/a> command against sorted sets to get the elements in a different order.<h1><a name="Implementation details">Implementation details<\/a><\/h1>Redis Sets are implemented using a dual-ported data structure containing a skip list and an hash table. When an element is added a map between the element and the score is added to the hash table (so that given the element we get the score in O(1)), and a map between the score and the element is added in the skip list so that elements are taken in order.<br\/><br\/>Redis uses a special skip list implementation that is doubly linked so that it's possible to traverse the sorted set from tail to head if needed (Check the <a href="ZRevrangeCommand.html">ZREVRANGE<\/a> command).<br\/><br\/>When <a href="ZaddCommand.html">ZADD<\/a> is used in order to update the score of an element, Redis retrieve the score of the element using the hash table, so that it's fast to access the element inside the skip list (that's indexed by score) in order to update the position.<br\/><br\/>Like it happens for Sets the hash table resizing is a blocking operation performed synchronously so working with huge sorted sets (consisting of many millions of elements) care should be taken when mass-inserting a very big amount of elements in a Set while other clients are querying Redis at high speed.<br\/><br\/>It is possible that in the near future Redis will switch to skip lists even for the element =&gt; score map, so every Sorted Set will have two skip lists, one indexed by element and one indexed by score.$/;"	a
Redis Sponsorship History	doc/SponsorshipHistory.html	/^                    <h1><a name="Redis Sponsorship History">Redis Sponsorship History<\/a><\/h1><b>Important notice: since 15 March 2010 I Joined VMware that is sponsoring all my work on Redis.<\/b> Thank you to all the companies and people donating in the past. No further donations are accepted.<br\/><br\/>This is a list of companies that sponsorship Redis developments, with details about the sponsored features. <b>Thanks for helping the project!<\/b>.<br\/><br\/><ul><li> <a href="http:\/\/www.linode.com\/?r=5cf1759a154c981368394fca9918970f60b6a2b3" target="_blank"><img src="http:\/\/www.linode.com\/images\/linode_logo10.gif" border="0"><\/img><\/a><br><\/br> 15 January 2010, provided Virtual Machines for Redis testing in a virtualized environment.<\/li><li> <a href="https:\/\/manage.slicehost.com\/customers\/new?referrer=d6272cc9e5f38cd2513e760e4d22bd9d" target="_blank"><img src="http:\/\/wiki.slicehost.com\/lib\/exe\/fetch.php?w=&h=&cache=cache&media=slicehost.gif" border="0"><\/img><\/a><br><\/br> 14 January 2010, provided Virtual Machines for Redis testing in a virtualized environment.<\/li><li> <a href="http:\/\/citrusbyte.com" target="_blank"><img src="http:\/\/redis.googlecode.com\/files\/citrusbyte_logo.png" border="0"><\/img><\/a><br><\/br> 18 Dec 2009, part of Virtual Memory.<\/li><li> <a href="http:\/\/www.hitmeister.de\/" target="_blank"><img src="http:\/\/redis.googlecode.com\/files\/logo_hitmeister_2.png" border="0"><\/img><\/a><br><\/br> 15 Dec 2009, part of Redis Cluster.<\/li><li> <a href="http:\/\/engineyard.com" target="_blank"><img src="http:\/\/redis.googlecode.com\/files\/engine_yard_logo.jpg" border="0"><\/img><\/a><br><\/br> 13 Dec 2009, for blocking POP (BLPOP) and part of the Virtual Memory implementation.<\/li><\/ul>$/;"	a
Redis String Type	doc/Strings.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="Redis String Type">Redis String Type<\/a><\/h1>Strings are the most basic Redis kind of values. Redis Strings are binary safe, this means a Redis string can contain any kind of data, for instance a JPEG image or a serialized Ruby object, and so forth.<br\/><br\/>A String value can be at max 1 Gigabyte in length.<br\/><br\/>Strings are treated as integer values by the <a href="IncrCommand.html">INCR<\/a> commands family, in this respect the value of an intger is limited to a singed 64 bit value.<br\/><br\/>Note that the single elements contained in Redis <a href="Lists.html">Lists<\/a>, <a href="Sets.html">Sets<\/a> and <a href="SortedSets.html">Sorted Sets<\/a>, are Redis Strings.<h1><a name="Implementation details">Implementation details<\/a><\/h1>Strings are implemented using a dynamic strings library called <code name="code" class="python">sds.c<\/code> (simple dynamic strings). This library caches the current length of the string, so to obtain the length of a Redis string is an O(1) operation (but currently there is no such STRLEN command. It will likely be added later).<br\/><br\/>Redis strings are incapsualted into Redis Objects. Redis Objects use a reference counting memory management system, so a single Redis String can be shared in different places of the dataset. This means that if you happen to use the same strings many times (especially if you have <i>object sharing<\/i> turned on in the configuration file) Redis will try to use the same string object instead to allocate one new every time.<br\/><br\/>Starting from version 1.1 Redis is also able to encode in a special way strings that are actually just numbers. Instead to save the string as an array of characters Redis will save the integer value in order to use less memory. With many datasets this can reduce the memory usage of about 30% compared to Redis 1.0.$/;"	a
Redis Virtual Memory	doc/RedisInternals.html	/^these are composed of strings.<br\/><br\/><a href="HackingStrings.html">Hacking Strings<\/a> documents the Redis String implementation details.<h2><a name="Redis Virtual Memory">Redis Virtual Memory<\/a><\/h2>A technical specification full of details about the <a href="VirtualMemorySpecification.html">Redis Virtual Memory subsystem<\/a><h2><a name="Redis Event Library">Redis Event Library<\/a><\/h2>Read <a href="EventLibray.html">event library<\/a> to understand what an event library does and why its needed.<br\/><br\/><a href="RedisEventLibrary.html">Redis event library<\/a> documents the implementation details of the event library used by Redis $/;"	a
Redis keys	doc/IntroductionToRedisDataTypes.html	/^It's not always trivial to grasp how this data types work and what to use in order to solve a given problem from the <a href="CommandReference.html">Redis command reference<\/a>, so this document is a crash course to Redis data types and their most used patterns.<br\/><br\/>For all the examples we'll use the <b>redis-cli<\/b> utility, that's a simple but handy command line utility to issue commands against the Redis server.<h2><a name="Redis keys">Redis keys<\/a><\/h2>Before to start talking about the different kind of values supported by Redis it is better to start saying that keys are not binary safe strings in Redis, but just strings not containing a space or a newline character. For instance &quot;foo&quot; or &quot;123456789&quot; or &quot;foo_bar&quot; are valid keys, while &quot;hello world&quot; or &quot;hello\\n&quot; are not.<br\/><br\/>Actually there is nothing inside the Redis internals preventing the use of binary keys, it's just a matter of protocol, and actually the new protocol introduced with Redis 1.2 (1.2 betas are 1.1.x) in order to implement commands like MSET, is totally binary safe. Still for now consider this as an hard limit as the database is only tested with &quot;normal&quot; keys.<br\/><br\/>A few other rules about keys:<br\/><br\/><ul><li> Too long keys are not a good idea, for instance a key of 1024 bytes is not a good idea not only memory-wise, but also because the lookup of the key in the dataset may require several costly key-comparisons.<\/li><li> Too short keys are not a good idea. There is no point in writing &quot;u:1000:pwd&quot; as key if you can write instead &quot;user:1000:password&quot;, the latter is more readable and the added space is very little compared to the space used by the key object itself.<\/li><li> Try to stick with a schema. For instance &quot;object-type:id:field&quot; can be a nice idea, like in &quot;user:1000:password&quot;. I like to use dots for multi-words fields, like in &quot;comment:1234:reply.to&quot;.<\/li><\/ul>$/;"	a
Redis with VM enabled: better .rdb files or Append Only File?	doc/VirtualMemoryUserGuide.html	/^<\/pre>The above output is about a redis-server with VM enable, around 1 million of keys inside, and a lot of simulated load using the redis-load utility.<br\/><br\/>As you can see from the output a number of load-in and swap-out operations are happening every second. Note that the first line reports the actual values since the server was started, while the next lines are differences compared to the previous reading.<br\/><br\/>If you assigned enough memory to hold your working set of data, probably you should see a lot less dramatic swapping happening, so redis-stat can be a really valuable tool in order to understand if you need to shop for RAM ;)<h2><a name="Redis with VM enabled: better .rdb files or Append Only File?">Redis with VM enabled: better .rdb files or Append Only File?<\/a><\/h2>When VM is enabled, saving and loading the database are <b>much slower<\/b> operations. A DB that usually loads in 2 seconds takes 13 seconds with VM enabled if the server is configured to use the smallest memory possible (that is, vm-max-memory set to 0).<br\/><br\/>So you probably want to switch to a configuration using the Append Only File for persistence, so that you can perform the BGREWRITEAOF from time to time.<br\/><br\/>It is important to note that while a BGSAVE or BGREWRITEAOF is in progress Redis does <b>not<\/b> swap new values on disk. The VM will be read-only while there is another child accessing it. So if you have a lot of writes while there is a child working, the memory usage may grow.<h2><a name="Using as little memory as possible">Using as little memory as possible<\/a><\/h2>An interesting setup to turn Redis into an on-disk DB with just keys in memory is setting vm-max-memory to 0. If you don't mind some latency more and poorer performances but want to use very little memory for very big values, this is a good setup.<br\/><br\/>In this setup you should first try setting the VM as blocking (vm-max-threads 0) as with this configuration and high traffic the number of swap in and swap out operations will be huge, and threading will consume a lot of resources compared to a simple blocking implementation.<h2><a name="VM Stability">VM Stability<\/a><\/h2>VM is still experimental code, but in the latest weeks it was tested in many ways in development environments, and even in some production environment. No bugs were noticed during this testing period. Still the more obscure bugs may happen in non controlled environments where there are setups that we are not able to reproduce for some reason.<br\/><br\/>In this stage you are encouraged to try VM in your development environment, and even in production if your DB is not mission critical, but for instance just a big persistent cache of data that may go away without too much problems.<br\/><br\/>Please report any problem you will notice to the Redis Google Group or by IRC joining the #redis IRC channel on freenode.$/;"	a
Redisent	doc/SupportedLanguages.html	/^<h4><a name="Redisent">Redisent<\/a><\/h4><ul><li> Redisent is a simple, no-nonsense interface to the Redis key-value store for modest developers. Due to the way it is implemented, it is flexible and tolerant of changes to the Redis protocol.<\/li><li> Author: <a href="http:\/\/blog.justinpoliey.com\/" target="_blank">Justin Poliey<\/a>, <a href="http:\/\/twitter.com\/justinpoliey" target="_blank">@justinpoliey<\/a><\/li><li> Repository: <a href="http:\/\/github.com\/jdp\/redisent" target="_blank">http:\/\/github.com\/jdp\/redisent<\/a><\/li><\/ul>$/;"	a
Remote server control commands	doc/CommandReference.html	/^<h2><a name="Remote server control commands">Remote server control commands<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="InfoCommand.html">INFO<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Provide information and statistics about the server  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="MonitorCommand.html">MONITOR<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Dump all the received requests in real time  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SlaveofCommand.html">SLAVEOF<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Change the replication settings  <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="ConfigCommand.html">CONFIG<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> -  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Configure a Redis server at runtime  <\/td><\/tr><\/table>$/;"	a
Reply Packet	doc/UDP.html	/^<h2><a name="Reply Packet">Reply Packet<\/a><\/h2>The reply packet is generated by the Redis server when a command received by $/;"	a
Request ACK packet and ACK packet	doc/UDP.html	/^<h2><a name="Request ACK packet and ACK packet">Request ACK packet and ACK packet<\/a><\/h2>Clients may request an acknowledge regarding a command recently issued.$/;"	a
Request Packets	doc/UDP.html	/^a maximum time of 10 seconds.<h2><a name="Request Packets">Request Packets<\/a><\/h2>The UDP request packet is sent by the client to the server, in order to run$/;"	a
Restrictions for write operations with volatile keys as sources	doc/ExpireCommand.html	/^<h2><a name="Restrictions for write operations with volatile keys as sources">Restrictions for write operations with volatile keys as sources<\/a><\/h2>Even when the volatile key is not modified as part of a write operation, if it is $/;"	a
Restrictions with write operations against volatile keys	doc/ExpireCommand.html	/^<h2><a name="Restrictions with write operations against volatile keys">Restrictions with write operations against volatile keys<\/a><\/h2><blockquote>IMPORTANT: Since Redis 2.1.3 or greater, there are no restrictions aboutthe operations you can perform against volatile keys, however older versionsof Redis, including the current stable version 2.0.0, has the followinglimitations:<\/blockquote>$/;"	a
Retrieving external keys	doc/SortCommand.html	/^<h2><a name="Retrieving external keys">Retrieving external keys<\/a><\/h2><pre class="codeblock python python python python python python python" name="code">$/;"	a
Return value	doc/AppendCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically the total length of the string after the append operation.<h2><a name="Examples">Examples<\/a><\/h2><pre class="codeblock python" name="code">$/;"	a
Return value	doc/AuthCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/BgrewriteaofCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/BgsaveCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/BlpopCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><blockquote>BLPOP returns a two-elements array via a multi bulk reply in order to returnboth the unblocking key and the popped value.<\/blockquote>$/;"	a
Return value	doc/DbsizeCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>$/;"	a
Return value	doc/DelCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ExistsCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ExpireCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python python" name="code">$/;"	a
Return value	doc/FlushallCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/FlushdbCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/GetCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a>$/;"	a
Return value	doc/GetsetCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a><h2><a name="Design patterns">Design patterns<\/a><\/h2><blockquote>GETSET can be used together with INCR for counting with atomic reset whena given condition arises. For example a process may call INCR against thekey <i>mycounter<\/i> every time some event occurred, but from time totime we need to get the value of the counter and reset it to zero atomicallyusing <code name="code" class="python">GETSET mycounter 0<\/code>.<\/blockquote>$/;"	a
Return value	doc/HdelCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>$/;"	a
Return value	doc/HexistsCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>$/;"	a
Return value	doc/HgetCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a>$/;"	a
Return value	doc/HgetallCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi Bulk Reply<\/a>$/;"	a
Return value	doc/HincrbyCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a> The new value at <i>field<\/i> after the increment operation.$/;"	a
Return value	doc/HlenCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>$/;"	a
Return value	doc/HmgetCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi Bulk Reply<\/a> specifically a list of all the values associated with the specified fields, in the same order of the request.$/;"	a
Return value	doc/HmsetCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a> Always +OK because HMSET can't fail$/;"	a
Return value	doc/HsetCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>$/;"	a
Return value	doc/HsetnxCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>$/;"	a
Return value	doc/IncrCommand.html	/^Note: this is actually a string operation, that is, in Redis there are not &quot;integer&quot; types. Simply the string stored at the key is parsed as a base 10 64 bit signed integer, incremented, and then converted back as a string.<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, this commands will reply with the new value of <i>key<\/i> after the increment or decrement.$/;"	a
Return value	doc/InfoCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a>, specifically in the following format:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/KeysCommand.html	/^<blockquote>* h?llo will match hello hallo hhllo* h*llo will match hllo heeeello* h<code name="code" class="python">[<\/code>ae<code name="code" class="python">]<\/code>llo will match hello and hallo, but not hillo<\/blockquote>Use \\ to escape special chars if you want to match them verbatim.<h2><a name="Return value">Return value<\/a><\/h2>$/;"	a
Return value	doc/LastsaveCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically an UNIX time stamp.$/;"	a
Return value	doc/LindexCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a>, specifically the requested element.$/;"	a
Return value	doc/LlenCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/LpopCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a>$/;"	a
Return value	doc/LrangeCommand.html	/^the last element of the list.<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi bulk reply<\/a>, specifically a list of elements in the specified range.$/;"	a
Return value	doc/LremCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer Reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/LsetCommand.html	/^<blockquote>Similarly to other list commands accepting indexes, the index can be negative to access elements starting from the end of the list. So -1 is the last element, -2 is the penultimate, and so forth.<\/blockquote><h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/LtrimCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/MgetCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi bulk reply<\/a><h2><a name="Example">Example<\/a><\/h2><pre class="codeblock python" name="code">$/;"	a
Return value	doc/MonitorCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><b>Non standard return value<\/b>, just dumps the received commands in an infinite flow.$/;"	a
Return value	doc/MoveCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/MultiExecCommand.html	/^If EXEC fails (returns a nil value) we just re-iterate the operation.<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi bulk reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python python python python python python python python" name="code">$/;"	a
Return value	doc/QuitCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2>None. The connection is closed as soon as the QUIT command is received.$/;"	a
Return value	doc/RandomkeyCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Singe line reply<\/a>, specifically the randomly selected key or an empty string is the database is empty.$/;"	a
Return value	doc/RenameCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code repy<\/a>$/;"	a
Return value	doc/RenamenxCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/RpoplpushCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a>$/;"	a
Return value	doc/RpushCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically, the number of elements inside the list after the push operation.$/;"	a
Return value	doc/SaddCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/SaveCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/ScardCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/SdiffCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi bulk reply<\/a>, specifically the list of common elements.$/;"	a
Return value	doc/SdiffstoreCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/SelectCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/SetCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/SetexCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/SetnxCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ShutdownCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a> on error. On success nothing is returned since the server quits and the connection is closed.$/;"	a
Return value	doc/SinterCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi bulk reply<\/a>, specifically the list of common elements.$/;"	a
Return value	doc/SinterstoreCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/SismemberCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/SlaveofCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/SmembersCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi bulk reply<\/a>$/;"	a
Return value	doc/SmoveCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/SortCommand.html	/^<blockquote>The two chars string -&gt; is used in order to signal the name of the Hash field. The key is substituted as documented above with sort BY and GET against normal keys, and the Hash stored at the resulting key is accessed in order to retrieve the specified field.<\/blockquote><h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi bulk reply<\/a>, specifically a list of sorted elements.$/;"	a
Return value	doc/SpopCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a>$/;"	a
Return value	doc/SrandmemberCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a>$/;"	a
Return value	doc/SremCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/SubstrCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a><h2><a name="Examples">Examples<\/a><\/h2><pre class="codeblock python" name="code">$/;"	a
Return value	doc/SunionCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi bulk reply<\/a>, specifically the list of common elements.$/;"	a
Return value	doc/SunionstoreCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>$/;"	a
Return value	doc/TemplateCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">ReplyTypes<\/a><h2><a name="See also">See also<\/a><\/h2>$/;"	a
Return value	doc/TtlCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>$/;"	a
Return value	doc/TypeCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Status code reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ZaddCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ZcardCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ZincrbyCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ZrangeCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Multi bulk reply<\/a>, specifically a list of elements in the specified range.$/;"	a
Return value	doc/ZrangebyscoreCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2>ZRANGEBYSCORE returns a <a href="ReplyTypes.html">Multi bulk reply<\/a> specifically a list of elements in the specified score range.<br\/><br\/>ZCOUNT returns a <a href="ReplyTypes.html">Integer reply<\/a> specifically the number of elements matching the specified score range.$/;"	a
Return value	doc/ZrankCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ZremCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ZremrangebyrankCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically the number of elements removed.$/;"	a
Return value	doc/ZremrangebyscoreCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically the number of elements removed.$/;"	a
Return value	doc/ZscoreCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Bulk reply<\/a><pre class="codeblock python" name="code">$/;"	a
Return value	doc/ZunionCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically the number of elements in the sorted set at <i>dstkey<\/i>.$/;"	a
Return value	doc/ZunionstoreCommand.html	/^<h2><a name="Return value">Return value<\/a><\/h2><a href="ReplyTypes.html">Integer reply<\/a>, specifically the number of elements in the sorted set at <i>dstkey<\/i>.$/;"	a
Road Map (ROUGH DRAFT)	doc/RoadMap.html	/^<h1><a name="Road Map (ROUGH DRAFT)">Road Map (ROUGH DRAFT)<\/a><\/h1>The up to date, raw Road Map for Redis is part of the source code, you can find it here: <a href="http:\/\/github.com\/antirez\/redis\/raw\/master\/TODO" target="_blank">http:\/\/github.com\/antirez\/redis\/raw\/master\/TODO<\/a><h2><a name="Features added in past versions">Features added in past versions<\/a><\/h2><h2><a name="1.1 \/ 1.2">1.1 \/ 1.2<\/a><\/h2><ul><li> <a href="DataTypes.html">Ordered Set (ZSET)<\/a><\/li><li> <a href="MultiBulkCommands.html">Multibulk Commands<\/a><\/li><li> In memory integer encoding of <a href="DataTypes.html">integers<\/a>. Memory saving of 20% or more with datasets using high number of integer IDs. <\/li><li> Enhanced <a href="ExpireCommand.html">EXPIRE<\/a> algorithm.<\/li><\/ul>$/;"	a
Run the server	doc/QuickStart.html	/^<\/pre>In order to test if the Redis server is working well in your computer make sure to run <code name="code" class="python">make test<\/code> and check that all the tests are passed.<h2><a name="Run the server">Run the server<\/a><\/h2>Redis can run just fine without a configuration file (when executed without a config file a standard configuration is used). To run Redis just type the following command:<br\/><br\/><pre class="codeblock python python python python" name="code">$/;"	a
SADD _key_ _member_	doc/SaddCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SADD _key_ _member_">SADD _key_ _member_<\/a><\/h1>$/;"	a
SAVE	doc/SaveCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ControlCommandsSidebar.html">ControlCommandsSidebar<\/a><h3><a name="SAVE">SAVE<\/a><\/h3>$/;"	a
SCARD _key_	doc/ScardCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SCARD _key_">SCARD _key_<\/a><\/h1>$/;"	a
SDIFF _key1_ _key2_ ... _keyN_	doc/SdiffCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SDIFF _key1_ _key2_ ... _keyN_">SDIFF _key1_ _key2_ ... _keyN_<\/a><\/h1>$/;"	a
SDIFFSTORE _dstkey_ _key1_ _key2_ ... _keyN_	doc/SdiffstoreCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SDIFFSTORE _dstkey_ _key1_ _key2_ ... _keyN_">SDIFFSTORE _dstkey_ _key1_ _key2_ ... _keyN_<\/a><\/h1>$/;"	a
SDS_ABORT_ON_OOM	sds.c	31;"	d	file:
SELECT _index_	doc/SelectCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="SELECT _index_">SELECT _index_<\/a><\/h1>$/;"	a
SET _key_ _value_	doc/SetCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="SET _key_ _value_">SET _key_ _value_<\/a><\/h1>$/;"	a
SET with expire	doc/NonexistentCommands.html	/^<\/pre><h1><a name="SET with expire">SET with expire<\/a><\/h1>See <a href="SetexCommand.html">SETEX<\/a>.<h1><a name="ZADDNX">ZADDNX<\/a><\/h1>Add an element to a sorted set, only if the element doesn't already exist (by default, <a href="ZaddCommand.html">ZADD<\/a> would update the element's score if it already exists). <a href="http:\/\/groups.google.com\/group\/redis-db\/browse_thread\/thread\/fc4c79d72e5bd346\/6cdc07ecc36b81e7" target="_blank">See thread<\/a>.<br\/><br\/><pre class="codeblock python python" name="code">$/;"	a
SETEX _key_ _time_ _value_	doc/SetexCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="SETEX _key_ _time_ _value_">SETEX _key_ _time_ _value_<\/a><\/h1>$/;"	a
SETNX _key_ _value_	doc/SetnxCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="SETNX _key_ _value_">SETNX _key_ _value_<\/a><\/h1>$/;"	a
SET_ERRNO	lzf_d.c	40;"	d	file:
SET_ERRNO	lzf_d.c	43;"	d	file:
SHA1Final	sha1.c	/^void SHA1Final(unsigned char digest[20], SHA1_CTX* context)$/;"	f
SHA1HANDSOFF	sha1.c	22;"	d	file:
SHA1Init	sha1.c	/^void SHA1Init(SHA1_CTX* context)$/;"	f
SHA1Transform	sha1.c	/^void SHA1Transform(u_int32_t state[5], const unsigned char buffer[64])$/;"	f
SHA1Update	sha1.c	/^void SHA1Update(SHA1_CTX* context, const unsigned char* data, u_int32_t len)$/;"	f
SHA1_CTX	sha1.h	/^} SHA1_CTX;$/;"	t	typeref:struct:__anon8
SHIFT_ERROR	redis-check-dump.c	85;"	d	file:
SHUTDOWN	doc/ShutdownCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ControlCommandsSidebar.html">ControlCommandsSidebar<\/a><h1><a name="SHUTDOWN">SHUTDOWN<\/a><\/h1>$/;"	a
SINTER _key1_ _key2_ ... _keyN_	doc/SinterCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SINTER _key1_ _key2_ ... _keyN_">SINTER _key1_ _key2_ ... _keyN_<\/a><\/h1>$/;"	a
SINTERSTORE _dstkey_ _key1_ _key2_ ... _keyN_	doc/SinterstoreCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SINTERSTORE _dstkey_ _key1_ _key2_ ... _keyN_">SINTERSTORE _dstkey_ _key1_ _key2_ ... _keyN_<\/a><\/h1>$/;"	a
SISMEMBER _key_ _member_	doc/SismemberCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SISMEMBER _key_ _member_">SISMEMBER _key_ _member_<\/a><\/h1>$/;"	a
SLAVEOF _host_ _port_	doc/SlaveofCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="ControlCommandsSidebar.html">ControlCommandsSidebar<\/a><h1><a name="SLAVEOF _host_ _port_">SLAVEOF _host_ _port_<\/a><\/h1>$/;"	a
SLAVEOF no one	doc/SlaveofCommand.html	/^<h1><a name="SLAVEOF no one">SLAVEOF no one<\/a><\/h1><blockquote>The SLAVEOF command can change the replication settings of a slave on the fly.If a Redis server is arleady acting as slave, the command <code name="code" class="python">SLAVEOF NO ONE<\/code>will turn off the replicaiton turning the Redis server into a MASTER.In the proper form <code name="code" class="python">SLAVEOF hostname port<\/code> will make the server a slave of thespecific server listening at the specified hostname and port.<\/blockquote>$/;"	a
SMEMBERS _key_	doc/SmembersCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SMEMBERS _key_">SMEMBERS _key_<\/a><\/h1>$/;"	a
SMOVE _srckey_ _dstkey_ _member_	doc/SmoveCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SMOVE _srckey_ _dstkey_ _member_">SMOVE _srckey_ _dstkey_ _member_<\/a><\/h1>$/;"	a
SORT and Hashes: BY and GET by hash field	doc/SortCommand.html	/^<h2><a name="SORT and Hashes: BY and GET by hash field">SORT and Hashes: BY and GET by hash field<\/a><\/h2>$/;"	a
SPOP _key_	doc/SpopCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SPOP _key_">SPOP _key_<\/a><\/h1>$/;"	a
SRANDMEMBER _key_	doc/SrandmemberCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SRANDMEMBER _key_">SRANDMEMBER _key_<\/a><\/h1>$/;"	a
SREM _key_ _member_	doc/SremCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SREM _key_ _member_">SREM _key_ _member_<\/a><\/h1>$/;"	a
STANDALONE	lzfP.h	40;"	d
STRICT_ALIGN	lzfP.h	139;"	d
STRICT_ALIGN	lzfP.h	140;"	d
STRICT_ALIGN	lzfP.h	82;"	d
SUBSTR _key_ _start_ _end_	doc/SubstrCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="StringCommandsSidebar.html">StringCommandsSidebar<\/a><h1><a name="SUBSTR _key_ _start_ _end_">SUBSTR _key_ _start_ _end_<\/a><\/h1>$/;"	a
SUNION _key1_ _key2_ ... _keyN_	doc/SunionCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SUNION _key1_ _key2_ ... _keyN_">SUNION _key1_ _key2_ ... _keyN_<\/a><\/h1>$/;"	a
SUNIONSTORE _dstkey_ _key1_ _key2_ ... _keyN_	doc/SunionstoreCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SetCommandsSidebar.html">SetCommandsSidebar<\/a><h1><a name="SUNIONSTORE _dstkey_ _key1_ _key2_ ... _keyN_">SUNIONSTORE _dstkey_ _key1_ _key2_ ... _keyN_<\/a><\/h1>$/;"	a
SWAPINIT	pqsort.c	66;"	d	file:
See Also	doc/ConfigCommand.html	/^<h2><a name="See Also">See Also<\/a><\/h2>The <a href="InfoCommand.html">INFO<\/a> command can be used in order to read configuriaton parameters that are not available in the CONFIG command.$/;"	a
See also	doc/TypeCommand.html	/^<\/pre><h2><a name="See also">See also<\/a><\/h2>$/;"	a
Setting the timeout again on already volatile keys	doc/ExpireCommand.html	/^desync in your dataset.<h2><a name="Setting the timeout again on already volatile keys">Setting the timeout again on already volatile keys<\/a><\/h2><blockquote>Trying to call EXPIRE against a key that already has an associated timeoutwill not change the timeout of the key, but will just return 0. If insteadthe key does not have a timeout associated the timeout will be set and EXPIREwill return 1.<\/blockquote>$/;"	a
Simple INLINE commands	doc/ProtocolSpecification.html	/^terminated by &quot;\\r\\n&quot; (CRLF).<h2><a name="Simple INLINE commands">Simple INLINE commands<\/a><\/h2>The simplest commands are the inline commands. This is an example of a$/;"	a
Single line reply	doc/ProtocolSpecification.html	/^<\/pre><h2><a name="Single line reply">Single line reply<\/a><\/h2>As already seen a single line reply is in the form of a single line string$/;"	a
Solaris Support	doc/Redis_1_2_0_Changelog.html	/^<h2><a name="Solaris Support">Solaris Support<\/a><\/h2>Redis will now compile and work on Solaris without problems. Warning: the Solaris user base is very little, so Redis running on Solaris may not be as tested and stable as it is on  Linux and Mac OS X.<h2><a name="Support for the new generation protocol">Support for the new generation protocol<\/a><\/h2><ul><li> Redis is now able to accept commands in a new fully binary safe way: with the new protocol keys are binary safe, not only values, and there is no distinction between bulk commands and inline commands. This new protocol is currently used only for MSET and MSETNX but at some point it will hopefully replace the old one. See the Multi Bulk Commands section in the <a href="ProtocolSpecification.html">Redis Protocol Specification<\/a> for more information.<\/li><\/ul>$/;"	a
Sorted sets	doc/IntroductionToRedisDataTypes.html	/^<h2><a name="Sorted sets">Sorted sets<\/a><\/h2>Sets are a very handy data type, but... they are a bit too unsorted in order to fit well for a number of problems ;) This is why Redis 1.2 introduced Sorted Sets. They are very similar to Sets, collections of binary-safe strings, but this time with an associated score, and an operation similar to the List LRANGE operation to return items in order, but working against Sorted Sets, that is, the <a href="ZrangeCommand.html">ZRANGE<\/a> command.<br\/><br\/>Basically Sorted Sets are in some way the Redis equivalent of Indexes in the SQL world. For instance in our reddit.com example above there was no mention about how to generate the actual home page with news raked by user votes and time. We'll see how sorted sets can fix this problem, but it's better to start with something simpler, illustrating the basic working of this advanced data type. Let's add a few selected hackers with their year of birth as &quot;score&quot;.<br\/><br\/><pre class="codeblock python python python python python python python python python" name="code">$/;"	a
Sorting	doc/CommandReference.html	/^<h2><a name="Sorting">Sorting<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="SortCommand.html">SORT<\/a>  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <i>key<\/i> BY <i>pattern<\/i> LIMIT <i>start<\/i> <i>end<\/i> GET <i>pattern<\/i> ASC|DESC ALPHA  <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Sort a Set or a List accordingly to the specified parameters  <\/td><\/tr><\/table>$/;"	a
Sorting by external keys	doc/SortCommand.html	/^<h2><a name="Sorting by external keys">Sorting by external keys<\/a><\/h2><pre class="codeblock python python python python python" name="code">$/;"	a
Special keys	doc/TwitterAlikeExample.html	/^<\/pre>This has a lot of problems since if you add one server you need to move too much keys and so on, but this is the general idea even if you use a better hashing scheme like consistent hashing.<br\/><br\/>Ok, are key accesses distributed among the key space? Well, all the user data will be partitioned among different servers. There are no inter-keys operations used (like SINTER, otherwise you need to care that things you want to intersect will end in the same server. <b>This is why Redis unlike memcached does not force a specific hashing scheme, it's application specific<\/b>). Btw there are keys that are accessed more frequently.<h3><a name="Special keys">Special keys<\/a><\/h3>For example every time we post a new message, we <b>need<\/b> to increment the <code name="code" class="python">global:nextPostId<\/code> key. How to fix this problem? A Single server will get a lot if increments. The simplest way to handle this is to have a dedicated server just for increments. This is probably an overkill btw unless you have really a lot of traffic. There is another trick. The ID does not really need to be an incremental number, but just <b>it needs to be unique<\/b>. So you can get a random string long enough to be unlikely (almost impossible, if it's md5-size) to collide, and you are done. We successfully eliminated our main problem to make it really horizontally scalable!<br\/><br\/>There is another one: global:timeline. There is no fix for this, if you need to take something in order you can split among different servers and <b>then merge<\/b> when you need to get the data back, or take it ordered and use a single key. Again if you really have so much posts per second, you can use a single server just for this. Remember that with commodity hardware Redis is able to handle 100000 writes for second, that's enough even for Twitter, I guess.<br\/><br\/>Please feel free to use the comments below for questions and feedbacks.$/;"	a
Speed (ROUGH DRAFT)	doc/Speed.html	/^<h1><a name="Speed (ROUGH DRAFT)">Speed (ROUGH DRAFT)<\/a><\/h1><h2><a name="TODO">TODO<\/a><\/h2><ul><li> Written in ANSI C<\/li><li> Pipelining<\/li><li> MultiBulkCommands<\/li><li> epoll &gt;= 1.1<\/li><li> Benchmarks<\/li><\/ul>$/;"	a
Splitting data into multiple instances	doc/RedisBigData.html	/^<h2><a name="Splitting data into multiple instances">Splitting data into multiple instances<\/a><\/h2>$/;"	a
Stable code	doc/UnstableSource.html	/^The development version of Redis is <a href="http:\/\/github.com\/antirez\/redis\/tree\/master" target="_blank">hosted here at Github<\/a>, have fun cloning the source code with Git. If you are not familar with Git just use the <b>download<\/b> button to get a tarball.<h2><a name="Stable code">Stable code<\/a><\/h2>$/;"	a
Storing the result of a SORT operation	doc/SortCommand.html	/^<\/pre><h2><a name="Storing the result of a SORT operation">Storing the result of a SORT operation<\/a><\/h2><blockquote>By default SORT returns the sorted elements as its return value.Using the <b>STORE<\/b> option instead to return the elements SORT willstore this elements as a <a href="Lists.html">Redis List<\/a> in the specified key.An example:<\/blockquote>$/;"	a
Supported Languages (DRAFT)	doc/SupportedLanguages.html	/^                    <h1><a name="Supported Languages (DRAFT)">Supported Languages (DRAFT)<\/a><\/h1>Wondering if you can use Redis from your favorite language? Well here is the definitive guide to the available client libraries.<br\/><br\/>This libraries are intended to expose Redis commands, but you also have the option to use some higher level libraries that provide a <b><a href="ObjectHashMappers.html">Object Hash Mappings<\/a><\/b> pretty much the same idea implemented by a classic <b>ORM<\/b>.<h2><a name="TODO">TODO<\/a><\/h2><ul><li> Add <a href="http:\/\/github.com\/madsimian\/em-redis" target="_blank">http:\/\/github.com\/madsimian\/em-redis<\/a><\/li><li> Add <a href="http:\/\/github.com\/besquared\/redis-datastructures" target="_blank">http:\/\/github.com\/besquared\/redis-datastructures<\/a><\/li><li> Add <a href="http:\/\/github.com\/sma\/redis-node-client" target="_blank">http:\/\/github.com\/sma\/redis-node-client<\/a><\/li><\/ul>$/;"	a
Supported Platforms	doc/SupportedPlatforms.html	/^                    <h1><a name="Supported Platforms">Supported Platforms<\/a><\/h1>Redis can be compiled in most POSIX systems, but the development targets mainly:<br\/><br\/><ul><li> Linux<\/li><li> Mac OS X<\/li><li> FreeBSD<\/li><li> OpenBSD<\/li><li> Solaris (startting with <a href="RoadMap.html">Version 1.1<\/a>)<\/li><\/ul>$/;"	a
TTL _key_	doc/TtlCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="TTL _key_">TTL _key_<\/a><\/h1><blockquote>The TTL command returns the remaining time to live in seconds of a key that has an <a href="ExpireCommand.html">EXPIRE<\/a> set. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset. If the Key does not exists or does not have an associated expire, -1 is returned.<\/blockquote>$/;"	a
TYPE _key_	doc/TypeCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="TYPE _key_">TYPE _key_<\/a><\/h1>$/;"	a
Tcl	doc/SupportedLanguages.html	/^<h3><a name="Tcl">Tcl<\/a><\/h3><ul><li> The official version is included in the Redis tarball since it's maintained by Salvatore. <\/li><li> Author: <a href="http:\/\/invece.org\/" target="_blank">Salvatore Sanfilippo<\/a>, <a href="http:\/\/twitter.com\/antirez" target="_blank">@antirez<\/a><\/li><li> Repository: <a href="http:\/\/github.com\/antirez\/redis\/blob\/master\/redis.tcl" target="_blank">http:\/\/github.com\/antirez\/redis\/blob\/master\/redis.tcl<\/a><\/li><\/ul>$/;"	a
The DISCARD command	doc/MultiExecCommand.html	/^at all.<h2><a name="The DISCARD command">The DISCARD command<\/a><\/h2>DISCARD can be used in order to abort a transaction. No command will be$/;"	a
The List type	doc/IntroductionToRedisDataTypes.html	/^<\/pre>The <a href="IncrCommand.html">INCR<\/a> command parses the string value as an integer, increments it by one, and finally sets the obtained value as the new string value. There are other similar commands like <a href="IncrCommand.html">INCRBY<\/a>, <a href="IncrCommand.html">DECR<\/a> and <a href="IncrCommand.html">DECRBY<\/a>. Actually internally it's always the same command, acting in a slightly different way.<br\/><br\/>What means that INCR is atomic? That even multiple clients issuing INCR against the same key will never incur into a race condition. For instance it can't never happen that client 1 read &quot;10&quot;, client 2 read &quot;10&quot; at the same time, both increment to 11, and set the new value of 11. The final value will always be of 12 ad the read-increment-set operation is performed while all the other clients are not executing a command at the same time.<br\/><br\/>Another interesting operation on string is the <a href="GetsetCommand.html">GETSET<\/a> command, that does just what its name suggests: Set a key to a new value, returning the old value, as result. Why this is useful? Example: you have a system that increments a Redis key using the <a href="IncrCommand.html">INCR<\/a> command every time your web site receives a new visit. You want to collect this information one time every hour, without loosing a single key. You can GETSET the key assigning it the new value of &quot;0&quot; and reading the old value back.<h2><a name="The List type">The List type<\/a><\/h2>To explain the List data type it's better to start with a little of theory, as the term <b>List<\/b> is often used in an improper way by information technology folks. For instance &quot;Python Lists&quot; are not what the name may suggest (Linked Lists), but them are actually Arrays (the same data type is called Array in Ruby actually).<br\/><br\/>From a very general point of view a List is just a sequence of ordered elements: 10,20,1,2,3 is a list, but when a list of items is implemented using an Array and when instead a <b>Linked List<\/b> is used for the implementation, the properties change a lot.<br\/><br\/>Redis lists are implemented via Linked Lists, this means that even if you have million of elements inside a list, the operation of adding a new element in the head or in the tail of the list is performed <b>in constant time<\/b>. Adding a new element with the <a href="LpushCommand.html">LPUSH<\/a> command to the head of a ten elements list is the same speed as adding an element to the head of a 10 million elements list.<br\/><br\/>What's the downside? That accessing an element <b>by index<\/b> is very fast in lists implemented with an Array and not so fast in lists implemented by linked lists.<br\/><br\/>Redis Lists are implemented with linked lists because for a database system is crucial to be able to add elements to a very long list in a very fast way. Another strong advantage is, as you'll see in a moment, that Redis Lists can be taken at constant length in constant time.<h3><a name="First steps with Redis lists">First steps with Redis lists<\/a><\/h3>The <a href="RpushCommand.html">LPUSH<\/a> command add a new element into a list, on the left (on head), while the <a href="RpushCommand.html">RPUSH<\/a> command add a new element into alist, ot the right (on tail). Finally the <a href="LrangeCommand.html">LRANGE<\/a> command extract ranges of elements from lists:<br\/><br\/><pre class="codeblock python python python" name="code">$/;"	a
The Swap File	doc/VirtualMemorySpecification.html	/^As you can see if the VM system is not enabled we allocate just <code name="code" class="python">sizeof(*o)-sizeof(struct redisObjectVM)<\/code> of memory. Given that the <i>vm<\/i> field is the last in the object structure, and that this fields are never accessed if VM is disabled, we are safe and Redis without VM does not pay the memory overhead.<h2><a name="The Swap File">The Swap File<\/a><\/h2>$/;"	a
The meaning of the count of subscriptions with pattern matching	doc/PublishSubscribe.html	/^<h2><a name="The meaning of the count of subscriptions with pattern matching">The meaning of the count of subscriptions with pattern matching<\/a><\/h2>$/;"	a
The problem with the blocking VM	doc/VirtualMemorySpecification.html	/^<h2><a name="The problem with the blocking VM">The problem with the blocking VM<\/a><\/h2>$/;"	a
The set data type	doc/TwitterAlikeExample.html	/^<h3><a name="The set data type">The set data type<\/a><\/h3>$/;"	a
The string type	doc/IntroductionToRedisDataTypes.html	/^<h2><a name="The string type">The string type<\/a><\/h2>This is the simplest Redis type. If you use only this type, Redis will be something like a memcached server with persistence.<br\/><br\/>Let's play a bit with the string type:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
The vm-max-memory setting	doc/VirtualMemoryUserGuide.html	/^<\/pre>Many other configuration options are able to change the behavior of VM. The rule is that you don't want to run with the default configuration, as every problem and dataset requires some tuning in order to get the maximum advantages.<h2><a name="The vm-max-memory setting">The vm-max-memory setting<\/a><\/h2>The <b>vm-max-memory<\/b> setting specifies how much memory Redis is free to use before starting swapping values on disk.<br\/><br\/>Basically if this memory limit is still not reached, no object will be swapped, Redis will work all in memory as usually. Once this limit is hit, enough objects are swapped out in order to return just under the limit.<br\/><br\/>The swapped objects are the one with the highest &quot;age&quot; (that is, the number of seconds since they are not used in any way) mainly, but the &quot;swappability&quot; of an object is also proportional to the logarithm of it's size in memory. So basically older objects are preferred, but when they are about the same size, bigger objects are preferred.<br\/><br\/><b>WARNING:<\/b> Because keys can't be swapped out, Redis will not be able to honour the <b>vm-max-memory<\/b> setting if the keys alone are using more space than the limit.<br\/><br\/>The best value for this setting is enough RAM in order to hold the &quot;working set&quot; of data. In practical terms, just give Redis as much memory as you can, and swapping will work better.<h2><a name="Configuring the swap file">Configuring the swap file<\/a><\/h2>In order to transfer data from memory to disk, Redis uses a swap file. The swap file has nothing to do with durability of data, and can be removed when a Redis instance is terminated. Still the swap file should not be moved, deleted, or altered in any other way while Redis is running.<br\/><br\/>Because the Redis swap file is used mostly in a random access fashion, to put the swap file into a Solid State Disk will lead to better performances.<br\/><br\/>The swap file is divided into &quot;pages&quot;. A value can be swapped into one or multiple pages, but a single page can't hold more than a value.<br\/><br\/>There is no direct way to tell Redis how much bytes of swap file it should be using. Instead two different values are configured, that multiplied together will produce the total number of bytes used. This two values are the number of pages inside the swap file, and the page size. It is possible to configure this two parameters in redis.conf.<br\/><br\/><ul><li> The <b>vm-pages<\/b> configuration directive is used to set the total number of pages in the swap file.<\/li><li> the <b>vm-page-size<\/b> configuration directive is used in order to set the page size in bytes.<\/li><\/ul>$/;"	a
Threaded VM	doc/VirtualMemorySpecification.html	/^<h2><a name="Threaded VM">Threaded VM<\/a><\/h2>$/;"	a
Threaded VM vs Blocking VM	doc/VirtualMemoryUserGuide.html	/^Usually the best idea is setting the page size so that the majority of the values can be swapped using a few pages.<h2><a name="Threaded VM vs Blocking VM">Threaded VM vs Blocking VM<\/a><\/h2>Another very important configuration parameter is <b>vm-max-threads<\/b>:<br\/><br\/><pre class="codeblock python python" name="code">$/;"	a
Tokyo Cabinet / Toyo Tyrant	doc/Comparisons.html	/^<h2><a name="Tokyo Cabinet \/ Toyo Tyrant">Tokyo Cabinet \/ Toyo Tyrant<\/a><\/h2>Redis and Tokyo Cabinet can be used for the same applications, but actually they are <i>very different<\/i> beasts. If you read Twitter messages of people involved in scalable things both products are reported to work well, but surely there are times where one or the other can be the best choice.<br\/><br\/><ul><li> Tokyo Cabinet writes synchronously on disk, Redis takes the whole dataset on memory and writes on disk asynchronously. Tokyo Cabinet is safer and probably a better idea if your dataset is going to be bigger than RAM, but Redis is faster (note that Redis supports master-slave replication that is trivial to setup, so you are safe anyway if you want a setup where data can't be lost even after a disaster). <\/li><\/ul>$/;"	a
Transactions	doc/CommandReference.html	/^<h2><a name="Transactions">Transactions<\/a><\/h2><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Command<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Parameters<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Description<\/b> <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> <a href="MultiExecCommand.html">MULTI\/EXEC\/DISCARD\/WATCH\/UNWATCH<\/a> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> - <\/td><td style="border: 1px solid #aaa; padding: 5px;">  Redis atomic transactions  <\/td><\/tr><\/table>$/;"	a
Transfering objects from memory to swap	doc/VirtualMemorySpecification.html	/^Redis takes a &quot;bitmap&quot; (an contiguous array of bits set to zero or one) in memory, every bit represent a page of the swap file on disk: if a given bit is set to 1, it represents a page that is already used (there is some Redis Object stored there), while if the corresponding bit is zero, the page is free.<br\/><br\/>Taking this bitmap (that will call the page table) in memory is a huge win in terms of performances, and the memory used is small: we just need 1 bit for every page on disk. For instance in the example below 134217728 pages of 32 bytes each (4GB swap file) is using just 16 MB of RAM for the page table.<h2><a name="Transfering objects from memory to swap">Transfering objects from memory to swap<\/a><\/h2>$/;"	a
UDP Protocol	doc/UDP.html	/^                    &iuml;&raquo;&iquest;Revision 3.2, Salvatore Sanfilippo, 12 June 2010.<h1><a name="UDP Protocol">UDP Protocol<\/a><\/h1>The default and usually the preferred way for a client to chat with a Redis server is using the TCP protocol described in the <a href="ProtocolSpecification.html">Protocol Specification<\/a>. In some environments the trade off of switching to a less reliable and not feature complete protocol running over UDP in order to improve latency is a good idea, so starting from Redis 2.2 there is support for a binary UDP protocol.<br\/><br\/>Examples of environments where a low latency, high load, possibly less reliable Redis service is required are caching, data logging, real time games.<br\/><br\/>The UDP protocol supports all the <b>stateless<\/b> Redis commands, so commands like MULTI, EXEC, WATCH, SELECT, are not supported.<h2><a name="Higher level description of the protocol">Higher level description of the protocol<\/a><\/h2>The Redis UDP protocol is a request\/reply protocol with optional support for$/;"	a
ULTRA_FAST	lzfP.h	75;"	d
UNSUBSCRIBE (unsubscribe from all channels)	doc/PublishSubscribe.html	/^<h1><a name="UNSUBSCRIBE (unsubscribe from all channels)">UNSUBSCRIBE (unsubscribe from all channels)<\/a><\/h1>$/;"	a
UNSUBSCRIBE channel_1 channel_2 ... channel_N	doc/PublishSubscribe.html	/^<h1><a name="UNSUBSCRIBE channel_1 channel_2 ... channel_N">UNSUBSCRIBE channel_1 channel_2 ... channel_N<\/a><\/h1>$/;"	a
UNWATCH	doc/MultiExecCommand.html	/^<h1><a name="UNWATCH">UNWATCH<\/a><\/h1>$/;"	a
Unreliable operations	doc/UDP.html	/^amount of timed out replies.<br\/><br\/>There are two reasosn for a reply to be dropped due to congestion:<br\/><br\/>1) Redis is not able to transfer a reply because the socket output buffer is full, so the reply is discarded.<br\/><br\/>2) The input buffer of the UDP socket is full. When this happens the kernel will reply to the client with a &quot;port unreachable&quot; ICMP packet. This happens every time the server is not able to process the requests at the rate they arrive.<br\/><br\/>Clients may handle the second condition directly checking for ICMP errors reported in the socket, or simply checking the side effect that congestion causes, that is, an increment in the number of timed out replies.<h2><a name="Unreliable operations">Unreliable operations<\/a><\/h2>ACK request and ACK packets provide support to check if a given operation was processed or not. Still there are operations that are unreliable over UDP. In general all the &quot;remove and transfer&quot; operations like GETSET or RPOP are unreliable.<br\/><br\/>For instance RPOP will remove an element form a list, and will reply with this element. If the reply packet is lost, even if we can use ACK packets in order to discover if the operation was completed server side, there is no way to obtain the original list element transfered in the reply that got lost.<br\/><br\/>This operations should be used over UDP only when losing data is non critical for the application.<h2><a name="Example Packets">Example Packets<\/a><\/h2>An example request packet. The encoded command is <code name="code" class="python">GET mykey<\/code>.$/;"	a
Unsubscribing from all the channels at once	doc/PublishSubscribe.html	/^<blockquote>Messages are in the form of multi bulk replies with three elements.The first element is the kind of message:<\/blockquote><ul><li> &quot;subscribe&quot;: means that we successfully subscribed to the channel given as second element of the multi bulk reply. The third argument represents the number of channels we are currently subscribed to.<\/li><li> &quot;unsubscribe&quot;: means that we successfully unsubscribed from the channel given as second element of the multi bulk reply. The third argument represents the number of channels we are currently subscribed to. If this latest argument is zero, we are no longer subscribed to any channel, and the client can issue any kind of Redis command as we are outside the Pub\/sub state.<\/li><li> &quot;message&quot;: it is a message received as result of a PUBLISH command issued by another client. The second element is the name of the originating channel, and the third the actual message payload.<\/li><\/ul><h2><a name="Unsubscribing from all the channels at once">Unsubscribing from all the channels at once<\/a><\/h2>$/;"	a
Updates	doc/TwitterAlikeExample.html	/^<h2><a name="Updates">Updates<\/a><\/h2>$/;"	a
Usage	doc/MultiExecCommand.html	/^Since Redis 2.1.0, it's also possible to add a further guarantee to the above two, in the form of optimistic locking of a set of keys in a way very similar to a CAS (check and set) operation. This is documented later in this manual page.<h2><a name="Usage">Usage<\/a><\/h2>A Redis transaction is entered using the MULTI command. The command always$/;"	a
Using multiple cores	doc/RedisBigData.html	/^<h2><a name="Using multiple cores">Using multiple cores<\/a><\/h2>$/;"	a
VERY_FAST	lzfP.h	146;"	d
VERY_FAST	lzfP.h	64;"	d
VM Configuration	doc/VirtualMemoryUserGuide.html	/^An important concept to take in mind is that Redis <b>is not able to swap the keys<\/b>, so if your memory problems are related to the fact you have too much keys with very small values, VM is not the solution.<br\/><br\/>Instead if a good amount of memory is used because values are pretty large (for example large strings, lists, sets or hashes with many elements), then VM can be a good idea.<br\/><br\/>Sometimes you can turn your &quot;many keys with small values&quot; problem into a &quot;less keys but with very large values&quot; one just using Hashes in order to group related data into fields of a single key. For instance instead of having a key for every attribute of your object you have a single key per object where Hash fields represent the different attributes.<h1><a name="VM Configuration">VM Configuration<\/a><\/h1>Configuring the VM is not hard but requires some care to set the best parameters accordingly to the requirements.<br\/><br\/>The VM is enabled and configured editing redis.conf, the first step is switching it on with:<br\/><br\/><pre class="codeblock python" name="code">$/;"	a
Version 1.0	doc/ExpireCommand.html	/^<h3><a name="Version 1.0">Version 1.0<\/a><\/h3><blockquote>Each time a fixed number of keys where tested (100 by default). So ifyou had a client setting keys with a very short expire faster than 100for second the memory continued to grow. When you stopped to insertnew keys the memory started to be freed, 100 keys every second in thebest conditions. Under a peak Redis continues to use more and more RAMeven if most keys are expired in each sweep.<\/blockquote>$/;"	a
Version 1.0	doc/SupportedLanguages.html	/^<h3><a name="Version 1.0">Version 1.0<\/a><\/h3> <br\/><br\/>Compatible client libraries are expected to implement the following command sets:<br\/><br\/><ul><li> <b>String<\/b>: GET, SET, SETNX, DEL, EXISTS, INCR, DECR, MGET, INCRBY, DECRBY, GETSET, TYPE.<\/li><li> <b>List<\/b>: RPUSH, LPUSH, RPOP, LPOP, LLEN, LINDEX, LSET, LRANGE, LTRIM, LREM.<\/li><li> <b>Set<\/b>: SADD, SREM, SMOVE, SISMEMBER, SCARD, SPOP, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SMEMBERS.<\/li><li> <b>Keyspace<\/b>: KEYS, RANDOMKEY, RENAME, RENAMENX, DBSIZE, EXPIRE, TTL.<\/li><li> <b>Databases<\/b>: SELECT, MOVE, FLUSHDB, FLUSHALL.<\/li><li> <b>Sort<\/b>: SORT<\/li><li> <b>Connection<\/b>: AUTH, QUIT?. ???<\/li><li> <b>Persistence<\/b>: SAVE, BGSAVE, LASTSAVE, SHUTDOWN?. ???<\/li><li> <b>Server<\/b>: INFO, MONITOR? SLAVEOF? ???<\/li><\/ul><blockquote><\/blockquote><table><tr><td style="border: 1px solid #aaa; padding: 5px;"> <b>Language<\/b>    <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Name<\/b>              <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Sharding<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>Pipelining<\/b> <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>1.1<\/b>   <\/td><td style="border: 1px solid #aaa; padding: 5px;"> <b>1.0<\/b>      <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> ActionScript 3<\/td><td style="border: 1px solid #aaa; padding: 5px;"> as3redis            <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes     <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Clojure       <\/td><td style="border: 1px solid #aaa; padding: 5px;"> redis-clojure       <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Partial <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Common Lisp         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> CL-Redis            <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Erlang        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> erldis              <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Looks like   <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Looks like <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Go            <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Go-Redis            <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes     <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Haskell       <\/td><td style="border: 1px solid #aaa; padding: 5px;"> haskell-redis       <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Java          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> JDBC-Redis          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Java          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> JRedis              <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes     <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Java          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Jedis              <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes     <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> LUA           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> redis-lua           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes     <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Perl          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Redis Client        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Perl          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> AnyEvent::Redis     <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> PHP           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Redis PHP Bindings  <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> PHP           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> phpredis (C)        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> PHP           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Predis              <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes     <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> PHP           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Redisent            <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Python        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Python Client       <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Python        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> py-redis            <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Partial <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Python        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> txredis             <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Ruby          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> redis-rb            <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes          <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes     <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> Scala         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> scala-redis         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No      <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><tr><td style="border: 1px solid #aaa; padding: 5px;"> TCL           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> TCL                 <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No         <\/td><td style="border: 1px solid #aaa; padding: 5px;"> No           <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes     <\/td><td style="border: 1px solid #aaa; padding: 5px;"> Yes        <\/td><\/tr><\/table>$/;"	a
Version 1.1	doc/ExpireCommand.html	/^<h3><a name="Version 1.1">Version 1.1<\/a><\/h3><blockquote>Each time Redis:<\/blockquote>$/;"	a
Videos	doc/index.html	/^<h1><a name="Videos">Videos<\/a><\/h1><ul><li> <a href="http:\/\/mwrc2009.confreaks.com\/13-mar-2009-19-24-redis-key-value-nirvana-ezra-zygmuntowicz.html" target="_blank">watch the Ezra Zygmuntowicz talk about Redis<\/a> to know the most important Redis ideas in few minutes.<\/li><li> <a href="http:\/\/www.ustream.tv\/recorded\/7855635" target="_blank">Salvatore Sanfilippo and Pieter Noordhuis at the SF Redis Meetup<\/a><\/li><\/ul>$/;"	a
Virtual Memory User Guide	doc/VirtualMemoryUserGuide.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="RedisGuides.html">RedisGuides<\/a><h1><a name="Virtual Memory User Guide">Virtual Memory User Guide<\/a><\/h1>Redis Virtual Memory is a feature that will appear for the first time in a stable Redis distribution in Redis 2.0. However Virtual Memory (called VM starting from now) is already available and stable enough to be tests in the unstable branch of Redis available <a href="http:\/\/github.com\/antirez\/redis" target="_blank">on Git<\/a>.<h2><a name="Virtual Memory explained in simple words">Virtual Memory explained in simple words<\/a><\/h2>Redis follows a Key-Value model. You have keys associated with some values.$/;"	a
Virtual Memory technical specification	doc/VirtualMemorySpecification.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="RedisInternals.html">RedisInternals<\/a><h1><a name="Virtual Memory technical specification">Virtual Memory technical specification<\/a><\/h1>This document details the internals of the Redis Virtual Memory subsystem. The intended audience is not the final user but programmers willing to understand or modify the Virtual Memory implementation.<h2><a name="Keys vs Values: what is swapped out?">Keys vs Values: what is swapped out?<\/a><\/h2>$/;"	a
WATCH explained	doc/MultiExecCommand.html	/^multiple times.<h2><a name="WATCH explained">WATCH explained<\/a><\/h2>So what is WATCH really about? It is a command that will make the EXEC$/;"	a
WATCH key1 key2 ... keyN (Redis &gt;	doc/MultiExecCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="GenericCommandsSidebar.html">GenericCommandsSidebar<\/a><h1><a name="WATCH key1 key2 ... keyN (Redis &gt;">WATCH key1 key2 ... keyN (Redis &gt;<\/a><\/h1> 2.1.0)=$/;"	a
WATCH used to implement ZPOP	doc/MultiExecCommand.html	/^the connection can already be used freely for new transactions.<h2><a name="WATCH used to implement ZPOP">WATCH used to implement ZPOP<\/a><\/h2>A good example to illustrate how WATCH can be used to create new atomic$/;"	a
What values to swap when we are out of memory?	doc/VirtualMemorySpecification.html	/^<h2><a name="What values to swap when we are out of memory?">What values to swap when we are out of memory?<\/a><\/h2>$/;"	a
What's new in Redis 1.2	doc/Redis_1_2_0_Changelog.html	/^                    <h1><a name="What's new in Redis 1.2">What's new in Redis 1.2<\/a><\/h1><h2><a name="New persistence mode: Append Only File">New persistence mode: Append Only File<\/a><\/h2>The Append Only File is an alternative way to save your data in Redis that is fully durable! Unlike the snapshotting (default) persistence mode, where the database is saved asynchronously from time to time, the Append Only File saves every change ASAP in a text-only file that works like a journal. Redis will play back this file again at startup reloading the whole dataset back in memory. Redis Append Only File supports background Log compaction. For more info read the <a href="AppendOnlyFileHowto.html">Append Only File HOWTO<\/a>.<h2><a name="New data type: sorted sets">New data type: sorted sets<\/a><\/h2>Sorted sets are collections of elements (like Sets) with an associated score (in the form of a double precision floating point number). Elements in a sorted set are taken in order, so for instance to take the greatest element is an O(1) operation. Insertion and deletion is O(log(N)). Sorted sets are implemented using a dual ported data structure consisting of an hash table and a skip list. For more information please read the <a href="IntroductionToRedisDataTypes.html">Introduction To Redis Data Types<\/a>.<h2><a name="Specialized integer objects encoding">Specialized integer objects encoding<\/a><\/h2>Redis 1.2 will use less memory than Redis 1.0 for values in Strings, Lists or Sets elements that happen to be representable as 32 or 64 bit signed integers (it depends on your arch bits for the long C type). This is totally transparent form the point of view of the user, but will safe a lot of memory (30% less in datasets where there are many integers).<h2><a name="MSET and MSETNX">MSET and MSETNX<\/a><\/h2>That is, setting multiple keys in one command, atomically. For more information see the <a href="MsetCommand.html">MSET command<\/a> wiki page.<h2><a name="Better Performances">Better Performances<\/a><\/h2><ul><li> 100x times faster SAVE and BGSAVE! There was a problem in the LZF lib configuration that is now resolved. The effect is this impressive speedup. Also the saving child will no longer use 100% of CPU.<\/li><li> Glue output buffer and writev(). Many commands producing large outputs, like LRANGE, will now be even 10 times faster, thanks to the new output buffer gluing algorithm and the (optional) use of writev(2) syscall.<\/li><li> Support for epool and kqueue \/ kevent. 10,000 clients scalability.<\/li><li> Much better EXPIRE support, now it's possible to work with very large sets of keys expiring in very short time without to incur in memory problems (the new algorithm expires keys in an adaptive way, so will get more aggressive if there are a lot of expiring keys)<\/li><\/ul>$/;"	a
What's new in Redis 2.0.0	doc/Redis_2_0_0_Changelog.html	/^                    <h1><a name="What's new in Redis 2.0.0">What's new in Redis 2.0.0<\/a><\/h1><ul><li> Redis transactions: MULTI\/EXEC (antirez)<\/li><li> Blocking POP: BLPOP and BRPOP (antirez)<\/li><li> Virtual Memory (antirez with contributions from Pieter Noordhuis)<\/li><li> APPEND command (antirez)<\/li><li> WITHSCORES in ZRANGEBYSCORE thanks to Sam Hendley (antirez)<\/li><li> Much faster .rdb loading\/saving times (antirez)<\/li><li> Add DISCARD command to discard queued MULTI commands. (djanowski, antirez)<\/li><li> Interactive mode to redis-cli. (Michel Martens &amp; Damian Janowski)<\/li><li> Countless improvements to skip list implementation (Pieter Noordhuis)<\/li><li> ZINTERSTORE, ZUNIONSTORE commands (Pieter Noordhuis)<\/li><li> ZRANK command (Pieter Noordhuis)<\/li><li> SUBSTR command (antirez)<\/li><li> Now list push commands return the length of the new list (Gustavo Picon, antirez)<\/li><li> ZREMBYRANK command (Pieter Noordhuis)<\/li><li> Hash data type with all the associated commands (antirez &amp; Pieter Noordhuis)<\/li><li> Added ZREVRANK (Pieter Noordhuis)<\/li><li> Fixed hard to track replication bug (Jeremy Zawodny)<\/li><li> Tool to check rdb files for unprocessable opcodes (Pieter Noordhuis)<\/li><li> Random internals refactoring \/ cleanups (antirez &amp; Pieter Noordhuis)<\/li><li> Fixed issues 193, 194, 191 (Antonio Ognio)<\/li><li> Support for include directive in config parser (Jeremy Zawodny)<\/li><li> Fix authentication for redis-cli on non-interactive mode. (Michel Martens)<\/li><li> Added linenoise.c for zero deps line editing support. (antirez)<\/li><li> Use linenoise for line editing on redis-cli. (Michel Martens)<\/li><li> More incremental expiration of keys. (antirez)<\/li><li> CONFIG command (antirez)<\/li><li> Publis\/Subscribe and associated commands (antirez)<\/li><li> New form of shared object, sharing all the small integers (antirez)<\/li><li> Validate numeric inputs. (Alex McHale)<\/li><li> Non blocking hash table resize, thanks to Derek Collison and Pieter Noordhuis for design ideas and help. (antirez)<\/li><li> Enable hash dereference in SORT on BY and GET (Pieter Noordhuis)<\/li><li> Now all commands support binary safe keys (antirez)<\/li><li> SETEX (Set + EXPIRE) implemented (antirez &amp; Pieter Noordhuis)<\/li><li> redis-cli now accepts and outputs quoted strings in interactive mode (antirez)<\/li><li> New MONITOR output format with timestamp, 1 command per line. (antirez)<\/li><li> Tool to check if AOF is valid, and fix it if needed (Pieter Noordhuis)<\/li><li> Major speedup to AOF with fsync always, thanks to Derek Collison for the algorithm (antirez)<\/li><li> Append only filename configurable (Pieter Noordhuis)<\/li><li> Add SIGTERM shutdown handling. (Ashley Martens)<\/li><li> Many improvements in Redis test suite (Pieter Noordhuis)<\/li><li> Add git commit information to INFO listing (Pieter Noordhuis &amp; antirez)<\/li><li> Many more minor things mainly from me and Pieter Noordhuis, but this changelog is already too big ;)<\/li><\/ul>$/;"	a
When using Virtual Memory is a good idea	doc/VirtualMemoryUserGuide.html	/^Usually Redis takes both Keys and associated Values in memory. Sometimes this is not the best option, and while Keys <b>must<\/b> be taken in memory for the way Redis is designed (and in order to ensure fast lookups), Values can be swapped out to disk when they are rarely used.<br\/><br\/>In practical terms this means that if you have a dataset of 100,000 keys in memory, but only 10% of this keys are often used, Redis with Virtual Memory enabled will try to transfer the values associated to the rarely used keys on disk.<br\/><br\/>When this values are requested, as a result of a command issued by a client, the values are loaded back from the swap file to the main memory.<h2><a name="When using Virtual Memory is a good idea">When using Virtual Memory is a good idea<\/a><\/h2>Before using VM you should ask yourself if you really need it. Redis is a disk backed, in memory database. The right way to use Redis is almost always to have enough RAM to fit all the data in memory. Still there are a scenarios where to hold all the data in memory is not possible:$/;"	a
Why did you started the Redis project?	doc/FAQ.html	/^<h1><a name="Why did you started the Redis project?">Why did you started the Redis project?<\/a><\/h1>In order to scale <a href="http:\/\/lloogg.com" target="_blank">LLOOGG<\/a>. But after I got the basic server working I liked the idea to share the work with other guys, and Redis was turned into an open source project.$/;"	a
Wire protocol example	doc/PublishSubscribe.html	/^<h2><a name="Wire protocol example">Wire protocol example<\/a><\/h2>$/;"	a
ZADD _key_ _score_ _member_ (Redis &gt;	doc/ZaddCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SortedSetCommandsSidebar.html">SortedSetCommandsSidebar<\/a><h1><a name="ZADD _key_ _score_ _member_ (Redis &gt;">ZADD _key_ _score_ _member_ (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
ZCARD _key_ (Redis &gt;	doc/ZcardCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SortedSetCommandsSidebar.html">SortedSetCommandsSidebar<\/a><h1><a name="ZCARD _key_ (Redis &gt;">ZCARD _key_ (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
ZCOUNT _key_ _min_ _max_	doc/ZrangebyscoreCommand.html	/^<h1><a name="ZCOUNT _key_ _min_ _max_">ZCOUNT _key_ _min_ _max_<\/a><\/h1>$/;"	a
ZINCRBY _key_ _increment_ _member_ (Redis &gt;	doc/ZincrbyCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SortedSetCommandsSidebar.html">SortedSetCommandsSidebar<\/a><h1><a name="ZINCRBY _key_ _increment_ _member_ (Redis &gt;">ZINCRBY _key_ _increment_ _member_ (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
ZINTERSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;	doc/ZunionCommand.html	/^<h1><a name="ZINTERSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;">ZINTERSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;<\/a><\/h1> 1.3.12) =<br\/><br\/><i>Time complexity: O(N) + O(M log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set<\/i><blockquote>Creates a union or intersection of <i>N<\/i> sorted sets given by keys <i>k1<\/i> through <i>kN<\/i>, and stores it at <i>dstkey<\/i>. It is mandatory to provide the number of input keys <i>N<\/i>, before passing the input keys and the other (optional) arguments.<\/blockquote>$/;"	a
ZINTERSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;	doc/ZunionstoreCommand.html	/^<h1><a name="ZINTERSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;">ZINTERSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;<\/a><\/h1> 1.3.12) =$/;"	a
ZIPMAP_BIGLEN	zipmap.c	84;"	d	file:
ZIPMAP_END	zipmap.c	85;"	d	file:
ZIPMAP_LEN_BYTES	zipmap.c	94;"	d	file:
ZIPMAP_VALUE_MAX_FREE	zipmap.c	89;"	d	file:
ZRANGE _key_ _start_ _end_ `[`WITHSCORES`]`(Redis &gt;	doc/ZrangeCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SortedSetCommandsSidebar.html">SortedSetCommandsSidebar<\/a><h1><a name="ZRANGE _key_ _start_ _end_ `[`WITHSCORES`]`(Redis &gt;">ZRANGE _key_ _start_ _end_ `[`WITHSCORES`]`(Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
ZRANGEBYSCORE _key_ _min_ _max_ `[`LIMIT _offset_ _count_`]` (Redis &gt;	doc/ZrangebyscoreCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SortedSetCommandsSidebar.html">SortedSetCommandsSidebar<\/a><h1><a name="ZRANGEBYSCORE _key_ _min_ _max_ `[`LIMIT _offset_ _count_`]` (Redis &gt;">ZRANGEBYSCORE _key_ _min_ _max_ `[`LIMIT _offset_ _count_`]` (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
ZRANGEBYSCORE _key_ _min_ _max_ `[`LIMIT _offset_ _count_`]` `[`WITHSCORES`]` (Redis &gt;	doc/ZrangebyscoreCommand.html	/^<h1><a name="ZRANGEBYSCORE _key_ _min_ _max_ `[`LIMIT _offset_ _count_`]` `[`WITHSCORES`]` (Redis &gt;">ZRANGEBYSCORE _key_ _min_ _max_ `[`LIMIT _offset_ _count_`]` `[`WITHSCORES`]` (Redis &gt;<\/a><\/h1> 1.3.4) =$/;"	a
ZRANK _key_ _member_ (Redis &gt;	doc/ZrankCommand.html	/^<h1><a name="ZRANK _key_ _member_ (Redis &gt;">ZRANK _key_ _member_ (Redis &gt;<\/a><\/h1> 1.3.4) =$/;"	a
ZREM _key_ _member_ (Redis &gt;	doc/ZremCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SortedSetCommandsSidebar.html">SortedSetCommandsSidebar<\/a><h1><a name="ZREM _key_ _member_ (Redis &gt;">ZREM _key_ _member_ (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
ZREMRANGEBYRANK _key_ _start_ _end_ (Redis &gt;	doc/ZremrangebyrankCommand.html	/^<h1><a name="ZREMRANGEBYRANK _key_ _start_ _end_ (Redis &gt;">ZREMRANGEBYRANK _key_ _start_ _end_ (Redis &gt;<\/a><\/h1> 1.3.4) =$/;"	a
ZREMRANGEBYSCORE _key_ _min_ _max_ (Redis &gt;	doc/ZremrangebyscoreCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SortedSetCommandsSidebar.html">SortedSetCommandsSidebar<\/a><h1><a name="ZREMRANGEBYSCORE _key_ _min_ _max_ (Redis &gt;">ZREMRANGEBYSCORE _key_ _min_ _max_ (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
ZREVRANGE _key_ _start_ _end_ `[`WITHSCORES`]` (Redis &gt;	doc/ZrangeCommand.html	/^<h1><a name="ZREVRANGE _key_ _start_ _end_ `[`WITHSCORES`]` (Redis &gt;">ZREVRANGE _key_ _start_ _end_ `[`WITHSCORES`]` (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
ZREVRANK _key_ _member_ (Redis &gt;	doc/ZrankCommand.html	/^<h1><a name="ZREVRANK _key_ _member_ (Redis &gt;">ZREVRANK _key_ _member_ (Redis &gt;<\/a><\/h1> 1.3.4) =$/;"	a
ZSCORE _key_ _element_ (Redis &gt;	doc/ZscoreCommand.html	/^                    &iuml;&raquo;&iquest;#sidebar <a href="SortedSetCommandsSidebar.html">SortedSetCommandsSidebar<\/a><h1><a name="ZSCORE _key_ _element_ (Redis &gt;">ZSCORE _key_ _element_ (Redis &gt;<\/a><\/h1> 1.1) =$/;"	a
ZSKIPLIST_MAXLEVEL	redis.c	227;"	d	file:
ZSKIPLIST_P	redis.c	228;"	d	file:
ZUNIONSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;	doc/ZunionCommand.html	/^<h1><a name="ZUNIONSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;">ZUNIONSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;<\/a><\/h1> 1.3.12) =$/;"	a
ZUNIONSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;	doc/ZunionstoreCommand.html	/^<h1><a name="ZUNIONSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;">ZUNIONSTORE _dstkey_ _N_ _k1_ ... _kN_ `[`WEIGHTS _w1_ ... _wN_`]` `[`AGGREGATE SUM|MIN|MAX`]`  (Redis &gt;<\/a><\/h1> 1.3.12) =$/;"	a
_BSD_SOURCE	fmacros.h	4;"	d
_FILE_OFFSET_BITS	fmacros.h	13;"	d
_LARGEFILE_SOURCE	fmacros.h	12;"	d
_REDIS_FMACRO_H	fmacros.h	2;"	d
_XOPEN_SOURCE	fmacros.h	7;"	d
_XOPEN_SOURCE	fmacros.h	9;"	d
_ZIPMAP_H	zipmap.h	36;"	d
_ZMALLOC_H	zmalloc.h	32;"	d
__ADLIST_H__	adlist.h	32;"	d
__AE_H__	ae.h	34;"	d
__CONFIG_H	config.h	2;"	d
__DICT_H	dict.h	37;"	d
__LINENOISE_H	linenoise.h	35;"	d
__PQSORT_H	pqsort.h	9;"	d
__REDIS_H__	redis.h	31;"	d
__SDS_H	sds.h	32;"	d
__linux__	config.h	4;"	d
_client	redis-benchmark.c	/^typedef struct _client {$/;"	s	file:
_dictAlloc	dict.c	/^static void *_dictAlloc(size_t size)$/;"	f	file:
_dictClear	dict.c	/^int _dictClear(dict *d, dictht *ht)$/;"	f
_dictExpandIfNeeded	dict.c	/^static int _dictExpandIfNeeded(dict *d)$/;"	f	file:
_dictFree	dict.c	/^static void _dictFree(void *ptr) {$/;"	f	file:
_dictInit	dict.c	/^int _dictInit(dict *d, dictType *type,$/;"	f
_dictKeyIndex	dict.c	/^static int _dictKeyIndex(dict *d, const void *key)$/;"	f	file:
_dictNextPower	dict.c	/^static unsigned long _dictNextPower(unsigned long size)$/;"	f	file:
_dictPanic	dict.c	/^static void _dictPanic(const char *fmt, ...)$/;"	f	file:
_dictPrintStatsHt	dict.c	/^static void _dictPrintStatsHt(dictht *ht) {$/;"	f	file:
_dictRehashStep	dict.c	/^static void _dictRehashStep(dict *d) {$/;"	f	file:
_dictReset	dict.c	/^static void _dictReset(dictht *ht)$/;"	f	file:
_dictStringCopyHTHashFunction	dict.c	/^static unsigned int _dictStringCopyHTHashFunction(const void *key)$/;"	f	file:
_dictStringCopyHTKeyCompare	dict.c	/^static int _dictStringCopyHTKeyCompare(void *privdata, const void *key1,$/;"	f	file:
_dictStringCopyHTKeyDestructor	dict.c	/^static void _dictStringCopyHTKeyDestructor(void *privdata, void *key)$/;"	f	file:
_dictStringCopyHTKeyDup	dict.c	/^static void *_dictStringCopyHTKeyDup(void *privdata, const void *key)$/;"	f	file:
_dictStringKeyValCopyHTValDestructor	dict.c	/^static void _dictStringKeyValCopyHTValDestructor(void *privdata, void *val)$/;"	f	file:
_dictStringKeyValCopyHTValDup	dict.c	/^static void *_dictStringKeyValCopyHTValDup(void *privdata, const void *val)$/;"	f	file:
_pqsort	pqsort.c	/^_pqsort(void *a, size_t n, size_t es,$/;"	f	file:
_redisAssert	redis.c	/^static void _redisAssert(char *estr, char *file, int line) {$/;"	f	file:
_redisPanic	redis.c	/^static void _redisPanic(char *msg, char *file, int line) {$/;"	f	file:
_redisSortObject	redis.c	/^typedef struct _redisSortObject {$/;"	s	file:
_redisSortOperation	redis.c	/^typedef struct _redisSortOperation {$/;"	s	file:
_rfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
_wfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
acceptHandler	redis.c	/^static void acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
activerehashing	redis.c	/^    int activerehashing;$/;"	m	struct:redisServer	file:
addReply	redis.c	/^static void addReply(redisClient *c, robj *obj) {$/;"	f	file:
addReplyBulk	redis.c	/^static void addReplyBulk(redisClient *c, robj *obj) {$/;"	f	file:
addReplyBulkCString	redis.c	/^static void addReplyBulkCString(redisClient *c, char *s) {$/;"	f	file:
addReplyBulkLen	redis.c	/^static void addReplyBulkLen(redisClient *c, robj *obj) {$/;"	f	file:
addReplyDouble	redis.c	/^static void addReplyDouble(redisClient *c, double d) {$/;"	f	file:
addReplyLongLong	redis.c	/^static void addReplyLongLong(redisClient *c, long long ll) {$/;"	f	file:
addReplySds	redis.c	/^static void addReplySds(redisClient *c, sds s) {$/;"	f	file:
addReplyUlong	redis.c	/^static void addReplyUlong(redisClient *c, unsigned long ul) {$/;"	f	file:
aeAddMillisecondsToNow	ae.c	/^static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {$/;"	f	file:
aeApiAddEvent	ae_epoll.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	ae_kqueue.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	ae_select.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiCreate	ae_epoll.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	ae_kqueue.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	ae_select.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiDelEvent	ae_epoll.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {$/;"	f	file:
aeApiDelEvent	ae_kqueue.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	ae_select.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiFree	ae_epoll.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	ae_kqueue.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	ae_select.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiName	ae_epoll.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	ae_kqueue.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	ae_select.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiPoll	ae_epoll.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	ae_kqueue.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	ae_select.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiState	ae_epoll.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_epoll.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_kqueue.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_kqueue.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_select.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_select.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeBeforeSleepProc	ae.h	/^typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);$/;"	t
aeCreateEventLoop	ae.c	/^aeEventLoop *aeCreateEventLoop(void) {$/;"	f
aeCreateEventLoop	doc/RedisEventLibrary.html	/^<\/pre><h3><a name="aeCreateEventLoop">aeCreateEventLoop<\/a><\/h3><code name="code" class="python">aeCreateEventLoop<\/code> first mallocs aeEventLoop structure then calls ae_epoll.c:aeApiCreate<code name="code" class="python">.$/;"	a
aeCreateFileEvent	ae.c	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	f
aeCreateFileEvent	doc/RedisEventLibrary.html	/^<\/pre><code name="code" class="python">redis.c:serverCron<\/code> performs many operations that helps keep Redis running properly.<h3><a name="aeCreateFileEvent">aeCreateFileEvent<\/a><\/h3>The essence of <code name="code" class="python">aeCreateFileEvent<\/code> function is to execute <a href="http:\/\/man.cx\/epoll_ctl" target="_blank">epoll_ctl<\/a> system call which adds a watch for <code name="code" class="python">EPOLLIN<\/code> event on the <i>listening descriptor<\/i> create by <code name="code" class="python">anetTcpServer<\/code> and associate it with the epoll descriptor created by a call to <code name="code" class="python">aeCreateEventLoop<\/code>. <br\/><br\/>Following is an explanation of what precisely <code name="code" class="python">aeCreateFileEvent<\/code> does when called from <code name="code" class="python">redis.c:initServer<\/code>.<br\/><br\/><code name="code" class="python">initServer<\/code> passes the following arguments to <code name="code" class="python">aeCreateFileEvent<\/code>:$/;"	a
aeCreateTimeEvent	ae.c	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	f
aeCreateTimeEvent	doc/RedisEventLibrary.html	/^Next is 'ae.c:aeCreateTimeEvent<\/code>. But before that <code name="code" class="python">initServer<\/code> call <code name="code" class="python">anet.c:anetTcpServer<\/code> that creates and returns a <i>listening descriptor<\/i>. The descriptor is listens to <b>port 6379<\/b> by default. The returned  <i>listening descriptor<\/i> is stored in <code name="code" class="python">server.fd<\/code> field.<h3><a name="aeCreateTimeEvent">aeCreateTimeEvent<\/a><\/h3><code name="code" class="python">aeCreateTimeEvent<\/code> accepts the following as parameters:<br\/><br\/><ul><li> eventLoop: This is <code name="code" class="python">server.el<\/code> in <b>redis.c<\/b><\/li><li> milliseconds: The number of milliseconds from the curent time after which the timer expires.<\/li><li> proc: Function pointer. Stores the address of the function that has to be called after the timer expires.<\/li><li> clientData: Mostly NULL.<\/li><li> finalizerProc: Pointer to the function that has to be called before the timed event is removed from the list of timed events.<\/li><\/ul>$/;"	a
aeDeleteEventLoop	ae.c	/^void aeDeleteEventLoop(aeEventLoop *eventLoop) {$/;"	f
aeDeleteFileEvent	ae.c	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)$/;"	f
aeDeleteTimeEvent	ae.c	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)$/;"	f
aeEventFinalizerProc	ae.h	/^typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);$/;"	t
aeEventLoop	ae.h	/^typedef struct aeEventLoop {$/;"	s
aeEventLoop	ae.h	/^} aeEventLoop;$/;"	t	typeref:struct:aeEventLoop
aeFileEvent	ae.h	/^typedef struct aeFileEvent {$/;"	s
aeFileEvent	ae.h	/^} aeFileEvent;$/;"	t	typeref:struct:aeFileEvent
aeFileProc	ae.h	/^typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);$/;"	t
aeFiredEvent	ae.h	/^typedef struct aeFiredEvent {$/;"	s
aeFiredEvent	ae.h	/^} aeFiredEvent;$/;"	t	typeref:struct:aeFiredEvent
aeGetApiName	ae.c	/^char *aeGetApiName(void) {$/;"	f
aeGetTime	ae.c	/^static void aeGetTime(long *seconds, long *milliseconds)$/;"	f	file:
aeMain	ae.c	/^void aeMain(aeEventLoop *eventLoop) {$/;"	f
aeProcessEvents	ae.c	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags)$/;"	f
aeSearchNearestTimer	ae.c	/^static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)$/;"	f	file:
aeSetBeforeSleepProc	ae.c	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {$/;"	f
aeStop	ae.c	/^void aeStop(aeEventLoop *eventLoop) {$/;"	f
aeTimeEvent	ae.h	/^typedef struct aeTimeEvent {$/;"	s
aeTimeEvent	ae.h	/^} aeTimeEvent;$/;"	t	typeref:struct:aeTimeEvent
aeTimeProc	ae.h	/^typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);$/;"	t
aeWait	ae.c	/^int aeWait(int fd, int mask, long long milliseconds) {$/;"	f
anetAccept	anet.c	/^int anetAccept(char *err, int serversock, char *ip, int *port)$/;"	f
anetNonBlock	anet.c	/^int anetNonBlock(char *err, int fd)$/;"	f
anetRead	anet.c	/^int anetRead(int fd, char *buf, int count)$/;"	f
anetResolve	anet.c	/^int anetResolve(char *err, char *host, char *ipbuf)$/;"	f
anetSetError	anet.c	/^static void anetSetError(char *err, const char *fmt, ...)$/;"	f	file:
anetSetSendBuffer	anet.c	/^int anetSetSendBuffer(char *err, int fd, int buffsize)$/;"	f
anetTcpConnect	anet.c	/^int anetTcpConnect(char *err, char *addr, int port)$/;"	f
anetTcpGenericConnect	anet.c	/^static int anetTcpGenericConnect(char *err, char *addr, int port, int flags)$/;"	f	file:
anetTcpKeepAlive	anet.c	/^int anetTcpKeepAlive(char *err, int fd)$/;"	f
anetTcpNoDelay	anet.c	/^int anetTcpNoDelay(char *err, int fd)$/;"	f
anetTcpNonBlockConnect	anet.c	/^int anetTcpNonBlockConnect(char *err, char *addr, int port)$/;"	f
anetTcpServer	anet.c	/^int anetTcpServer(char *err, int port, char *bindaddr)$/;"	f
anetWrite	anet.c	/^int anetWrite(int fd, char *buf, int count)$/;"	f
aofRemoveTempFile	redis.c	/^static void aofRemoveTempFile(pid_t childpid) {$/;"	f	file:
aof_fsync	config.h	42;"	d
aof_fsync	config.h	44;"	d
aofbuf	redis.c	/^    sds aofbuf;       \/* AOF buffer, written before entering the event loop *\/$/;"	m	struct:redisServer	file:
apidata	ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	struct:aeEventLoop
appendCommand	redis.c	/^static void appendCommand(redisClient *c) {$/;"	f	file:
appendServerSaveParams	redis.c	/^static void appendServerSaveParams(time_t seconds, int changes) {$/;"	f	file:
append_to_aof	tests/integration/aof.tcl	/^proc append_to_aof {str} {$/;"	p
appendfd	redis.c	/^    int appendfd;$/;"	m	struct:redisServer	file:
appendfilename	redis.c	/^    char *appendfilename;$/;"	m	struct:redisServer	file:
appendfsync	redis.c	/^    int appendfsync;$/;"	m	struct:redisServer	file:
appendonly	redis.c	/^    int appendonly;$/;"	m	struct:redisServer	file:
appendseldb	redis.c	/^    int appendseldb;$/;"	m	struct:redisServer	file:
argc	redis.c	/^    int argc, mbargc;$/;"	m	struct:redisClient	file:
argc	redis.c	/^    int argc;$/;"	m	struct:multiCmd	file:
argv	redis.c	/^    robj **argv, **mbargv;$/;"	m	struct:redisClient	file:
argv	redis.c	/^    robj **argv;$/;"	m	struct:multiCmd	file:
arity	redis.c	/^    int arity;$/;"	m	struct:redisCommand	file:
assert_encoding	tests/support/test.tcl	/^proc assert_encoding {enc key} {$/;"	p
assert_equal	tests/support/test.tcl	/^proc assert_equal {expected value} {$/;"	p
assert_error	tests/support/test.tcl	/^proc assert_error {pattern code} {$/;"	p
assert_match	tests/support/test.tcl	/^proc assert_match {pattern value} {$/;"	p
assert_type	tests/support/test.tcl	/^proc assert_type {type key} {$/;"	p
atexit_registered	linenoise.c	/^static int atexit_registered = 0; \/* register atexit just 1 time *\/$/;"	v	file:
atime	redis.c	/^    time_t atime;       \/* Last access time *\/$/;"	m	struct:redisObjectVM	file:
auth	redis-cli.c	/^    char *auth;$/;"	m	struct:config	file:
authCommand	redis.c	/^static void authCommand(redisClient *c) {$/;"	f	file:
authenticated	redis.c	/^    int authenticated;      \/* when requirepass is non-NULL *\/$/;"	m	struct:redisClient	file:
backgroundRewriteDoneHandler	redis.c	/^void backgroundRewriteDoneHandler(int statloc) {$/;"	f
backgroundSaveDoneHandler	redis.c	/^void backgroundSaveDoneHandler(int statloc) {$/;"	f
backward	redis.c	/^    struct zskiplistNode *backward;$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistNode	file:
beforeSleep	redis.c	/^static void beforeSleep(struct aeEventLoop *eventLoop) {$/;"	f	file:
beforesleep	ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	struct:aeEventLoop
bgrewriteaofCommand	redis.c	/^static void bgrewriteaofCommand(redisClient *c) {$/;"	f	file:
bgrewritebuf	redis.c	/^    sds bgrewritebuf; \/* buffer taken by parent during oppend only rewrite *\/$/;"	m	struct:redisServer	file:
bgrewritechildpid	redis.c	/^    pid_t bgrewritechildpid;$/;"	m	struct:redisServer	file:
bgsaveCommand	redis.c	/^static void bgsaveCommand(redisClient *c) {$/;"	f	file:
bgsavechildpid	redis.c	/^    pid_t bgsavechildpid;$/;"	m	struct:redisServer	file:
bindaddr	redis.c	/^    char *bindaddr;$/;"	m	struct:redisServer	file:
blk	sha1.c	93;"	d	file:
blk0	sha1.c	86;"	d	file:
blk0	sha1.c	89;"	d	file:
blockClientOnSwappedKeys	redis.c	/^static int blockClientOnSwappedKeys(redisClient *c, struct redisCommand *cmd) {$/;"	f	file:
blockForKeys	redis.c	/^static void blockForKeys(redisClient *c, robj **keys, int numkeys, time_t timeout) {$/;"	f	file:
blocking POP inside a MULTI/EXEC transaction	doc/BlpopCommand.html	/^<h2><a name="blocking POP inside a MULTI\/EXEC transaction">blocking POP inside a MULTI\/EXEC transaction<\/a><\/h2><blockquote>BLPOP and BRPOP can be used with pipelining (sending multiple commands and reading the replies in batch), but it does not make sense to use BLPOP or BRPOP inside a MULTI\/EXEC block (a Redis transaction).<\/blockquote>$/;"	a
blockingPopGenericCommand	redis.c	/^static void blockingPopGenericCommand(redisClient *c, int where) {$/;"	f	file:
blockingkeys	redis.c	/^    dict *blockingkeys;         \/* Keys with clients waiting for data (BLPOP) *\/$/;"	m	struct:redisDb	file:
blockingkeys	redis.c	/^    robj **blockingkeys;    \/* The key we are waiting to terminate a blocking$/;"	m	struct:redisClient	file:
blockingkeysnum	redis.c	/^    int blockingkeysnum;    \/* Number of blocking keys *\/$/;"	m	struct:redisClient	file:
blockingto	redis.c	/^    time_t blockingto;      \/* Blocking operation timeout. If UNIX current time$/;"	m	struct:redisClient	file:
blpopCommand	redis.c	/^static void blpopCommand(redisClient *c) {$/;"	f	file:
blpop_blocked_clients	redis.c	/^    unsigned int blpop_blocked_clients;$/;"	m	struct:redisServer	file:
brpopCommand	redis.c	/^static void brpopCommand(redisClient *c) {$/;"	f	file:
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr
buffer	sha1.h	/^    unsigned char buffer[64];$/;"	m	struct:__anon8
bulklen	redis.c	/^    int bulklen;            \/* bulk read len. -1 if not in bulk read mode *\/$/;"	m	struct:redisClient	file:
bytesToHuman	redis.c	/^static void bytesToHuman(char *s, unsigned long long n) {$/;"	f	file:
call	redis.c	/^static void call(redisClient *c, struct redisCommand *cmd) {$/;"	f	file:
canceled	redis.c	/^    int canceled; \/* True if this command was canceled by blocking side of VM *\/$/;"	m	struct:iojob	file:
catAppendOnlyExpireAtCommand	redis.c	/^static sds catAppendOnlyExpireAtCommand(sds buf, robj *key, robj *seconds) {$/;"	f	file:
catAppendOnlyGenericCommand	redis.c	/^static sds catAppendOnlyGenericCommand(sds buf, int argc, robj **argv) {$/;"	f	file:
changes	redis.c	/^    int changes;$/;"	m	struct:saveparam	file:
checkType	redis.c	/^static int checkType(redisClient *c, robj *o, int type) {$/;"	f	file:
check_valgrind_errors	tests/support/server.tcl	/^proc check_valgrind_errors stderr {$/;"	p
cleanup	tests/test_helper.tcl	/^proc cleanup {} {$/;"	p
cliConnect	redis-cli.c	/^static int cliConnect(int force) {$/;"	f	file:
cliReadBulkReply	redis-cli.c	/^static int cliReadBulkReply(int fd) {$/;"	f	file:
cliReadLine	redis-cli.c	/^static sds cliReadLine(int fd) {$/;"	f	file:
cliReadMultiBulkReply	redis-cli.c	/^static int cliReadMultiBulkReply(int fd) {$/;"	f	file:
cliReadReply	redis-cli.c	/^static int cliReadReply(int fd) {$/;"	f	file:
cliReadSingleLineReply	redis-cli.c	/^static int cliReadSingleLineReply(int fd, int quiet) {$/;"	f	file:
cliSendCommand	redis-cli.c	/^static int cliSendCommand(int argc, char **argv, int repeat) {$/;"	f	file:
client	redis-benchmark.c	/^} *client;$/;"	t	typeref:struct:_client	file:
client	redis.c	/^    redisClient *client;$/;"	m	struct:pubsubPattern	file:
clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeFileEvent
clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeTimeEvent
clientDone	redis-benchmark.c	/^static void clientDone(client c) {$/;"	f	file:
clients	redis-benchmark.c	/^    list *clients;$/;"	m	struct:config	file:
clients	redis.c	/^    list *clients;$/;"	m	struct:redisServer	file:
closeTimedoutClients	redis.c	/^static void closeTimedoutClients(void) {$/;"	f	file:
cmd	redis.c	/^    struct redisCommand *cmd;$/;"	m	struct:multiCmd	typeref:struct:multiCmd::redisCommand	file:
cmdTable	redis.c	/^static struct redisCommand cmdTable[] = {$/;"	v	typeref:struct:redisCommand	file:
cmpobj	redis.c	/^        robj *cmpobj;$/;"	m	union:_redisSortObject::__anon1	file:
colon	redis.c	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	file:
commands	redis.c	/^    multiCmd *commands;     \/* Array of MULTI commands *\/$/;"	m	struct:multiState	file:
compareStringObjects	redis.c	/^static int compareStringObjects(robj *a, robj *b) {$/;"	f	file:
computeDatasetDigest	redis.c	/^static void computeDatasetDigest(unsigned char *final) {$/;"	f	file:
computeObjectSwappability	redis.c	/^static double computeObjectSwappability(robj *o) {$/;"	f	file:
cone	redis.c	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	file:
config	redis-benchmark.c	/^static struct config {$/;"	s	file:
config	redis-benchmark.c	/^} config;$/;"	v	typeref:struct:config	file:
config	redis-cli.c	/^static struct config {$/;"	s	file:
config	redis-cli.c	/^} config;$/;"	v	typeref:struct:config	file:
configCommand	redis.c	/^static void configCommand(redisClient *c) {$/;"	f	file:
configGetCommand	redis.c	/^static void configGetCommand(redisClient *c) {$/;"	f	file:
configSetCommand	redis.c	/^static void configSetCommand(redisClient *c) {$/;"	f	file:
consumeNewline	redis-check-aof.c	/^int consumeNewline(char *buf) {$/;"	f
convertToRealHash	redis.c	/^static void convertToRealHash(robj *o) {$/;"	f	file:
convertToSds	redis-cli.c	/^static char **convertToSds(int count, char** args) {$/;"	f	file:
count	redis.c	/^    int count;              \/* Total number of MULTI commands *\/$/;"	m	struct:multiState	file:
count	sha1.h	/^    u_int32_t count[2];$/;"	m	struct:__anon8
createClient	redis-benchmark.c	/^static client createClient(void) {$/;"	f	file:
createClient	redis.c	/^static redisClient *createClient(int fd) {$/;"	f	file:
createComplexDataset	tests/support/util.tcl	/^proc createComplexDataset {r ops} {$/;"	p
createFakeClient	redis.c	/^static struct redisClient *createFakeClient(void) {$/;"	f	file:
createHashObject	redis.c	/^static robj *createHashObject(void) {$/;"	f	file:
createListObject	redis.c	/^static robj *createListObject(void) {$/;"	f	file:
createMissingClients	redis-benchmark.c	/^static void createMissingClients(client c) {$/;"	f	file:
createObject	redis.c	/^static robj *createObject(int type, void *ptr) {$/;"	f	file:
createSetObject	redis.c	/^static robj *createSetObject(void) {$/;"	f	file:
createSharedObjects	redis.c	/^static void createSharedObjects(void) {$/;"	f	file:
createSortOperation	redis.c	/^static redisSortOperation *createSortOperation(int type, robj *pattern) {$/;"	f	file:
createStringObject	redis.c	/^static robj *createStringObject(char *ptr, size_t len) {$/;"	f	file:
createStringObjectFromLongLong	redis.c	/^static robj *createStringObjectFromLongLong(long long value) {$/;"	f	file:
createZsetObject	redis.c	/^static robj *createZsetObject(void) {$/;"	f	file:
create_aof	tests/integration/aof.tcl	/^proc create_aof {code} {$/;"	p
create_list	tests/unit/type/list.tcl	/^    proc create_list {key entries} {$/;"	p
create_zset	tests/unit/type/zset.tcl	/^    proc create_zset {key items} {$/;"	p
crlf	redis.c	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	file:
cronloops	redis.c	/^    int cronloops;              \/* number of times the cron function run *\/$/;"	m	struct:redisServer	file:
czero	redis.c	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	file:
d	dict.h	/^    dict *d;$/;"	m	struct:dictIterator
daemonize	redis.c	/^    int daemonize;$/;"	m	struct:redisServer	file:
daemonize	redis.c	/^static void daemonize(void) {$/;"	f	file:
data	redis-check-dump.c	/^    void *data;$/;"	m	struct:__anon5	file:
datasize	redis-benchmark.c	/^    int datasize;$/;"	m	struct:config	file:
db	redis.c	/^    redisDb *db;$/;"	m	struct:redisClient	file:
db	redis.c	/^    redisDb *db;$/;"	m	struct:redisServer	file:
db	redis.c	/^    redisDb *db;\/* Redis database *\/$/;"	m	struct:iojob	file:
dbDictType	redis.c	/^static dictType dbDictType = {$/;"	v	file:
dbfilename	redis.c	/^    char *dbfilename;$/;"	m	struct:redisServer	file:
dbnum	redis-cli.c	/^    int dbnum;$/;"	m	struct:config	file:
dbnum	redis.c	/^    int dbnum;$/;"	m	struct:redisServer	file:
dbsizeCommand	redis.c	/^static void dbsizeCommand(redisClient *c) {$/;"	f	file:
de	redis.c	/^    dictEntry *de;$/;"	m	struct:__anon3	file:
debug	redis-benchmark.c	/^    int debug;$/;"	m	struct:config	file:
debugCommand	redis.c	/^static void debugCommand(redisClient *c) {$/;"	f	file:
decrCommand	redis.c	/^static void decrCommand(redisClient *c) {$/;"	f	file:
decrRefCount	redis.c	/^static void decrRefCount(void *obj) {$/;"	f	file:
decrbyCommand	redis.c	/^static void decrbyCommand(redisClient *c) {$/;"	f	file:
decrement_used_memory	zmalloc.c	55;"	d	file:
delCommand	redis.c	/^static void delCommand(redisClient *c) {$/;"	f	file:
deleteIfSwapped	redis.c	/^static int deleteIfSwapped(redisDb *db, robj *key) {$/;"	f	file:
deleteIfVolatile	redis.c	/^static int deleteIfVolatile(redisDb *db, robj *key) {$/;"	f	file:
deleteKey	redis.c	/^static int deleteKey(redisDb *db, robj *key) {$/;"	f	file:
devnull	redis.c	/^    FILE *devnull;$/;"	m	struct:redisServer	file:
di	redis.c	/^    dictIterator *di;$/;"	m	struct:__anon3	file:
dict	dict.h	/^typedef struct dict {$/;"	s
dict	dict.h	/^} dict;$/;"	t	typeref:struct:dict
dict	redis.c	/^    dict *dict;                 \/* The keyspace for this DB *\/$/;"	m	struct:redisDb	file:
dict	redis.c	/^    dict *dict;$/;"	m	struct:__anon2	file:
dict	redis.c	/^    dict *dict;$/;"	m	struct:zset	file:
dictAdd	dict.c	/^int dictAdd(dict *d, void *key, void *val)$/;"	f
dictCompareHashKeys	dict.h	110;"	d
dictCreate	dict.c	/^dict *dictCreate(dictType *type,$/;"	f
dictDelete	dict.c	/^int dictDelete(dict *ht, const void *key) {$/;"	f
dictDeleteNoFree	dict.c	/^int dictDeleteNoFree(dict *ht, const void *key) {$/;"	f
dictDisableResize	dict.c	/^void dictDisableResize(void) {$/;"	f
dictEmpty	dict.c	/^void dictEmpty(dict *d) {$/;"	f
dictEnableResize	dict.c	/^void dictEnableResize(void) {$/;"	f
dictEncObjHash	redis.c	/^static unsigned int dictEncObjHash(const void *key) {$/;"	f	file:
dictEncObjKeyCompare	redis.c	/^static int dictEncObjKeyCompare(void *privdata, const void *key1,$/;"	f	file:
dictEntry	dict.h	/^typedef struct dictEntry {$/;"	s
dictEntry	dict.h	/^} dictEntry;$/;"	t	typeref:struct:dictEntry
dictExpand	dict.c	/^int dictExpand(dict *d, unsigned long size)$/;"	f
dictFetchValue	dict.c	/^void *dictFetchValue(dict *d, const void *key) {$/;"	f
dictFind	dict.c	/^dictEntry *dictFind(dict *d, const void *key)$/;"	f
dictFreeEntryKey	dict.h	99;"	d
dictFreeEntryVal	dict.h	88;"	d
dictGenHashFunction	dict.c	/^unsigned int dictGenHashFunction(const unsigned char *buf, int len) {$/;"	f
dictGenericDelete	dict.c	/^static int dictGenericDelete(dict *d, const void *key, int nofree)$/;"	f	file:
dictGetEntryKey	dict.h	117;"	d
dictGetEntryVal	dict.h	118;"	d
dictGetIterator	dict.c	/^dictIterator *dictGetIterator(dict *d)$/;"	f
dictGetRandomKey	dict.c	/^dictEntry *dictGetRandomKey(dict *d)$/;"	f
dictHashKey	dict.h	115;"	d
dictIdentityHashFunction	dict.c	/^unsigned int dictIdentityHashFunction(unsigned int key)$/;"	f
dictIntHashFunction	dict.c	/^unsigned int dictIntHashFunction(unsigned int key)$/;"	f
dictIsRehashing	dict.h	121;"	d
dictIterator	dict.h	/^typedef struct dictIterator {$/;"	s
dictIterator	dict.h	/^} dictIterator;$/;"	t	typeref:struct:dictIterator
dictListDestructor	redis.c	/^static void dictListDestructor(void *privdata, void *val)$/;"	f	file:
dictNext	dict.c	/^dictEntry *dictNext(dictIterator *iter)$/;"	f
dictObjHash	redis.c	/^static unsigned int dictObjHash(const void *key) {$/;"	f	file:
dictObjKeyCompare	redis.c	/^static int dictObjKeyCompare(void *privdata, const void *key1,$/;"	f	file:
dictPrintStats	dict.c	/^void dictPrintStats(dict *d) {$/;"	f
dictRedisObjectDestructor	redis.c	/^static void dictRedisObjectDestructor(void *privdata, void *val)$/;"	f	file:
dictRehash	dict.c	/^int dictRehash(dict *d, int n) {$/;"	f
dictRehashMilliseconds	dict.c	/^int dictRehashMilliseconds(dict *d, int ms) {$/;"	f
dictRelease	dict.c	/^void dictRelease(dict *d)$/;"	f
dictReleaseIterator	dict.c	/^void dictReleaseIterator(dictIterator *iter)$/;"	f
dictReplace	dict.c	/^int dictReplace(dict *d, void *key, void *val)$/;"	f
dictResize	dict.c	/^int dictResize(dict *d)$/;"	f
dictSetHashKey	dict.h	103;"	d
dictSetHashVal	dict.h	92;"	d
dictSize	dict.h	120;"	d
dictSlots	dict.h	119;"	d
dictType	dict.h	/^typedef struct dictType {$/;"	s
dictType	dict.h	/^} dictType;$/;"	t	typeref:struct:dictType
dictTypeHeapStringCopyKey	dict.c	/^dictType dictTypeHeapStringCopyKey = {$/;"	v
dictTypeHeapStringCopyKeyValue	dict.c	/^dictType dictTypeHeapStringCopyKeyValue = {$/;"	v
dictTypeHeapStrings	dict.c	/^dictType dictTypeHeapStrings = {$/;"	v
dictVanillaFree	redis.c	/^static void dictVanillaFree(void *privdata, void *val)$/;"	f	file:
dict_can_resize	dict.c	/^static int dict_can_resize = 1;$/;"	v	file:
dict_force_resize_ratio	dict.c	/^static unsigned int dict_force_resize_ratio = 5;$/;"	v	file:
dictht	dict.h	/^typedef struct dictht {$/;"	s
dictht	dict.h	/^} dictht;$/;"	t	typeref:struct:dictht
dictid	redis.c	/^    int dictid;$/;"	m	struct:redisClient	file:
direction	adlist.h	/^    int direction;$/;"	m	struct:listIter
dirty	redis.c	/^    long long dirty;            \/* changes to DB from the last save *\/$/;"	m	struct:redisServer	file:
dirty_before_bgsave	redis.c	/^    long long dirty_before_bgsave; \/* used to restore dirty on failed BGSAVE *\/$/;"	m	struct:redisServer	file:
disableRawMode	linenoise.c	/^static void disableRawMode(int fd) {$/;"	f	file:
discardCommand	redis.c	/^static void discardCommand(redisClient *c) {$/;"	f	file:
dm-redis-adapter	doc/ObjectHashMappers.html	/^<h3><a name="dm-redis-adapter">dm-redis-adapter<\/a><\/h3><ul><li> This is a DataMapper (ORM that is based on the IdentityMap pattern) adapter for the Redis key-value database.<\/li><li> Author: <a href="http:\/\/whoahbot.com\/" target="_blank">Whoahbot<\/a>, <a href="http:\/\/twitter.com\/whoahbot" target="_blank">@whoahbot<\/a>.<\/li><li> Repository: <a href="http:\/\/github.com\/whoahbot\/dm-redis-adapter\/" target="_blank">http:\/\/github.com\/whoahbot\/dm-redis-adapter\/<\/a><\/li><\/ul>$/;"	a
donerequests	redis-benchmark.c	/^    int donerequests;$/;"	m	struct:config	file:
dontWaitForSwappedKey	redis.c	/^static int dontWaitForSwappedKey(redisClient *c, robj *key) {$/;"	f	file:
dup	adlist.h	/^    void *(*dup)(void *ptr);$/;"	m	struct:list
dupClientReplyValue	redis.c	/^static void *dupClientReplyValue(void *o) {$/;"	f	file:
dupStringObject	redis.c	/^static robj *dupStringObject(robj *o) {$/;"	f	file:
echoCommand	redis.c	/^static void echoCommand(redisClient *c) {$/;"	f	file:
el	redis-benchmark.c	/^    aeEventLoop *el;$/;"	m	struct:config	file:
el	redis.c	/^    aeEventLoop *el;$/;"	m	struct:redisServer	file:
emptyDb	redis.c	/^static long long emptyDb() {$/;"	f	file:
emptybulk	redis.c	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	file:
emptymultibulk	redis.c	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	file:
enableRawMode	linenoise.c	/^static int enableRawMode(int fd) {$/;"	f	file:
encoding	redis.c	/^    int encoding;$/;"	m	struct:__anon3	file:
encoding	redis.c	/^    unsigned char encoding;$/;"	m	struct:redisObject	file:
endBenchmark	redis-benchmark.c	/^static void endBenchmark(char *title) {$/;"	f	file:
entry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
entry	redis-check-dump.c	/^} entry;$/;"	t	typeref:struct:__anon7	file:
epfd	ae_epoll.c	/^    int epfd;$/;"	m	struct:aeApiState	file:
epos	redis-check-aof.c	/^static long epos;$/;"	v	file:
equalStringObjects	redis.c	/^static int equalStringObjects(robj *a, robj *b) {$/;"	f	file:
erldis (Erlang)	doc/SupportedLanguages.html	/^<h3><a name="erldis (Erlang)">erldis (Erlang)<\/a><\/h3><ul><li> Client protocol for redis key-value store.<\/li><li> Author: <a href="http:\/\/www.adroll.com\/" target="_blank">Valentino Volonghi<\/a>, <a href="http:\/\/twitter.com\/dialtone_" target="_blank">@dialtone_<\/a>.<\/li><li> Repository: <a href="http:\/\/bitbucket.org\/adroll\/erldis\/" target="_blank">http:\/\/bitbucket.org\/adroll\/erldis\/<\/a><\/li><\/ul>$/;"	a
err	redis.c	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	file:
error	redis-check-aof.c	/^static char error[1024];$/;"	v	file:
error	redis-check-dump.c	/^    char error[16][1024];$/;"	m	struct:__anon6	file:
error_and_quit	tests/support/server.tcl	/^proc error_and_quit {config_file error} {$/;"	p
errors	redis-check-dump.c	/^static errors_t errors;$/;"	v	file:
errors_t	redis-check-dump.c	/^} errors_t;$/;"	t	typeref:struct:__anon6	file:
events	ae.h	/^    aeFileEvent events[AE_SETSIZE]; \/* Registered events *\/$/;"	m	struct:aeEventLoop
events	ae_epoll.c	/^    struct epoll_event events[AE_SETSIZE];$/;"	m	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:
events	ae_kqueue.c	/^    struct kevent events[AE_SETSIZE];$/;"	m	struct:aeApiState	typeref:struct:aeApiState::kevent	file:
execBlockClientOnSwappedKeys	redis.c	/^static void execBlockClientOnSwappedKeys(redisClient *c, struct redisCommand *cmd, int argc, robj **argv) {$/;"	f	file:
execCommand	redis.c	/^static void execCommand(redisClient *c) {$/;"	f	file:
execCommandReplicateMulti	redis.c	/^static void execCommandReplicateMulti(redisClient *c) {$/;"	f	file:
execute_tests	tests/test_helper.tcl	/^proc execute_tests name {$/;"	p
existsCommand	redis.c	/^static void existsCommand(redisClient *c) {$/;"	f	file:
expect	lzf_c.c	79;"	d	file:
expect	lzf_c.c	82;"	d	file:
expect_false	lzf_c.c	86;"	d	file:
expect_true	lzf_c.c	87;"	d	file:
expireCommand	redis.c	/^static void expireCommand(redisClient *c) {$/;"	f	file:
expireGenericCommand	redis.c	/^static void expireGenericCommand(redisClient *c, robj *key, robj *param, long offset) {$/;"	f	file:
expireIfNeeded	redis.c	/^static int expireIfNeeded(redisDb *db, robj *key) {$/;"	f	file:
expireatCommand	redis.c	/^static void expireatCommand(redisClient *c) {$/;"	f	file:
expires	redis.c	/^    dict *expires;              \/* Timeout of keys with a timeout set *\/$/;"	m	struct:redisDb	file:
fd	ae.h	/^    int fd;$/;"	m	struct:aeFiredEvent
fd	redis-benchmark.c	/^    int fd;$/;"	m	struct:_client	file:
fd	redis.c	/^    int fd;$/;"	m	struct:redisClient	file:
fd	redis.c	/^    int fd;$/;"	m	struct:redisServer	file:
feedAppendOnlyFile	redis.c	/^static void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {$/;"	f	file:
finalizerProc	ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	struct:aeTimeEvent
findFuncName	redis.c	/^static char *findFuncName(void *pointer, unsigned long *offset){$/;"	f	file:
fired	ae.h	/^    aeFiredEvent fired[AE_SETSIZE]; \/* Fired events *\/$/;"	m	struct:aeEventLoop
flags	redis.c	/^    int flags;              \/* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... *\/$/;"	m	struct:redisClient	file:
flags	redis.c	/^    int flags;$/;"	m	struct:redisCommand	file:
flushAppendOnlyFile	redis.c	/^static void flushAppendOnlyFile(void) {$/;"	f	file:
flushallCommand	redis.c	/^static void flushallCommand(redisClient *c) {$/;"	f	file:
flushdbCommand	redis.c	/^static void flushdbCommand(redisClient *c) {$/;"	f	file:
formatCommand	tests/support/util.tcl	/^proc formatCommand {args} {$/;"	p
forward	redis.c	/^    struct zskiplistNode **forward;$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistNode	file:
free	adlist.h	/^    void (*free)(void *ptr);$/;"	m	struct:list
free	sds.h	/^    long free;$/;"	m	struct:sdshdr
freeAllClients	redis-benchmark.c	/^static void freeAllClients(void) {$/;"	f	file:
freeClient	redis-benchmark.c	/^static void freeClient(client c) {$/;"	f	file:
freeClient	redis.c	/^static void freeClient(redisClient *c) {$/;"	f	file:
freeClientArgv	redis.c	/^static void freeClientArgv(redisClient *c) {$/;"	f	file:
freeClientMultiState	redis.c	/^static void freeClientMultiState(redisClient *c) {$/;"	f	file:
freeFakeClient	redis.c	/^static void freeFakeClient(struct redisClient *c) {$/;"	f	file:
freeHashObject	redis.c	/^static void freeHashObject(robj *o) {$/;"	f	file:
freeHistory	linenoise.c	/^static void freeHistory(void) {$/;"	f	file:
freeIOJob	redis.c	/^static void freeIOJob(iojob *j) {$/;"	f	file:
freeListObject	redis.c	/^static void freeListObject(robj *o) {$/;"	f	file:
freeMemoryIfNeeded	redis.c	/^static void freeMemoryIfNeeded(void) {$/;"	f	file:
freePubsubPattern	redis.c	/^static void freePubsubPattern(void *p) {$/;"	f	file:
freeSetObject	redis.c	/^static void freeSetObject(robj *o) {$/;"	f	file:
freeStringObject	redis.c	/^static void freeStringObject(robj *o) {$/;"	f	file:
freeZsetObject	redis.c	/^static void freeZsetObject(robj *o) {$/;"	f	file:
fwriteBulkDouble	redis.c	/^static int fwriteBulkDouble(FILE *fp, double d) {$/;"	f	file:
fwriteBulkLong	redis.c	/^static int fwriteBulkLong(FILE *fp, long l) {$/;"	f	file:
fwriteBulkObject	redis.c	/^static int fwriteBulkObject(FILE *fp, robj *obj) {$/;"	f	file:
fwriteBulkString	redis.c	/^static int fwriteBulkString(FILE *fp, char *s, unsigned long len) {$/;"	f	file:
genRedisInfoString	redis.c	/^static sds genRedisInfoString(void) {$/;"	f	file:
genericHgetallCommand	redis.c	/^static void genericHgetallCommand(redisClient *c, int flags) {$/;"	f	file:
genericZrangebyscoreCommand	redis.c	/^static void genericZrangebyscoreCommand(redisClient *c, int justcount) {$/;"	f	file:
getColumns	linenoise.c	/^static int getColumns(void) {$/;"	f	file:
getCommand	redis.c	/^static void getCommand(redisClient *c) {$/;"	f	file:
getDecodedObject	redis.c	/^static robj *getDecodedObject(robj *o) {$/;"	f	file:
getDoubleFromObject	redis.c	/^static int getDoubleFromObject(robj *o, double *target) {$/;"	f	file:
getDoubleFromObjectOrReply	redis.c	/^static int getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg) {$/;"	f	file:
getExpire	redis.c	/^static time_t getExpire(redisDb *db, robj *key) {$/;"	f	file:
getGenericCommand	redis.c	/^static int getGenericCommand(redisClient *c) {$/;"	f	file:
getLongFromObjectOrReply	redis.c	/^static int getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg) {$/;"	f	file:
getLongLongFromObject	redis.c	/^static int getLongLongFromObject(robj *o, long long *target) {$/;"	f	file:
getLongLongFromObjectOrReply	redis.c	/^static int getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg) {$/;"	f	file:
getMcontextEip	redis.c	/^static void *getMcontextEip(ucontext_t *uc) {$/;"	f	file:
getsetCommand	redis.c	/^static void getsetCommand(redisClient *c) {$/;"	f	file:
glueReplyBuffersIfNeeded	redis.c	/^static void glueReplyBuffersIfNeeded(redisClient *c) {$/;"	f	file:
glueoutputbuf	redis.c	/^    int glueoutputbuf;$/;"	m	struct:redisServer	file:
handleClientsBlockedOnSwappedKey	redis.c	/^static void handleClientsBlockedOnSwappedKey(redisDb *db, robj *key) {$/;"	f	file:
handleClientsWaitingListPush	redis.c	/^static int handleClientsWaitingListPush(redisClient *c, robj *key, robj *ele) {$/;"	f	file:
hashCurrent	redis.c	/^static robj *hashCurrent(hashIterator *hi, int what) {$/;"	f	file:
hashDelete	redis.c	/^static int hashDelete(robj *o, robj *key) {$/;"	f	file:
hashDictType	redis.c	/^static dictType hashDictType = {$/;"	v	file:
hashExists	redis.c	/^static int hashExists(robj *o, robj *key) {$/;"	f	file:
hashFunction	dict.h	/^    unsigned int (*hashFunction)(const void *key);$/;"	m	struct:dictType
hashGet	redis.c	/^static robj *hashGet(robj *o, robj *key) {$/;"	f	file:
hashInitIterator	redis.c	/^static hashIterator *hashInitIterator(robj *subject) {$/;"	f	file:
hashIterator	redis.c	/^} hashIterator;$/;"	t	typeref:struct:__anon3	file:
hashLength	redis.c	/^static unsigned long hashLength(robj *o) {$/;"	f	file:
hashLookupWriteOrCreate	redis.c	/^static robj *hashLookupWriteOrCreate(redisClient *c, robj *key) {$/;"	f	file:
hashNext	redis.c	/^static int hashNext(hashIterator *hi) {$/;"	f	file:
hashReleaseIterator	redis.c	/^static void hashReleaseIterator(hashIterator *hi) {$/;"	f	file:
hashSet	redis.c	/^static int hashSet(robj *o, robj *key, robj *value) {$/;"	f	file:
hashTryConversion	redis.c	/^static void hashTryConversion(robj *subject, robj **argv, int start, int end) {$/;"	f	file:
hashTryObjectEncoding	redis.c	/^static void hashTryObjectEncoding(robj *subject, robj **o1, robj **o2) {$/;"	f	file:
hash_max_zipmap_entries	redis.c	/^    size_t hash_max_zipmap_entries;$/;"	m	struct:redisServer	file:
hash_max_zipmap_value	redis.c	/^    size_t hash_max_zipmap_value;$/;"	m	struct:redisServer	file:
haskell-redis (Haskell)	doc/SupportedLanguages.html	/^<h3><a name="haskell-redis (Haskell)">haskell-redis (Haskell)<\/a><\/h3><ul><li> A Haskell binding for the Redis database.<\/li><li> Author: <a href="http:\/\/obvioushints.blogspot.com\/" target="_blank">Alvaro Videla<\/a>, <a href="http:\/\/twitter.com\/old_sound" target="_blank">@old_sound<\/a>.<\/li><li> Repository: <a href="http:\/\/bitbucket.org\/videlalvaro\/redis-haskell\/wiki\/Home" target="_blank">       <\/a><\/li><\/ul>$/;"	a
hdelCommand	redis.c	/^static void hdelCommand(redisClient *c) {$/;"	f	file:
head	adlist.h	/^    listNode *head;$/;"	m	struct:list
header	redis.c	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::zskiplistNode	file:
hexistsCommand	redis.c	/^static void hexistsCommand(redisClient *c) {$/;"	f	file:
hgetCommand	redis.c	/^static void hgetCommand(redisClient *c) {$/;"	f	file:
hgetallCommand	redis.c	/^static void hgetallCommand(redisClient *c) {$/;"	f	file:
hincrbyCommand	redis.c	/^static void hincrbyCommand(redisClient *c) {$/;"	f	file:
history	linenoise.c	/^char **history = NULL;$/;"	v
history_len	linenoise.c	/^static int history_len = 0;$/;"	v	file:
history_max_len	linenoise.c	/^static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;$/;"	v	file:
historyfile	redis-cli.c	/^    char *historyfile;$/;"	m	struct:config	file:
hkeysCommand	redis.c	/^static void hkeysCommand(redisClient *c) {$/;"	f	file:
hlenCommand	redis.c	/^static void hlenCommand(redisClient *c) {$/;"	f	file:
hmgetCommand	redis.c	/^static void hmgetCommand(redisClient *c) {$/;"	f	file:
hmsetCommand	redis.c	/^static void hmsetCommand(redisClient *c) {$/;"	f	file:
hostip	redis-benchmark.c	/^    char *hostip;$/;"	m	struct:config	file:
hostip	redis-cli.c	/^    char *hostip;$/;"	m	struct:config	file:
hostport	redis-benchmark.c	/^    int hostport;$/;"	m	struct:config	file:
hostport	redis-cli.c	/^    int hostport;$/;"	m	struct:config	file:
hsetCommand	redis.c	/^static void hsetCommand(redisClient *c) {$/;"	f	file:
hsetnxCommand	redis.c	/^static void hsetnxCommand(redisClient *c) {$/;"	f	file:
ht	dict.h	/^    dictht ht[2];$/;"	m	struct:dict
htNeedsResize	redis.c	/^static int htNeedsResize(dict *dict) {$/;"	f	file:
hvalsCommand	redis.c	/^static void hvalsCommand(redisClient *c) {$/;"	f	file:
ibuf	redis-benchmark.c	/^    sds ibuf;$/;"	m	struct:_client	file:
id	ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	struct:aeTimeEvent
id	redis.c	/^    int id;$/;"	m	struct:redisDb	file:
idlemode	redis-benchmark.c	/^    int idlemode;$/;"	m	struct:config	file:
incrCommand	redis.c	/^static void incrCommand(redisClient *c) {$/;"	f	file:
incrDecrCommand	redis.c	/^static void incrDecrCommand(redisClient *c, long long incr) {$/;"	f	file:
incrRefCount	redis.c	/^static void incrRefCount(robj *o) {$/;"	f	file:
incrbyCommand	redis.c	/^static void incrbyCommand(redisClient *c) {$/;"	f	file:
increment_used_memory	zmalloc.c	43;"	d	file:
incrementallyRehash	redis.c	/^static void incrementallyRehash(void) {$/;"	f	file:
index	dict.h	/^    int index;$/;"	m	struct:dictIterator
infoCommand	redis.c	/^static void infoCommand(redisClient *c) {$/;"	f	file:
initClientMultiState	redis.c	/^static void initClientMultiState(redisClient *c) {$/;"	f	file:
initServer	redis.c	/^static void initServer() {$/;"	f	file:
initServerConfig	redis.c	/^static void initServerConfig() {$/;"	f	file:
initStaticStringObject	redis.c	277;"	d	file:
inline	lzf_c.c	80;"	d	file:
inline	lzf_c.c	83;"	d	file:
integers	redis.c	/^    *integers[REDIS_SHARED_INTEGERS];$/;"	m	struct:sharedObjectsStruct	file:
interactive	redis-cli.c	/^    int interactive;$/;"	m	struct:config	file:
io_active_threads	redis.c	/^    int io_active_threads; \/* Number of running I\/O threads *\/$/;"	m	struct:redisServer	file:
io_keys	redis.c	/^    dict *io_keys;              \/* Keys with clients waiting for VM I\/O *\/$/;"	m	struct:redisDb	file:
io_keys	redis.c	/^    list *io_keys;          \/* Keys this client is waiting to be loaded from the$/;"	m	struct:redisClient	file:
io_mutex	redis.c	/^    pthread_mutex_t io_mutex; \/* lock to access io_jobs\/io_done\/io_thread_job *\/$/;"	m	struct:redisServer	file:
io_newjobs	redis.c	/^    list *io_newjobs; \/* List of VM I\/O jobs yet to be processed *\/$/;"	m	struct:redisServer	file:
io_processed	redis.c	/^    list *io_processed; \/* List of VM I\/O jobs already processed *\/$/;"	m	struct:redisServer	file:
io_processing	redis.c	/^    list *io_processing; \/* List of VM I\/O jobs being processed *\/$/;"	m	struct:redisServer	file:
io_ready_clients	redis.c	/^    list *io_ready_clients; \/* Clients ready to be unblocked. All keys loaded *\/$/;"	m	struct:redisServer	file:
io_ready_pipe_read	redis.c	/^    int io_ready_pipe_read;$/;"	m	struct:redisServer	file:
io_ready_pipe_write	redis.c	/^    int io_ready_pipe_write;$/;"	m	struct:redisServer	file:
io_swapfile_mutex	redis.c	/^    pthread_mutex_t io_swapfile_mutex; \/* So we can lseek + write *\/$/;"	m	struct:redisServer	file:
io_threads_attr	redis.c	/^    pthread_attr_t io_threads_attr; \/* attributes for threads creation *\/$/;"	m	struct:redisServer	file:
iojob	redis.c	/^typedef struct iojob {$/;"	s	file:
iojob	redis.c	/^} iojob;$/;"	t	typeref:struct:iojob	file:
isLoggedIn	doc/TwitterAlikeExample.html	/^function isLoggedIn() {$/;"	f
isStringRepresentableAsLong	redis.c	/^static int isStringRepresentableAsLong(sds s, long *longval) {$/;"	f	file:
isUnsupportedTerm	linenoise.c	/^static int isUnsupportedTerm(void) {$/;"	f	file:
is_alive	tests/support/server.tcl	/^proc is_alive config {$/;"	p
isfinite	solarisfixes.h	10;"	d
isfinite	solarisfixes.h	9;"	d
isinf	solarisfixes.h	14;"	d
isinf	solarisfixes.h	15;"	d
isnan	solarisfixes.h	4;"	d
isnan	solarisfixes.h	5;"	d
isslave	redis.c	/^    int isslave;$/;"	m	struct:redisServer	file:
iterators	dict.h	/^    int iterators; \/* number of iterators currently running *\/$/;"	m	struct:dict
keepalive	redis-benchmark.c	/^    int keepalive;$/;"	m	struct:config	file:
key	dict.h	/^    void *key;$/;"	m	struct:dictEntry
key	redis-check-dump.c	/^    char* key;$/;"	m	struct:__anon7	file:
key	redis.c	/^    robj *key;  \/* This I\/O request is about swapping this key *\/$/;"	m	struct:iojob	file:
keyCompare	dict.h	/^    int (*keyCompare)(void *privdata, const void *key1, const void *key2);$/;"	m	struct:dictType
keyDestructor	dict.h	/^    void (*keyDestructor)(void *privdata, void *key);$/;"	m	struct:dictType
keyDup	dict.h	/^    void *(*keyDup)(void *privdata, const void *key);$/;"	m	struct:dictType
keylistDictType	redis.c	/^static dictType keylistDictType = {$/;"	v	file:
keyptrDictType	redis.c	/^static dictType keyptrDictType = {$/;"	v	file:
keysCommand	redis.c	/^static void keysCommand(redisClient *c) {$/;"	f	file:
keysize	redis-benchmark.c	/^    int keysize;$/;"	m	struct:config	file:
kill_server	tests/support/server.tcl	/^proc kill_server config {$/;"	p
kqfd	ae_kqueue.c	/^    int kqfd;$/;"	m	struct:aeApiState	file:
lastfsync	redis.c	/^    time_t lastfsync;$/;"	m	struct:redisServer	file:
lastinteraction	redis.c	/^    time_t lastinteraction; \/* time of the last interaction, used for timeout *\/$/;"	m	struct:redisClient	file:
lastsave	redis.c	/^    time_t lastsave;            \/* Unix time of last save succeeede *\/$/;"	m	struct:redisServer	file:
lastsaveCommand	redis.c	/^static void lastsaveCommand(redisClient *c) {$/;"	f	file:
latency	redis-benchmark.c	/^    int *latency;$/;"	m	struct:config	file:
len	adlist.h	/^    unsigned int len;$/;"	m	struct:list
len	sds.h	/^    long len;$/;"	m	struct:sdshdr
length	redis.c	/^    unsigned long length;$/;"	m	struct:zskiplist	file:
level	redis-check-dump.c	/^    size_t level;$/;"	m	struct:__anon6	file:
level	redis-check-dump.c	/^static unsigned char level = 0;$/;"	v	file:
level	redis.c	/^    int level;$/;"	m	struct:zskiplist	file:
lindexCommand	redis.c	/^static void lindexCommand(redisClient *c) {$/;"	f	file:
linenoise	linenoise.c	/^char *linenoise(const char *prompt) {$/;"	f
linenoiseAtExit	linenoise.c	/^static void linenoiseAtExit(void) {$/;"	f	file:
linenoiseHistoryAdd	linenoise.c	/^int linenoiseHistoryAdd(const char *line) {$/;"	f
linenoiseHistoryLoad	linenoise.c	/^int linenoiseHistoryLoad(char *filename) {$/;"	f
linenoiseHistorySave	linenoise.c	/^int linenoiseHistorySave(char *filename) {$/;"	f
linenoiseHistorySetMaxLen	linenoise.c	/^int linenoiseHistorySetMaxLen(int len) {$/;"	f
linenoisePrompt	linenoise.c	/^static int linenoisePrompt(int fd, char *buf, size_t buflen, const char *prompt) {$/;"	f	file:
linenoiseRaw	linenoise.c	/^static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {$/;"	f	file:
linuxOvercommitMemoryValue	redis.c	/^int linuxOvercommitMemoryValue(void) {$/;"	f
linuxOvercommitMemoryWarning	redis.c	/^void linuxOvercommitMemoryWarning(void) {$/;"	f
list	adlist.h	/^typedef struct list {$/;"	s
list	adlist.h	/^} list;$/;"	t	typeref:struct:list
listAddNodeHead	adlist.c	/^list *listAddNodeHead(list *list, void *value)$/;"	f
listAddNodeTail	adlist.c	/^list *listAddNodeTail(list *list, void *value)$/;"	f
listCreate	adlist.c	/^list *listCreate(void)$/;"	f
listDelNode	adlist.c	/^void listDelNode(list *list, listNode *node)$/;"	f
listDup	adlist.c	/^list *listDup(list *orig)$/;"	f
listFirst	adlist.h	58;"	d
listGetDupMethod	adlist.h	68;"	d
listGetFree	adlist.h	69;"	d
listGetIterator	adlist.c	/^listIter *listGetIterator(list *list, int direction)$/;"	f
listGetMatchMethod	adlist.h	70;"	d
listIndex	adlist.c	/^listNode *listIndex(list *list, int index) {$/;"	f
listIter	adlist.h	/^typedef struct listIter {$/;"	s
listIter	adlist.h	/^} listIter;$/;"	t	typeref:struct:listIter
listLast	adlist.h	59;"	d
listLength	adlist.h	57;"	d
listMatchObjects	redis.c	/^static int listMatchObjects(void *a, void *b) {$/;"	f	file:
listMatchPubsubPattern	redis.c	/^static int listMatchPubsubPattern(void *a, void *b) {$/;"	f	file:
listNext	adlist.c	/^listNode *listNext(listIter *iter)$/;"	f
listNextNode	adlist.h	61;"	d
listNode	adlist.h	/^typedef struct listNode {$/;"	s
listNode	adlist.h	/^} listNode;$/;"	t	typeref:struct:listNode
listNodeValue	adlist.h	62;"	d
listPrevNode	adlist.h	60;"	d
listRelease	adlist.c	/^void listRelease(list *list)$/;"	f
listReleaseIterator	adlist.c	/^void listReleaseIterator(listIter *iter) {$/;"	f
listRewind	adlist.c	/^void listRewind(list *list, listIter *li) {$/;"	f
listRewindTail	adlist.c	/^void listRewindTail(list *list, listIter *li) {$/;"	f
listSearchKey	adlist.c	/^listNode *listSearchKey(list *list, void *key)$/;"	f
listSetDupMethod	adlist.h	64;"	d
listSetFreeMethod	adlist.h	65;"	d
listSetMatchMethod	adlist.h	66;"	d
liveclients	redis-benchmark.c	/^    int liveclients;$/;"	m	struct:config	file:
ll2string	redis.c	/^static int ll2string(char *s, size_t len, long long value) {$/;"	f	file:
llenCommand	redis.c	/^static void llenCommand(redisClient *c) {$/;"	f	file:
loadAppendOnlyFile	redis.c	/^int loadAppendOnlyFile(char *filename) {$/;"	f
loadDoubleValue	redis-check-dump.c	/^double* loadDoubleValue() {$/;"	f
loadEntry	redis-check-dump.c	/^entry loadEntry() {$/;"	f
loadIntegerObject	redis-check-dump.c	/^char *loadIntegerObject(int enctype) {$/;"	f
loadLength	redis-check-dump.c	/^uint32_t loadLength(int *isencoded) {$/;"	f
loadLzfStringObject	redis-check-dump.c	/^char* loadLzfStringObject() {$/;"	f
loadPair	redis-check-dump.c	/^int loadPair(entry *e) {$/;"	f
loadServerConfig	redis.c	/^static void loadServerConfig(char *filename) {$/;"	f	file:
loadStringObject	redis-check-dump.c	/^char* loadStringObject() {$/;"	f
loadType	redis-check-dump.c	/^int loadType(entry *e) {$/;"	f
loadUserInfo	doc/TwitterAlikeExample.html	/^function loadUserInfo($userid) {$/;"	f
lockThreadedIO	redis.c	/^static void lockThreadedIO(void) {$/;"	f	file:
logfile	redis.c	/^    char *logfile;$/;"	m	struct:redisServer	file:
lookupCommand	redis.c	/^static struct redisCommand *lookupCommand(char *name) {$/;"	f	file:
lookupKey	redis.c	/^static robj *lookupKey(redisDb *db, robj *key) {$/;"	f	file:
lookupKeyByPattern	redis.c	/^static robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {$/;"	f	file:
lookupKeyRead	redis.c	/^static robj *lookupKeyRead(redisDb *db, robj *key) {$/;"	f	file:
lookupKeyReadOrReply	redis.c	/^static robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply) {$/;"	f	file:
lookupKeyWrite	redis.c	/^static robj *lookupKeyWrite(redisDb *db, robj *key) {$/;"	f	file:
lookupKeyWriteOrReply	redis.c	/^static robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply) {$/;"	f	file:
loop	redis-benchmark.c	/^    int loop;$/;"	m	struct:config	file:
lpopCommand	redis.c	/^static void lpopCommand(redisClient *c) {$/;"	f	file:
lpushCommand	redis.c	/^static void lpushCommand(redisClient *c) {$/;"	f	file:
lrangeCommand	redis.c	/^static void lrangeCommand(redisClient *c) {$/;"	f	file:
lremCommand	redis.c	/^static void lremCommand(redisClient *c) {$/;"	f	file:
lsetCommand	redis.c	/^static void lsetCommand(redisClient *c) {$/;"	f	file:
ltrimCommand	redis.c	/^static void ltrimCommand(redisClient *c) {$/;"	f	file:
lzf_compress	lzf_c.c	/^lzf_compress (const void *const in_data, unsigned int in_len,$/;"	f
lzf_decompress	lzf_d.c	/^lzf_decompress (const void *const in_data,  unsigned int in_len,$/;"	f
main	redis-benchmark.c	/^int main(int argc, char **argv) {$/;"	f
main	redis-check-aof.c	/^int main(int argc, char **argv) {$/;"	f
main	redis-check-dump.c	/^int main(int argc, char **argv) {$/;"	f
main	redis-cli.c	/^int main(int argc, char **argv) {$/;"	f
main	redis.c	/^int main(int argc, char **argv) {$/;"	f
main	tests/test_helper.tcl	/^proc main {} {$/;"	p
main	zipmap.c	/^int main(void) {$/;"	f
mainthread	redis.c	/^    pthread_t mainthread;$/;"	m	struct:redisServer	file:
mask	ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	struct:aeFileEvent
mask	ae.h	/^    int mask;$/;"	m	struct:aeFiredEvent
master	redis.c	/^    redisClient *master;    \/* client that is master for this slave *\/$/;"	m	struct:redisServer	file:
masterauth	redis.c	/^    char *masterauth;$/;"	m	struct:redisServer	file:
masterhost	redis.c	/^    char *masterhost;$/;"	m	struct:redisServer	file:
masterport	redis.c	/^    int masterport;$/;"	m	struct:redisServer	file:
match	adlist.h	/^    int (*match)(void *ptr, void *key);$/;"	m	struct:list
maxclients	redis.c	/^    unsigned int maxclients;$/;"	m	struct:redisServer	file:
maxfd	ae.h	/^    int maxfd;$/;"	m	struct:aeEventLoop
maxidletime	redis.c	/^    int maxidletime;$/;"	m	struct:redisServer	file:
maxmemory	redis.c	/^    unsigned long long maxmemory;$/;"	m	struct:redisServer	file:
mb_sep	redis-cli.c	/^    char mb_sep;$/;"	m	struct:config	file:
mbargc	redis.c	/^    int argc, mbargc;$/;"	m	struct:redisClient	file:
mbargv	redis.c	/^    robj **argv, **mbargv;$/;"	m	struct:redisClient	file:
mbulk	redis-benchmark.c	/^    int mbulk;          \/* Number of elements in an mbulk reply *\/$/;"	m	struct:_client	file:
mbulk3	redis.c	/^    *messagebulk, *pmessagebulk, *subscribebulk, *unsubscribebulk, *mbulk3,$/;"	m	struct:sharedObjectsStruct	file:
mbulk4	redis.c	/^    *mbulk4, *psubscribebulk, *punsubscribebulk,$/;"	m	struct:sharedObjectsStruct	file:
med3	pqsort.c	/^med3(char *a, char *b, char *c,$/;"	f	file:
memtoll	redis.c	/^static long long memtoll(const char *p, int *err) {$/;"	f	file:
messagebulk	redis.c	/^    *messagebulk, *pmessagebulk, *subscribebulk, *unsubscribebulk, *mbulk3,$/;"	m	struct:sharedObjectsStruct	file:
mgetCommand	redis.c	/^static void mgetCommand(redisClient *c) {$/;"	f	file:
min	pqsort.c	50;"	d	file:
mixDigest	redis.c	/^static void mixDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f	file:
mixObjectDigest	redis.c	/^static void mixObjectDigest(unsigned char *digest, robj *o) {$/;"	f	file:
monitorCommand	redis.c	/^static void monitorCommand(redisClient *c) {$/;"	f	file:
monitor_mode	redis-cli.c	/^    int monitor_mode;$/;"	m	struct:config	file:
monitors	redis.c	/^    list *slaves, *monitors;$/;"	m	struct:redisServer	file:
moveCommand	redis.c	/^static void moveCommand(redisClient *c) {$/;"	f	file:
msetCommand	redis.c	/^static void msetCommand(redisClient *c) {$/;"	f	file:
msetGenericCommand	redis.c	/^static void msetGenericCommand(redisClient *c, int nx) {$/;"	f	file:
msetnxCommand	redis.c	/^static void msetnxCommand(redisClient *c) {$/;"	f	file:
mstate	redis.c	/^    multiState mstate;      \/* MULTI\/EXEC state *\/$/;"	m	struct:redisClient	file:
mstime	redis-benchmark.c	/^static long long mstime(void) {$/;"	f	file:
multiCmd	redis.c	/^typedef struct multiCmd {$/;"	s	file:
multiCmd	redis.c	/^} multiCmd;$/;"	t	typeref:struct:multiCmd	file:
multiCommand	redis.c	/^static void multiCommand(redisClient *c) {$/;"	f	file:
multiState	redis.c	/^typedef struct multiState {$/;"	s	file:
multiState	redis.c	/^} multiState;$/;"	t	typeref:struct:multiState	file:
multibulk	redis.c	/^    int multibulk;          \/* multi bulk command format active *\/$/;"	m	struct:redisClient	file:
name	redis.c	/^    char *name;$/;"	m	struct:redisCommand	file:
name	redis.c	/^    char *name;$/;"	m	struct:redisFunctionSym	file:
neterr	redis.c	/^    char neterr[ANET_ERR_LEN];$/;"	m	struct:redisServer	file:
next	adlist.h	/^    listNode *next;$/;"	m	struct:listIter
next	adlist.h	/^    struct listNode *next;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
next	ae.h	/^    struct aeTimeEvent *next;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent
next	dict.h	/^    struct dictEntry *next;$/;"	m	struct:dictEntry	typeref:struct:dictEntry::dictEntry
nextEntry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
nokeyerr	redis.c	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	file:
noninteractive	redis-cli.c	/^static int noninteractive(int argc, char **argv) {$/;"	f	file:
nullbulk	redis.c	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	file:
nullmultibulk	redis.c	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	file:
numclients	redis-benchmark.c	/^    int numclients;$/;"	m	struct:config	file:
obj	redis.c	/^    robj *obj;$/;"	m	struct:_redisSortObject	file:
obj	redis.c	/^    robj *obj;$/;"	m	struct:zskiplistNode	file:
obj_freelist_mutex	redis.c	/^    pthread_mutex_t obj_freelist_mutex; \/* safe redis objects creation\/free *\/$/;"	m	struct:redisServer	file:
objfreelist	redis.c	/^    list *objfreelist;          \/* A list of freed objects to avoid malloc() *\/$/;"	m	struct:redisServer	file:
obuf	redis-benchmark.c	/^    sds obuf;$/;"	m	struct:_client	file:
offset	redis-check-dump.c	/^    size_t offset;$/;"	m	struct:__anon5	file:
offset	redis-check-dump.c	/^    size_t offset[16];$/;"	m	struct:__anon6	file:
ok	redis.c	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	file:
oom	redis.c	/^static void oom(const char *msg) {$/;"	f	file:
orig_termios	linenoise.c	/^static struct termios orig_termios; \/* in order to restore at exit *\/$/;"	v	typeref:struct:termios	file:
outofrangeerr	redis.c	/^    *outofrangeerr, *plus,$/;"	m	struct:sharedObjectsStruct	file:
page	redis.c	/^    off_t page;         \/* the page at witch the object is stored on disk *\/$/;"	m	struct:redisObjectVM	file:
page	redis.c	/^    off_t page; \/* Swap page where to read\/write the object *\/$/;"	m	struct:iojob	file:
pages	redis.c	/^    off_t pages; \/* Swap pages needed to save object. PREPARE_SWAP return val *\/$/;"	m	struct:iojob	file:
parseOptions	redis-benchmark.c	/^void parseOptions(int argc, char **argv) {$/;"	f
parseOptions	redis-cli.c	/^static int parseOptions(int argc, char **argv) {$/;"	f	file:
pattern	redis.c	/^    robj *pattern;$/;"	m	struct:_redisSortOperation	file:
pattern	redis.c	/^    robj *pattern;$/;"	m	struct:pubsubPattern	file:
peekType	redis-check-dump.c	/^int peekType() {$/;"	f
phpredis	doc/SupportedLanguages.html	/^<h4><a name="phpredis">phpredis<\/a><\/h4><ul><li> This extension provides an API for communicating with Redis database, a persistent key-value database with built-in net interface written in ANSI-C for Posix systems.<\/li><li> Author: <a href="http:\/\/www.alfonsojimenez.com\/" target="_blank">Alfonso Jimenez<\/a> , (<a href="http:\/\/twitter.com\/alfonsojimenez" target="_blank">@alfonsojimenez<\/a>), Nicolas Favre-F&Atilde;&copy;lix and Nasreddine Bouafif.<\/li><li> Repository: <a href="http:\/\/github.com\/owlient\/phpredis" target="_blank">http:\/\/github.com\/owlient\/phpredis<\/a><\/li><\/ul>$/;"	a
pidfile	redis.c	/^    char *pidfile;$/;"	m	struct:redisServer	file:
pingCommand	redis.c	/^static void pingCommand(redisClient *c) {$/;"	f	file:
ping_server	tests/support/server.tcl	/^proc ping_server {host port} {$/;"	p
plus	redis.c	/^    *outofrangeerr, *plus,$/;"	m	struct:sharedObjectsStruct	file:
pmessagebulk	redis.c	/^    *messagebulk, *pmessagebulk, *subscribebulk, *unsubscribebulk, *mbulk3,$/;"	m	struct:sharedObjectsStruct	file:
pointer	redis.c	/^    unsigned long pointer;$/;"	m	struct:redisFunctionSym	file:
pong	redis.c	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	file:
popGenericCommand	redis.c	/^static void popGenericCommand(redisClient *c, int where) {$/;"	f	file:
port	redis.c	/^    int port;$/;"	m	struct:redisServer	file:
pos	redis-check-dump.c	/^} pos;$/;"	t	typeref:struct:__anon5	file:
positions	redis-check-dump.c	/^static pos positions[16];$/;"	v	file:
pqsort	pqsort.c	/^pqsort(void *a, size_t n, size_t es,$/;"	f
prepareClientForReply	redis-benchmark.c	/^static void prepareClientForReply(client c, int type) {$/;"	f	file:
prepareForBenchmark	redis-benchmark.c	/^static void prepareForBenchmark(void)$/;"	f	file:
prepareForShutdown	redis.c	/^static int prepareForShutdown() {$/;"	f	file:
prev	adlist.h	/^    struct listNode *prev;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
printCentered	redis-check-dump.c	/^void printCentered(int indent, int width, char* body) {$/;"	f
printErrorStack	redis-check-dump.c	/^void printErrorStack(entry *e) {$/;"	f
printSkipped	redis-check-dump.c	/^void printSkipped(uint64_t bytes, uint64_t offset) {$/;"	f
printStringRepr	redis-cli.c	/^static void printStringRepr(char *s, int len) {$/;"	f	file:
printValid	redis-check-dump.c	/^void printValid(uint64_t ops, uint64_t bytes) {$/;"	f
privdata	dict.h	/^    void *privdata;$/;"	m	struct:dict
proc	redis.c	/^    redisCommandProc *proc;$/;"	m	struct:redisCommand	file:
process	redis-check-aof.c	/^long process(FILE *fp) {$/;"	f
process	redis-check-dump.c	/^void process() {$/;"	f
processCommand	redis.c	/^static int processCommand(redisClient *c) {$/;"	f	file:
processDoubleValue	redis-check-dump.c	/^int processDoubleValue(double** store) {$/;"	f
processHeader	redis-check-dump.c	/^int processHeader() {$/;"	f
processInputBuffer	redis.c	/^static void processInputBuffer(redisClient *c) {$/;"	f	file:
processStringObject	redis-check-dump.c	/^int processStringObject(char** store) {$/;"	f
processTime	redis-check-dump.c	/^int processTime() {$/;"	f
processTimeEvents	ae.c	/^static int processTimeEvents(aeEventLoop *eventLoop) {$/;"	f	file:
processTimeEvents	doc/RedisEventLibrary.html	/^<\/pre><code name="code" class="python">c<\/code> is the <code name="code" class="python">redisClient<\/code> structure variable and <code name="code" class="python">c-&gt;fd<\/code> is the connected descriptor.<br\/><br\/>Next the <code name="code" class="python">ae.c:aeProcessEvent<\/code> calls <code name="code" class="python">ae.c:processTimeEvents<\/code><h3><a name="processTimeEvents">processTimeEvents<\/a><\/h3><code name="code" class="python">ae.processTimeEvents<\/code> iterates over list of time events starting at <code name="code" class="python">eventLoop-&gt;timeEventHead<\/code>.<br\/><br\/>For every timed event that has elapsed <code name="code" class="python">processTimeEvents<\/code> calls the registered callback. In this case it calls the only timed event callback registered, that is, <code name="code" class="python">redis.c:serverCron<\/code>. The callback returns the time in milliseconds after which the callback must be called again. This change is recorded via a call to <code name="code" class="python">ae.c:aeAddMilliSeconds<\/code> and will be handled on the next iteration of <code name="code" class="python">ae.c:aeMain<\/code> while loop.<br\/><br\/>That's all.$/;"	a
psubscribeCommand	redis.c	/^static void psubscribeCommand(redisClient *c) {$/;"	f	file:
psubscribebulk	redis.c	/^    *mbulk4, *psubscribebulk, *punsubscribebulk,$/;"	m	struct:sharedObjectsStruct	file:
ptr	redis.c	/^    void *ptr;$/;"	m	struct:redisObject	file:
publishCommand	redis.c	/^static void publishCommand(redisClient *c) {$/;"	f	file:
pubsubPattern	redis.c	/^typedef struct pubsubPattern {$/;"	s	file:
pubsubPattern	redis.c	/^} pubsubPattern;$/;"	t	typeref:struct:pubsubPattern	file:
pubsubPublishMessage	redis.c	/^static int pubsubPublishMessage(robj *channel, robj *message) {$/;"	f	file:
pubsubSubscribeChannel	redis.c	/^static int pubsubSubscribeChannel(redisClient *c, robj *channel) {$/;"	f	file:
pubsubSubscribePattern	redis.c	/^static int pubsubSubscribePattern(redisClient *c, robj *pattern) {$/;"	f	file:
pubsubUnsubscribeAllChannels	redis.c	/^static int pubsubUnsubscribeAllChannels(redisClient *c, int notify) {$/;"	f	file:
pubsubUnsubscribeAllPatterns	redis.c	/^static int pubsubUnsubscribeAllPatterns(redisClient *c, int notify) {$/;"	f	file:
pubsubUnsubscribeChannel	redis.c	/^static int pubsubUnsubscribeChannel(redisClient *c, robj *channel, int notify) {$/;"	f	file:
pubsubUnsubscribePattern	redis.c	/^static int pubsubUnsubscribePattern(redisClient *c, robj *pattern, int notify) {$/;"	f	file:
pubsub_channels	redis.c	/^    dict *pubsub_channels;  \/* channels a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:redisClient	file:
pubsub_channels	redis.c	/^    dict *pubsub_channels; \/* Map channels to list of subscribed clients *\/$/;"	m	struct:redisServer	file:
pubsub_mode	redis-cli.c	/^    int pubsub_mode;$/;"	m	struct:config	file:
pubsub_patterns	redis.c	/^    list *pubsub_patterns;  \/* patterns a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:redisClient	file:
pubsub_patterns	redis.c	/^    list *pubsub_patterns; \/* A list of pubsub_patterns *\/$/;"	m	struct:redisServer	file:
punsubscribeCommand	redis.c	/^static void punsubscribeCommand(redisClient *c) {$/;"	f	file:
punsubscribebulk	redis.c	/^    *mbulk4, *psubscribebulk, *punsubscribebulk,$/;"	m	struct:sharedObjectsStruct	file:
pushGenericCommand	redis.c	/^static void pushGenericCommand(redisClient *c, int where) {$/;"	f	file:
py-redis	doc/SupportedLanguages.html	/^<h4><a name="py-redis">py-redis<\/a><\/h4><ul><li> Redis Python Client.<\/li><li> Author: <a href="Andy.html">McCurdy<\/a>, <a href="http:\/\/twitter.com\/andymccurdy" target="_blank">@andymccurdy<\/a>.<\/li><li> Repository: <a href="http:\/\/github.com\/andymccurdy\/redis-py" target="_blank">http:\/\/github.com\/andymccurdy\/redis-py<\/a><\/li><\/ul>$/;"	a
qsortCompareSetsByCardinality	redis.c	/^static int qsortCompareSetsByCardinality(const void *s1, const void *s2) {$/;"	f	file:
qsortCompareZsetopsrcByCardinality	redis.c	/^static int qsortCompareZsetopsrcByCardinality(const void *s1, const void *s2) {$/;"	f	file:
querybuf	redis.c	/^    sds querybuf;$/;"	m	struct:redisClient	file:
queueIOJob	redis.c	/^static void queueIOJob(iojob *j) {$/;"	f	file:
queueMultiCommand	redis.c	/^static void queueMultiCommand(redisClient *c, struct redisCommand *cmd) {$/;"	f	file:
queued	redis.c	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	file:
quiet	redis-benchmark.c	/^    int quiet;$/;"	m	struct:config	file:
r	tests/test_helper.tcl	/^proc r {args} {$/;"	p
randomInt	tests/support/util.tcl	/^proc randomInt {max} {$/;"	p
randomKey	tests/support/util.tcl	/^proc randomKey {} {$/;"	p
randomValue	tests/support/util.tcl	/^proc randomValue {} {$/;"	p
randomizeClientKey	redis-benchmark.c	/^static void randomizeClientKey(client c) {$/;"	f	file:
randomkeyCommand	redis.c	/^static void randomkeyCommand(redisClient *c) {$/;"	f	file:
randomkeys	redis-benchmark.c	/^    int randomkeys;$/;"	m	struct:config	file:
randomkeys_keyspacelen	redis-benchmark.c	/^    int randomkeys_keyspacelen;$/;"	m	struct:config	file:
randpath	tests/support/util.tcl	/^proc randpath args {$/;"	p
randstring	tests/support/util.tcl	/^proc randstring {min max {type binary}} {$/;"	p
raw_output	redis-cli.c	/^    int raw_output; \/* output mode per command *\/$/;"	m	struct:config	file:
rawmode	linenoise.c	/^static int rawmode = 0; \/* for atexit() function to check if restore is needed*\/$/;"	v	file:
rdbEncodeInteger	redis.c	/^static int rdbEncodeInteger(long long value, unsigned char *enc) {$/;"	f	file:
rdbGenericLoadStringObject	redis.c	/^static robj *rdbGenericLoadStringObject(FILE*fp, int encode) {$/;"	f	file:
rdbLoad	redis.c	/^static int rdbLoad(char *filename) {$/;"	f	file:
rdbLoadDoubleValue	redis.c	/^static int rdbLoadDoubleValue(FILE *fp, double *val) {$/;"	f	file:
rdbLoadEncodedStringObject	redis.c	/^static robj *rdbLoadEncodedStringObject(FILE *fp) {$/;"	f	file:
rdbLoadIntegerObject	redis.c	/^static robj *rdbLoadIntegerObject(FILE *fp, int enctype, int encode) {$/;"	f	file:
rdbLoadLen	redis.c	/^static uint32_t rdbLoadLen(FILE *fp, int *isencoded) {$/;"	f	file:
rdbLoadLzfStringObject	redis.c	/^static robj *rdbLoadLzfStringObject(FILE*fp) {$/;"	f	file:
rdbLoadObject	redis.c	/^static robj *rdbLoadObject(int type, FILE *fp) {$/;"	f	file:
rdbLoadStringObject	redis.c	/^static robj *rdbLoadStringObject(FILE *fp) {$/;"	f	file:
rdbLoadTime	redis.c	/^static time_t rdbLoadTime(FILE *fp) {$/;"	f	file:
rdbLoadType	redis.c	/^static int rdbLoadType(FILE *fp) {$/;"	f	file:
rdbRemoveTempFile	redis.c	/^static void rdbRemoveTempFile(pid_t childpid) {$/;"	f	file:
rdbSave	redis.c	/^static int rdbSave(char *filename) {$/;"	f	file:
rdbSaveBackground	redis.c	/^static int rdbSaveBackground(char *filename) {$/;"	f	file:
rdbSaveDoubleValue	redis.c	/^static int rdbSaveDoubleValue(FILE *fp, double val) {$/;"	f	file:
rdbSaveLen	redis.c	/^static int rdbSaveLen(FILE *fp, uint32_t len) {$/;"	f	file:
rdbSaveLzfStringObject	redis.c	/^static int rdbSaveLzfStringObject(FILE *fp, unsigned char *s, size_t len) {$/;"	f	file:
rdbSaveObject	redis.c	/^static int rdbSaveObject(FILE *fp, robj *o) {$/;"	f	file:
rdbSaveRawString	redis.c	/^static int rdbSaveRawString(FILE *fp, unsigned char *s, size_t len) {$/;"	f	file:
rdbSaveStringObject	redis.c	/^static int rdbSaveStringObject(FILE *fp, robj *obj) {$/;"	f	file:
rdbSaveTime	redis.c	/^static int rdbSaveTime(FILE *fp, time_t t) {$/;"	f	file:
rdbSaveType	redis.c	/^static int rdbSaveType(FILE *fp, unsigned char type) {$/;"	f	file:
rdbSavedObjectLen	redis.c	/^static off_t rdbSavedObjectLen(robj *o, FILE *fp) {$/;"	f	file:
rdbSavedObjectPages	redis.c	/^static off_t rdbSavedObjectPages(robj *o, FILE *fp) {$/;"	f	file:
rdbTryIntegerEncoding	redis.c	/^static int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {$/;"	f	file:
rdbcompression	redis.c	/^    int rdbcompression;$/;"	m	struct:redisServer	file:
readArgFromStdin	redis-cli.c	/^static sds readArgFromStdin(void) {$/;"	f	file:
readArgc	redis-check-aof.c	/^int readArgc(FILE *fp, long *target) {$/;"	f
readBytes	redis-check-aof.c	/^int readBytes(FILE *fp, char *target, long length) {$/;"	f
readBytes	redis-check-dump.c	/^int readBytes(void *target, long num) {$/;"	f
readHandler	redis-benchmark.c	/^static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask)$/;"	f	file:
readLong	redis-check-aof.c	/^int readLong(FILE *fp, char prefix, long *target) {$/;"	f
readQueryFromClient	redis.c	/^static void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
readString	redis-check-aof.c	/^int readString(FILE *fp, char** target) {$/;"	f
readlen	redis-benchmark.c	/^    int readlen;        \/* readlen == -1 means read a single line *\/$/;"	m	struct:_client	file:
redis	tests/support/redis.tcl	/^proc redis {{server 127.0.0.1} {port 6379} {defer 0}} {$/;"	p
redis-clojure (Clojure)	doc/SupportedLanguages.html	/^<h3><a name="redis-clojure (Clojure)">redis-clojure (Clojure)<\/a><\/h3><ul><li> A Clojure client library for the key-value storage system Redis.<\/li><li> Repository: <a href="http:\/\/github.com\/ragnard\/redis-clojure" target="_blank">http:\/\/github.com\/ragnard\/redis-clojure<\/a><\/li><li> Author: Ragnar Dahl&Atilde;&copy;n, <a href="http:\/\/twitter.com\/ragge" target="_blank">@ragge<\/a>.<\/li><\/ul>$/;"	a
redis-lua (Lua)	doc/SupportedLanguages.html	/^<h3><a name="redis-lua (Lua)">redis-lua (Lua)<\/a><\/h3><ul><li> A Lua client library for the redis key value storage system.<\/li><li> Author: <a href="http:\/\/www.clorophilla.net\/blog\/" target="_blank">Daniele Alessandri<\/a>, <a href="http:\/\/twitter.com\/jol1hahn" target="_blank">@jol1hahn<\/a>.<\/li><li> Repository: <a href="http:\/\/github.com\/nrk\/redis-lua" target="_blank">http:\/\/github.com\/nrk\/redis-lua<\/a><\/li><\/ul>$/;"	a
redis-models	doc/ObjectHashMappers.html	/^<h3><a name="redis-models">redis-models<\/a><\/h3><ul><li> Minimal model support for Redis. Directly maps Ruby properties to model_name:id:field_name keys in redis. Scalar, List and Set properties are supported. Values can be marshaled to\/from Integer, Float, DateTime, JSON. <\/li><li> Repository: <a href="http:\/\/github.com\/voloko\/redis-model" target="_blank">http:\/\/github.com\/voloko\/redis-model<\/a><\/li><\/ul>$/;"	a
redis-rb (Ruby)	doc/SupportedLanguages.html	/^<h3><a name="redis-rb (Ruby)">redis-rb (Ruby)<\/a><\/h3><ul><li> A Ruby client library for the redis key value storage engine.<\/li><li> Author: <a href="http:\/\/brainspl.at\/" target="_blank">Ezra Zygmuntowicz<\/a>, <a href="http:\/\/twitter.com\/ezmobius" target="_blank">@ezmobius<\/a>.<\/li><li> Repository: <a href="http:\/\/github.com\/ezmobius\/redis-rb" target="_blank">http:\/\/github.com\/ezmobius\/redis-rb<\/a><\/li><\/ul>$/;"	a
redisAssert	redis.c	240;"	d	file:
redisClient	redis.c	/^typedef struct redisClient {$/;"	s	file:
redisClient	redis.c	/^} redisClient;$/;"	t	typeref:struct:redisClient	file:
redisCommand	redis.c	/^struct redisCommand {$/;"	s	file:
redisCommandProc	redis.c	/^typedef void redisCommandProc(redisClient *c);$/;"	t	file:
redisCopy	utils/redis-copy.rb	/^def redisCopy(opts={})$/;"	f
redisDb	redis.c	/^typedef struct redisDb {$/;"	s	file:
redisDb	redis.c	/^} redisDb;$/;"	t	typeref:struct:redisDb	file:
redisFunctionSym	redis.c	/^struct redisFunctionSym {$/;"	s	file:
redisLog	redis.c	/^static void redisLog(int level, const char *fmt, ...) {$/;"	f	file:
redisObject	redis.c	/^typedef struct redisObject {$/;"	s	file:
redisObjectVM	redis.c	/^struct redisObjectVM {$/;"	s	file:
redisPanic	redis.c	241;"	d	file:
redisServer	redis.c	/^struct redisServer {$/;"	s	file:
redisSha1	utils/redis-sha1.rb	/^def redisSha1(opts={})$/;"	f
redisSortObject	redis.c	/^} redisSortObject;$/;"	t	typeref:struct:_redisSortObject	file:
redisSortOperation	redis.c	/^} redisSortOperation;$/;"	t	typeref:struct:_redisSortOperation	file:
redisVmPreloadProc	redis.c	/^typedef void redisVmPreloadProc(redisClient *c, struct redisCommand *cmd, int argc, robj **argv);$/;"	t	file:
redis_deferring_client	tests/test_helper.tcl	/^proc redis_deferring_client {args} {$/;"	p
redis_fstat	config.h	19;"	d
redis_fstat	config.h	22;"	d
redis_malloc_size	config.h	14;"	d
redis_stat	config.h	20;"	d
redis_stat	config.h	23;"	d
refcount	redis.c	/^    int refcount;$/;"	m	struct:redisObject	file:
refreshLine	linenoise.c	/^static void refreshLine(int fd, const char *prompt, char *buf, size_t len, size_t pos, size_t cols) {$/;"	f	file:
rehashidx	dict.h	/^    int rehashidx; \/* rehashing not in progress if rehashidx == -1 *\/$/;"	m	struct:dict
release_hdr	Makefile	/^release_hdr := $(shell sh -c '.\/mkreleasehdr.sh')$/;"	m
removeExpire	redis.c	/^static int removeExpire(redisDb *db, robj *key) {$/;"	f	file:
remrangebyrank	tests/unit/type/zset.tcl	/^        proc remrangebyrank {min max} {$/;"	p
renameCommand	redis.c	/^static void renameCommand(redisClient *c) {$/;"	f	file:
renameGenericCommand	redis.c	/^static void renameGenericCommand(redisClient *c, int nx) {$/;"	f	file:
renamenxCommand	redis.c	/^static void renamenxCommand(redisClient *c) {$/;"	f	file:
repeat	redis-cli.c	/^    long repeat;$/;"	m	struct:config	file:
repl	redis-cli.c	/^static void repl() {$/;"	f	file:
repldbfd	redis.c	/^    int repldbfd;           \/* replication DB file descriptor *\/$/;"	m	struct:redisClient	file:
repldboff	redis.c	/^    long repldboff;         \/* replication DB file offset *\/$/;"	m	struct:redisClient	file:
repldbsize	redis.c	/^    off_t repldbsize;       \/* replication DB file size *\/$/;"	m	struct:redisClient	file:
replicationFeedMonitors	redis.c	/^static void replicationFeedMonitors(list *monitors, int dictid, robj **argv, int argc) {$/;"	f	file:
replicationFeedSlaves	redis.c	/^static void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {$/;"	f	file:
replstate	redis.c	/^    int replstate;          \/* replication state if this is a slave *\/$/;"	m	struct:redisClient	file:
replstate	redis.c	/^    int replstate;$/;"	m	struct:redisServer	file:
reply	redis.c	/^    list *reply;$/;"	m	struct:redisClient	file:
replytype	redis-benchmark.c	/^    int replytype;$/;"	m	struct:_client	file:
requests	redis-benchmark.c	/^    int requests;$/;"	m	struct:config	file:
requirepass	redis.c	/^    char *requirepass;$/;"	m	struct:redisServer	file:
resetClient	redis-benchmark.c	/^static void resetClient(client c) {$/;"	f	file:
resetClient	redis.c	/^static void resetClient(redisClient *c) {$/;"	f	file:
resetServerSaveParams	redis.c	/^static void resetServerSaveParams() {$/;"	f	file:
rewriteAppendOnlyFile	redis.c	/^static int rewriteAppendOnlyFile(char *filename) {$/;"	f	file:
rewriteAppendOnlyFileBackground	redis.c	/^static int rewriteAppendOnlyFileBackground(void) {$/;"	f	file:
rfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
rfileProc	ae.h	/^    aeFileProc *rfileProc;$/;"	m	struct:aeFileEvent
robj	redis.c	/^} robj;$/;"	t	typeref:struct:redisObject	file:
rol	sha1.c	81;"	d	file:
rpopCommand	redis.c	/^static void rpopCommand(redisClient *c) {$/;"	f	file:
rpoplpushcommand	redis.c	/^static void rpoplpushcommand(redisClient *c) {$/;"	f	file:
rpushCommand	redis.c	/^static void rpushCommand(redisClient *c) {$/;"	f	file:
s	tests/test_helper.tcl	/^proc s {args} {$/;"	p
saddCommand	redis.c	/^static void saddCommand(redisClient *c) {$/;"	f	file:
sameobjecterr	redis.c	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	file:
saveCommand	redis.c	/^static void saveCommand(redisClient *c) {$/;"	f	file:
saveparam	redis.c	/^struct saveparam {$/;"	s	file:
saveparams	redis.c	/^    struct saveparam *saveparams;$/;"	m	struct:redisServer	typeref:struct:redisServer::saveparam	file:
saveparamslen	redis.c	/^    int saveparamslen;$/;"	m	struct:redisServer	file:
scala-redis (Scala)	doc/SupportedLanguages.html	/^<h3><a name="scala-redis (Scala)">scala-redis (Scala)<\/a><\/h3><ul><li> A scala library for connecting to a redis server, or a cluster of redis nodes using consistent hashing on the client side.<\/li><li> Author: <a href="http:\/\/www.linkedin.com\/in\/alejandrocrosa" target="_blank">Alejandro Crosa<\/a>, <a href="http:\/\/twitter.com\/alejandrocrosa" target="_blank">@alejandrocrosa<\/a>.<\/li><li> Repository: <a href="http:\/\/github.com\/acrosa\/scala-redis" target="_blank">http:\/\/github.com\/acrosa\/scala-redis<\/a><\/li><\/ul>$/;"	a
scardCommand	redis.c	/^static void scardCommand(redisClient *c) {$/;"	f	file:
score	redis.c	/^        double score;$/;"	m	union:_redisSortObject::__anon1	file:
score	redis.c	/^    double score;$/;"	m	struct:zskiplistNode	file:
sdiffCommand	redis.c	/^static void sdiffCommand(redisClient *c) {$/;"	f	file:
sdiffstoreCommand	redis.c	/^static void sdiffstoreCommand(redisClient *c) {$/;"	f	file:
sds	sds.h	/^typedef char *sds;$/;"	t
sdsDictKeyCompare	redis.c	/^static int sdsDictKeyCompare(void *privdata, const void *key1,$/;"	f	file:
sdsMakeRoomFor	sds.c	/^static sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f	file:
sdsOomAbort	sds.c	/^static void sdsOomAbort(void) {$/;"	f	file:
sdsavail	sds.c	/^size_t sdsavail(sds s) {$/;"	f
sdscat	sds.c	/^sds sdscat(sds s, char *t) {$/;"	f
sdscatlen	sds.c	/^sds sdscatlen(sds s, void *t, size_t len) {$/;"	f
sdscatprintf	sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	redis.c	/^static sds sdscatrepr(sds s, char *p, size_t len) {$/;"	f	file:
sdscmp	sds.c	/^int sdscmp(sds s1, sds s2) {$/;"	f
sdscpy	sds.c	/^sds sdscpy(sds s, char *t) {$/;"	f
sdscpylen	sds.c	/^sds sdscpylen(sds s, char *t, size_t len) {$/;"	f
sdsdup	sds.c	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	sds.c	/^sds sdsempty(void) {$/;"	f
sdsfree	sds.c	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f
sdshdr	sds.h	/^struct sdshdr {$/;"	s
sdslen	sds.c	/^size_t sdslen(const sds s) {$/;"	f
sdsnew	sds.c	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	sds.c	/^sds sdsrange(sds s, long start, long end) {$/;"	f
sdssplitargs	sds.c	/^sds *sdssplitargs(char *line, int *argc) {$/;"	f
sdssplitlen	sds.c	/^sds *sdssplitlen(char *s, int len, char *sep, int seplen, int *count) {$/;"	f
sdstolower	sds.c	/^void sdstolower(sds s) {$/;"	f
sdstoupper	sds.c	/^void sdstoupper(sds s) {$/;"	f
sdstrim	sds.c	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdsupdatelen	sds.c	/^void sdsupdatelen(sds s) {$/;"	f
seconds	redis.c	/^    time_t seconds;$/;"	m	struct:saveparam	file:
segvHandler	redis.c	/^static void segvHandler(int sig, siginfo_t *info, void *secret) {$/;"	f	file:
select0	redis.c	/^    *select0, *select1, *select2, *select3, *select4,$/;"	m	struct:sharedObjectsStruct	file:
select1	redis.c	/^    *select0, *select1, *select2, *select3, *select4,$/;"	m	struct:sharedObjectsStruct	file:
select2	redis.c	/^    *select0, *select1, *select2, *select3, *select4,$/;"	m	struct:sharedObjectsStruct	file:
select3	redis.c	/^    *select0, *select1, *select2, *select3, *select4,$/;"	m	struct:sharedObjectsStruct	file:
select4	redis.c	/^    *select0, *select1, *select2, *select3, *select4,$/;"	m	struct:sharedObjectsStruct	file:
select5	redis.c	/^    *select5, *select6, *select7, *select8, *select9,$/;"	m	struct:sharedObjectsStruct	file:
select6	redis.c	/^    *select5, *select6, *select7, *select8, *select9,$/;"	m	struct:sharedObjectsStruct	file:
select7	redis.c	/^    *select5, *select6, *select7, *select8, *select9,$/;"	m	struct:sharedObjectsStruct	file:
select8	redis.c	/^    *select5, *select6, *select7, *select8, *select9,$/;"	m	struct:sharedObjectsStruct	file:
select9	redis.c	/^    *select5, *select6, *select7, *select8, *select9,$/;"	m	struct:sharedObjectsStruct	file:
selectCommand	redis.c	/^static void selectCommand(redisClient *c) {$/;"	f	file:
selectDb	redis-cli.c	/^static int selectDb(int fd) {$/;"	f	file:
selectDb	redis.c	/^static int selectDb(redisClient *c, int id) {$/;"	f	file:
sendBulkToSlave	redis.c	/^static void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
sendReplyToClient	redis.c	/^static void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
sendReplyToClientWritev	redis.c	/^static void sendReplyToClientWritev(aeEventLoop *el, int fd, void *privdata, int mask)$/;"	f	file:
sentlen	redis.c	/^    int sentlen;$/;"	m	struct:redisClient	file:
server	redis.c	/^static struct redisServer server; \/* server global state *\/$/;"	v	typeref:struct:redisServer	file:
serverCron	redis.c	/^static int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f	file:
setCommand	redis.c	/^static void setCommand(redisClient *c) {$/;"	f	file:
setDictType	redis.c	/^static dictType setDictType = {$/;"	v	file:
setExpire	redis.c	/^static int setExpire(redisDb *db, robj *key, time_t when) {$/;"	f	file:
setGenericCommand	redis.c	/^static void setGenericCommand(redisClient *c, int nx, robj *key, robj *val, robj *expire) {$/;"	f	file:
setexCommand	redis.c	/^static void setexCommand(redisClient *c) {$/;"	f	file:
setnxCommand	redis.c	/^static void setnxCommand(redisClient *c) {$/;"	f	file:
setupSigSegvAction	redis.c	/^static void setupSigSegvAction(void) {$/;"	f	file:
shared	redis.c	/^} shared;$/;"	v	typeref:struct:sharedObjectsStruct
sharedObjectsStruct	redis.c	/^struct sharedObjectsStruct {$/;"	s	file:
showInteractiveHelp	redis-cli.c	/^static void showInteractiveHelp(void) {$/;"	f	file:
showLatencyReport	redis-benchmark.c	/^static void showLatencyReport(char *title) {$/;"	f	file:
showPost	doc/TwitterAlikeExample.html	/^function showPost($id) {$/;"	f
showUserPosts	doc/TwitterAlikeExample.html	/^function showUserPosts($userid,$start,$count) {$/;"	f
shutdown	redis-cli.c	/^    int shutdown;$/;"	m	struct:config	file:
shutdownCommand	redis.c	/^static void shutdownCommand(redisClient *c) {$/;"	f	file:
shutdown_asap	redis.c	/^    int shutdown_asap;$/;"	m	struct:redisServer	file:
sigtermHandler	redis.c	/^static void sigtermHandler(int sig) {$/;"	f	file:
sinterCommand	redis.c	/^static void sinterCommand(redisClient *c) {$/;"	f	file:
sinterGenericCommand	redis.c	/^static void sinterGenericCommand(redisClient *c, robj **setskeys, unsigned long setsnum, robj *dstkey) {$/;"	f	file:
sinterstoreCommand	redis.c	/^static void sinterstoreCommand(redisClient *c) {$/;"	f	file:
sismemberCommand	redis.c	/^static void sismemberCommand(redisClient *c) {$/;"	f	file:
size	dict.h	/^    unsigned long size;$/;"	m	struct:dictht
size	redis-check-dump.c	/^    size_t size;$/;"	m	struct:__anon5	file:
sizemask	dict.h	/^    unsigned long sizemask;$/;"	m	struct:dictht
slaveofCommand	redis.c	/^static void slaveofCommand(redisClient *c) {$/;"	f	file:
slaves	redis.c	/^    list *slaves, *monitors;$/;"	m	struct:redisServer	file:
slaveseldb	redis.c	/^    int slaveseldb;         \/* slave selected db, if this client is a slave *\/$/;"	m	struct:redisClient	file:
smoveCommand	redis.c	/^static void smoveCommand(redisClient *c) {$/;"	f	file:
sortCommand	redis.c	/^static void sortCommand(redisClient *c) {$/;"	f	file:
sortCompare	redis.c	/^static int sortCompare(const void *s1, const void *s2) {$/;"	f	file:
sort_alpha	redis.c	/^    int sort_alpha;$/;"	m	struct:redisServer	file:
sort_bypattern	redis.c	/^    int sort_bypattern;$/;"	m	struct:redisServer	file:
sort_desc	redis.c	/^    int sort_desc;$/;"	m	struct:redisServer	file:
space	redis.c	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	file:
span	redis.c	/^    unsigned int *span;$/;"	m	struct:zskiplistNode	file:
spawnIOThread	redis.c	/^static void spawnIOThread(void) {$/;"	f	file:
spopCommand	redis.c	/^static void spopCommand(redisClient *c) {$/;"	f	file:
srandmemberCommand	redis.c	/^static void srandmemberCommand(redisClient *c) {$/;"	f	file:
sremCommand	redis.c	/^static void sremCommand(redisClient *c) {$/;"	f	file:
srv	tests/test_helper.tcl	/^proc srv {level property} {$/;"	p
start	redis-benchmark.c	/^    long long start;    \/* start time in milliseconds *\/$/;"	m	struct:_client	file:
start	redis-benchmark.c	/^    long long start;$/;"	m	struct:config	file:
startAppendOnly	redis.c	/^static int startAppendOnly(void) {$/;"	f	file:
start_server	tests/support/server.tcl	/^proc start_server {options {code undefined}} {$/;"	p
start_server_aof	tests/integration/aof.tcl	/^proc start_server_aof {overrides code} {$/;"	p
stat_expiredkeys	redis.c	/^    long long stat_expiredkeys;   \/* number of expired keys *\/$/;"	m	struct:redisServer	file:
stat_numcommands	redis.c	/^    long long stat_numcommands;    \/* number of processed commands *\/$/;"	m	struct:redisServer	file:
stat_numconnections	redis.c	/^    long long stat_numconnections; \/* number of connections received *\/$/;"	m	struct:redisServer	file:
stat_starttime	redis.c	/^    time_t stat_starttime;         \/* server start time *\/$/;"	m	struct:redisServer	file:
state	redis-benchmark.c	/^    int state;$/;"	m	struct:_client	file:
state	sha1.h	/^    u_int32_t state[5];$/;"	m	struct:__anon8
status	tests/support/util.tcl	/^proc status {r property} {$/;"	p
stdinarg	redis-cli.c	/^    int stdinarg; \/* get last arg from stdin. (-x option) *\/$/;"	m	struct:config	file:
stop	ae.h	/^    int stop;$/;"	m	struct:aeEventLoop
stopAppendOnly	redis.c	/^static void stopAppendOnly(void) {$/;"	f	file:
storage	redis.c	/^    unsigned char storage;  \/* If this object is a key, where is the value?$/;"	m	struct:redisObject	file:
strencoding	redis.c	/^static char* strencoding[] = {$/;"	v	file:
stringObjectLen	redis.c	/^static size_t stringObjectLen(robj *o) {$/;"	f	file:
stringmatch	redis.c	/^static int stringmatch(const char *pattern, const char *string, int nocase) {$/;"	f	file:
stringmatchlen	redis.c	/^static int stringmatchlen(const char *pattern, int patternLen,$/;"	f	file:
subscribeCommand	redis.c	/^static void subscribeCommand(redisClient *c) {$/;"	f	file:
subscribebulk	redis.c	/^    *messagebulk, *pmessagebulk, *subscribebulk, *unsubscribebulk, *mbulk3,$/;"	m	struct:sharedObjectsStruct	file:
substrCommand	redis.c	/^static void substrCommand(redisClient *c) {$/;"	f	file:
success	redis-check-dump.c	/^    char success;$/;"	m	struct:__anon7	file:
sunionCommand	redis.c	/^static void sunionCommand(redisClient *c) {$/;"	f	file:
sunionDiffGenericCommand	redis.c	/^static void sunionDiffGenericCommand(redisClient *c, robj **setskeys, int setsnum, robj *dstkey, int op) {$/;"	f	file:
sunionstoreCommand	redis.c	/^static void sunionstoreCommand(redisClient *c) {$/;"	f	file:
swap	pqsort.c	79;"	d	file:
swapcode	pqsort.c	55;"	d	file:
swapfunc	pqsort.c	/^swapfunc(char *a, char *b, size_t n, int swaptype)$/;"	f	file:
symsTable	staticsymbols.h	/^static struct redisFunctionSym symsTable[] = {$/;"	v	typeref:struct:redisFunctionSym
syncCommand	redis.c	/^static void syncCommand(redisClient *c) {$/;"	f	file:
syncRead	redis.c	/^static int syncRead(int fd, char *ptr, ssize_t size, int timeout) {$/;"	f	file:
syncReadLine	redis.c	/^static int syncReadLine(int fd, char *ptr, ssize_t size, int timeout) {$/;"	f	file:
syncWithMaster	redis.c	/^static int syncWithMaster(void) {$/;"	f	file:
syncWrite	redis.c	/^static int syncWrite(int fd, char *ptr, ssize_t size, int timeout) {$/;"	f	file:
syntaxerr	redis.c	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	file:
table	dict.h	/^    dictEntry **table;$/;"	m	struct:dictht
table	dict.h	/^    int table;$/;"	m	struct:dictIterator
tags	tests/support/server.tcl	/^proc tags {tags code} {$/;"	p
tail	adlist.h	/^    listNode *tail;$/;"	m	struct:list
tail	redis.c	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::	file:
test	tests/support/test.tcl	/^proc test {name code {okpattern notspecified}} {$/;"	p
thread	redis.c	/^    pthread_t thread; \/* ID of the thread processing this entry *\/$/;"	m	struct:iojob	file:
timeEventHead	ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	struct:aeEventLoop
timeEventNextId	ae.h	/^    long long timeEventNextId;$/;"	m	struct:aeEventLoop
timeInMilliseconds	dict.c	/^long long timeInMilliseconds(void) {$/;"	f
timeProc	ae.h	/^    aeTimeProc *timeProc;$/;"	m	struct:aeTimeEvent
tmpdir	tests/support/tmpfile.tcl	/^proc tmpdir {basename} {$/;"	p
tmpfile	tests/support/tmpfile.tcl	/^proc tmpfile {basename} {$/;"	p
totlatency	redis-benchmark.c	/^    long long totlatency;$/;"	m	struct:config	file:
totreceived	redis-benchmark.c	/^    int totreceived;$/;"	m	struct:_client	file:
tryFreeOneObjectFromFreelist	redis.c	/^static int tryFreeOneObjectFromFreelist(void) {$/;"	f	file:
tryObjectEncoding	redis.c	/^static robj *tryObjectEncoding(robj *o) {$/;"	f	file:
tryResizeHashTables	redis.c	/^static void tryResizeHashTables(void) {$/;"	f	file:
ttlCommand	redis.c	/^static void ttlCommand(redisClient *c) {$/;"	f	file:
tty	redis-cli.c	/^    int tty; \/* flag for default output format *\/$/;"	m	struct:config	file:
txredis	doc/SupportedLanguages.html	/^<h3><a name="txredis">txredis<\/a><\/h3><ul><li> Python\/Twisted client for Redis key-value store<\/li><li> Author: Dorian Raymer, <a href="http:\/\/twitter.com\/dio_rian" target="_blank">@dio_rian<\/a>.<\/li><li> PyPI: <a href="http:\/\/pypi.python.org\/pypi\/txredis\/0.1.1" target="_blank">http:\/\/pypi.python.org\/pypi\/txredis\/0.1.1<\/a><\/li><\/ul>$/;"	a
type	dict.h	/^    dictType *type;$/;"	m	struct:dict
type	redis-check-dump.c	/^    int type;$/;"	m	struct:__anon7	file:
type	redis.c	/^    int type;   \/* Request type, REDIS_IOJOB_* *\/$/;"	m	struct:iojob	file:
type	redis.c	/^    int type;$/;"	m	struct:_redisSortOperation	file:
type	redis.c	/^    unsigned char type;$/;"	m	struct:redisObject	file:
typeCommand	redis.c	/^static void typeCommand(redisClient *c) {$/;"	f	file:
types	redis-check-dump.c	/^static char types[256][16];$/;"	v	file:
u	redis.c	/^    } u;$/;"	m	struct:_redisSortObject	typeref:union:_redisSortObject::__anon1	file:
u16	lzfP.h	/^    typedef unsigned int u16;$/;"	t
u16	lzfP.h	/^    typedef unsigned short u16;$/;"	t
u8	lzfP.h	/^typedef unsigned char u8;$/;"	t
u_int	solarisfixes.h	19;"	d
u_int32_t	sha1.h	/^typedef uint32_t u_int32_t;$/;"	t
u_int32_t	solarisfixes.h	20;"	d
uname_S	Makefile	/^uname_S := $(shell sh -c 'uname -s 2>\/dev\/null || echo not')$/;"	m
unblockClientWaitingData	redis.c	/^static void unblockClientWaitingData(redisClient *c) {$/;"	f	file:
unixtime	redis.c	/^    time_t unixtime;    \/* Unix time sampled every second. *\/$/;"	m	struct:redisServer	file:
unlockThreadedIO	redis.c	/^static void unlockThreadedIO(void) {$/;"	f	file:
unsubscribeCommand	redis.c	/^static void unsubscribeCommand(redisClient *c) {$/;"	f	file:
unsubscribebulk	redis.c	/^    *messagebulk, *pmessagebulk, *subscribebulk, *unsubscribebulk, *mbulk3,$/;"	m	struct:sharedObjectsStruct	file:
unsupported_term	linenoise.c	/^static char *unsupported_term[] = {"dumb","cons25",NULL};$/;"	v	file:
updateDictResizePolicy	redis.c	/^static void updateDictResizePolicy(void) {$/;"	f	file:
updateSlavesWaitingBgsave	redis.c	/^static void updateSlavesWaitingBgsave(int bgsaveerr) {$/;"	f	file:
usage	redis-cli.c	/^static void usage() {$/;"	f	file:
usage	redis.c	/^static void usage() {$/;"	f	file:
used	dict.h	/^    unsigned long used;$/;"	m	struct:dictht
used_memory	zmalloc.c	/^static size_t used_memory = 0;$/;"	v	file:
used_memory_mutex	zmalloc.c	/^pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
usedpages	redis.c	/^    off_t usedpages;    \/* number of pages used on disk *\/$/;"	m	struct:redisObjectVM	file:
val	dict.h	/^    void *val;$/;"	m	struct:dictEntry
val	redis.c	/^    robj *val;  \/* the value to swap for REDIS_IOREQ_*_SWAP, otherwise this$/;"	m	struct:iojob	file:
valDestructor	dict.h	/^    void (*valDestructor)(void *privdata, void *obj);$/;"	m	struct:dictType
valDup	dict.h	/^    void *(*valDup)(void *privdata, const void *obj);$/;"	m	struct:dictType
value	adlist.h	/^    void *value;$/;"	m	struct:listNode
vecswap	pqsort.c	87;"	d	file:
verbosity	redis.c	/^    int verbosity;$/;"	m	struct:redisServer	file:
version	redis.c	/^static void version() {$/;"	f	file:
vm	redis.c	/^    struct redisObjectVM vm;$/;"	m	struct:redisObject	typeref:struct:redisObject::redisObjectVM	file:
vm	redis.c	/^} vm;$/;"	v	typeref:struct:redisObjectVM
vmCanSwapOut	redis.c	/^static int vmCanSwapOut(void) {$/;"	f	file:
vmCancelThreadedIOJob	redis.c	/^static void vmCancelThreadedIOJob(robj *o) {$/;"	f	file:
vmFindContiguousPages	redis.c	/^static int vmFindContiguousPages(off_t *first, off_t n) {$/;"	f	file:
vmFreePage	redis.c	/^static int vmFreePage(off_t page) {$/;"	f	file:
vmGenericLoadObject	redis.c	/^static robj *vmGenericLoadObject(robj *key, int preview) {$/;"	f	file:
vmInit	redis.c	/^static void vmInit(void) {$/;"	f	file:
vmLoadObject	redis.c	/^static robj *vmLoadObject(robj *key) {$/;"	f	file:
vmMarkPageFree	redis.c	/^static void vmMarkPageFree(off_t page) {$/;"	f	file:
vmMarkPageUsed	redis.c	/^static void vmMarkPageUsed(off_t page) {$/;"	f	file:
vmMarkPagesFree	redis.c	/^static void vmMarkPagesFree(off_t page, off_t count) {$/;"	f	file:
vmMarkPagesUsed	redis.c	/^static void vmMarkPagesUsed(off_t page, off_t count) {$/;"	f	file:
vmPreviewObject	redis.c	/^static robj *vmPreviewObject(robj *key) {$/;"	f	file:
vmReadObjectFromSwap	redis.c	/^static robj *vmReadObjectFromSwap(off_t page, int type) {$/;"	f	file:
vmReopenSwapFile	redis.c	/^static void vmReopenSwapFile(void) {$/;"	f	file:
vmSwapObjectBlocking	redis.c	/^static int vmSwapObjectBlocking(robj *key, robj *val) {$/;"	f	file:
vmSwapObjectThreaded	redis.c	/^static int vmSwapObjectThreaded(robj *key, robj *val, redisDb *db) {$/;"	f	file:
vmSwapOneObject	redis.c	/^static int vmSwapOneObject(int usethreads) {$/;"	f	file:
vmSwapOneObjectBlocking	redis.c	/^static int vmSwapOneObjectBlocking() {$/;"	f	file:
vmSwapOneObjectThreaded	redis.c	/^static int vmSwapOneObjectThreaded() {$/;"	f	file:
vmThreadedIOCompletedJob	redis.c	/^static void vmThreadedIOCompletedJob(aeEventLoop *el, int fd, void *privdata,$/;"	f	file:
vmWriteObjectOnSwap	redis.c	/^static int vmWriteObjectOnSwap(robj *o, off_t page) {$/;"	f	file:
vm_bitmap	redis.c	/^    unsigned char *vm_bitmap; \/* Bitmap of free\/used pages *\/$/;"	m	struct:redisServer	file:
vm_blocked_clients	redis.c	/^    unsigned int vm_blocked_clients;$/;"	m	struct:redisServer	file:
vm_enabled	redis.c	/^    int vm_enabled;$/;"	m	struct:redisServer	file:
vm_fd	redis.c	/^    int vm_fd;$/;"	m	struct:redisServer	file:
vm_firstkey	redis.c	/^    int vm_firstkey; \/* The first argument that's a key (0 = no keys) *\/$/;"	m	struct:redisCommand	file:
vm_fp	redis.c	/^    FILE *vm_fp;$/;"	m	struct:redisServer	file:
vm_keystep	redis.c	/^    int vm_keystep;  \/* The step between first and last key *\/$/;"	m	struct:redisCommand	file:
vm_lastkey	redis.c	/^    int vm_lastkey;  \/* THe last argument that's a key *\/$/;"	m	struct:redisCommand	file:
vm_max_memory	redis.c	/^    unsigned long long vm_max_memory;$/;"	m	struct:redisServer	file:
vm_max_threads	redis.c	/^    int vm_max_threads; \/* Max number of I\/O threads running at the same time *\/$/;"	m	struct:redisServer	file:
vm_near_pages	redis.c	/^    off_t vm_near_pages; \/* Number of pages allocated sequentially *\/$/;"	m	struct:redisServer	file:
vm_next_page	redis.c	/^    off_t vm_next_page; \/* Next probably empty page *\/$/;"	m	struct:redisServer	file:
vm_page_size	redis.c	/^    off_t vm_page_size;$/;"	m	struct:redisServer	file:
vm_pages	redis.c	/^    off_t vm_pages;$/;"	m	struct:redisServer	file:
vm_preload_proc	redis.c	/^    redisVmPreloadProc *vm_preload_proc;$/;"	m	struct:redisCommand	file:
vm_stats_swapins	redis.c	/^    unsigned long long vm_stats_swapins;$/;"	m	struct:redisServer	file:
vm_stats_swapouts	redis.c	/^    unsigned long long vm_stats_swapouts;$/;"	m	struct:redisServer	file:
vm_stats_swapped_objects	redis.c	/^    unsigned long long vm_stats_swapped_objects;$/;"	m	struct:redisServer	file:
vm_stats_used_pages	redis.c	/^    unsigned long long vm_stats_used_pages;$/;"	m	struct:redisServer	file:
vm_swap_file	redis.c	/^    char *vm_swap_file;$/;"	m	struct:redisServer	file:
vtype	redis.c	/^    unsigned char vtype; \/* If this object is a key, and value is swapped out,$/;"	m	struct:redisObject	file:
waitEmptyIOJobsQueue	redis.c	/^static void waitEmptyIOJobsQueue(void) {$/;"	f	file:
waitForBgrewriteaof	tests/support/util.tcl	/^proc waitForBgrewriteaof r {$/;"	p
waitForBgsave	tests/support/util.tcl	/^proc waitForBgsave r {$/;"	p
waitForMultipleSwappedKeys	redis.c	/^static void waitForMultipleSwappedKeys(redisClient *c, struct redisCommand *cmd, int argc, robj **argv) {$/;"	f	file:
waitForSwappedKey	redis.c	/^static int waitForSwappedKey(redisClient *c, robj *key) {$/;"	f	file:
wait_for_sync	tests/support/util.tcl	/^proc wait_for_sync r {$/;"	p
warnings_from_file	tests/support/util.tcl	/^proc warnings_from_file {filename} {$/;"	p
weight	redis.c	/^    double weight;$/;"	m	struct:__anon2	file:
wfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
wfileProc	ae.h	/^    aeFileProc *wfileProc;$/;"	m	struct:aeFileEvent
when_ms	ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	struct:aeTimeEvent
when_sec	ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	struct:aeTimeEvent
writeHandler	redis-benchmark.c	/^static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask)$/;"	f	file:
written	redis-benchmark.c	/^    unsigned int written;        \/* bytes of 'obuf' already written *\/$/;"	m	struct:_client	file:
wrongtypeerr	redis.c	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	file:
xorDigest	redis.c	/^static void xorDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f	file:
xorObjectDigest	redis.c	/^static void xorObjectDigest(unsigned char *digest, robj *o) {$/;"	f	file:
yesnotoi	redis.c	/^static int yesnotoi(char *s) {$/;"	f	file:
zaddCommand	redis.c	/^static void zaddCommand(redisClient *c) {$/;"	f	file:
zaddGenericCommand	redis.c	/^static void zaddGenericCommand(redisClient *c, robj *key, robj *ele, double scoreval, int doincrement) {$/;"	f	file:
zcardCommand	redis.c	/^static void zcardCommand(redisClient *c) {$/;"	f	file:
zcountCommand	redis.c	/^static void zcountCommand(redisClient *c) {$/;"	f	file:
zfree	zmalloc.c	/^void zfree(void *ptr) {$/;"	f
zi	redis.c	/^    unsigned char *zi;$/;"	m	struct:__anon3	file:
zincrbyCommand	redis.c	/^static void zincrbyCommand(redisClient *c) {$/;"	f	file:
zinterstoreCommand	redis.c	/^static void zinterstoreCommand(redisClient *c) {$/;"	f	file:
zipmapDecodeLength	zipmap.c	/^static unsigned int zipmapDecodeLength(unsigned char *p) {$/;"	f	file:
zipmapDel	zipmap.c	/^unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {$/;"	f
zipmapEncodeLength	zipmap.c	/^static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	file:
zipmapExists	zipmap.c	/^int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {$/;"	f
zipmapGet	zipmap.c	/^int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {$/;"	f
zipmapLen	zipmap.c	/^unsigned int zipmapLen(unsigned char *zm) {$/;"	f
zipmapLookupRaw	zipmap.c	/^static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {$/;"	f	file:
zipmapNew	zipmap.c	/^unsigned char *zipmapNew(void) {$/;"	f
zipmapNext	zipmap.c	/^unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {$/;"	f
zipmapRawEntryLength	zipmap.c	/^static unsigned int zipmapRawEntryLength(unsigned char *p) {$/;"	f	file:
zipmapRawKeyLength	zipmap.c	/^static unsigned int zipmapRawKeyLength(unsigned char *p) {$/;"	f	file:
zipmapRawValueLength	zipmap.c	/^static unsigned int zipmapRawValueLength(unsigned char *p) {$/;"	f	file:
zipmapRepr	zipmap.c	/^void zipmapRepr(unsigned char *p) {$/;"	f
zipmapRequiredLength	zipmap.c	/^static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {$/;"	f	file:
zipmapResize	zipmap.c	/^static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {$/;"	f	file:
zipmapRewind	zipmap.c	/^unsigned char *zipmapRewind(unsigned char *zm) {$/;"	f
zipmapSet	zipmap.c	/^unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {$/;"	f
zk	redis.c	/^    unsigned char *zk, *zv;$/;"	m	struct:__anon3	file:
zklen	redis.c	/^    unsigned int zklen, zvlen;$/;"	m	struct:__anon3	file:
zlistAlikeSort	tests/support/util.tcl	/^proc zlistAlikeSort {a b} {$/;"	p
zmalloc	zmalloc.c	/^void *zmalloc(size_t size) {$/;"	f
zmalloc_enable_thread_safeness	zmalloc.c	/^void zmalloc_enable_thread_safeness(void) {$/;"	f
zmalloc_oom	zmalloc.c	/^static void zmalloc_oom(size_t size) {$/;"	f	file:
zmalloc_thread_safe	zmalloc.c	/^static int zmalloc_thread_safe = 0;$/;"	v	file:
zmalloc_used_memory	zmalloc.c	/^size_t zmalloc_used_memory(void) {$/;"	f
zrangeCommand	redis.c	/^static void zrangeCommand(redisClient *c) {$/;"	f	file:
zrangeGenericCommand	redis.c	/^static void zrangeGenericCommand(redisClient *c, int reverse) {$/;"	f	file:
zrangebyscoreCommand	redis.c	/^static void zrangebyscoreCommand(redisClient *c) {$/;"	f	file:
zrankCommand	redis.c	/^static void zrankCommand(redisClient *c) {$/;"	f	file:
zrankGenericCommand	redis.c	/^static void zrankGenericCommand(redisClient *c, int reverse) {$/;"	f	file:
zrealloc	zmalloc.c	/^void *zrealloc(void *ptr, size_t size) {$/;"	f
zremCommand	redis.c	/^static void zremCommand(redisClient *c) {$/;"	f	file:
zremrangebyrankCommand	redis.c	/^static void zremrangebyrankCommand(redisClient *c) {$/;"	f	file:
zremrangebyscoreCommand	redis.c	/^static void zremrangebyscoreCommand(redisClient *c) {$/;"	f	file:
zrevrangeCommand	redis.c	/^static void zrevrangeCommand(redisClient *c) {$/;"	f	file:
zrevrankCommand	redis.c	/^static void zrevrankCommand(redisClient *c) {$/;"	f	file:
zscoreCommand	redis.c	/^static void zscoreCommand(redisClient *c) {$/;"	f	file:
zset	redis.c	/^typedef struct zset {$/;"	s	file:
zset	redis.c	/^} zset;$/;"	t	typeref:struct:zset	file:
zsetDictType	redis.c	/^static dictType zsetDictType = {$/;"	v	file:
zsetopsrc	redis.c	/^} zsetopsrc;$/;"	t	typeref:struct:__anon2	file:
zskiplist	redis.c	/^typedef struct zskiplist {$/;"	s	file:
zskiplist	redis.c	/^} zskiplist;$/;"	t	typeref:struct:zskiplist	file:
zskiplistNode	redis.c	/^typedef struct zskiplistNode {$/;"	s	file:
zskiplistNode	redis.c	/^} zskiplistNode;$/;"	t	typeref:struct:zskiplistNode	file:
zsl	redis.c	/^    zskiplist *zsl;$/;"	m	struct:zset	file:
zslCreate	redis.c	/^static zskiplist *zslCreate(void) {$/;"	f	file:
zslCreateNode	redis.c	/^static zskiplistNode *zslCreateNode(int level, double score, robj *obj) {$/;"	f	file:
zslDelete	redis.c	/^static int zslDelete(zskiplist *zsl, double score, robj *obj) {$/;"	f	file:
zslDeleteNode	redis.c	/^void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {$/;"	f
zslDeleteRangeByRank	redis.c	/^static unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {$/;"	f	file:
zslDeleteRangeByScore	redis.c	/^static unsigned long zslDeleteRangeByScore(zskiplist *zsl, double min, double max, dict *dict) {$/;"	f	file:
zslFirstWithScore	redis.c	/^static zskiplistNode *zslFirstWithScore(zskiplist *zsl, double score) {$/;"	f	file:
zslFree	redis.c	/^static void zslFree(zskiplist *zsl) {$/;"	f	file:
zslFreeNode	redis.c	/^static void zslFreeNode(zskiplistNode *node) {$/;"	f	file:
zslGetElementByRank	redis.c	/^zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {$/;"	f
zslGetRank	redis.c	/^static unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) {$/;"	f	file:
zslInsert	redis.c	/^static void zslInsert(zskiplist *zsl, double score, robj *obj) {$/;"	f	file:
zslRandomLevel	redis.c	/^static int zslRandomLevel(void) {$/;"	f	file:
zstrdup	zmalloc.c	/^char *zstrdup(const char *s) {$/;"	f
zunionInterAggregate	redis.c	/^inline static void zunionInterAggregate(double *target, double val, int aggregate) {$/;"	f	file:
zunionInterBlockClientOnSwappedKeys	redis.c	/^static void zunionInterBlockClientOnSwappedKeys(redisClient *c, struct redisCommand *cmd, int argc, robj **argv) {$/;"	f	file:
zunionInterGenericCommand	redis.c	/^static void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {$/;"	f	file:
zunionstoreCommand	redis.c	/^static void zunionstoreCommand(redisClient *c) {$/;"	f	file:
zv	redis.c	/^    unsigned char *zk, *zv;$/;"	m	struct:__anon3	file:
zvlen	redis.c	/^    unsigned int zklen, zvlen;$/;"	m	struct:__anon3	file:
